import {
  getEnvironmentData,
  getLastSeenUserIdAfterAuth,
  getSensitiveEnvironmentData
} from "./chunk-5OP2SA7G.js";
import {
  fetch
} from "./chunk-GDYKHT64.js";
import {
  runWithRateLimit
} from "./chunk-FDJVVEGH.js";
import {
  CLI_KIT_VERSION
} from "./chunk-43YGIE7Y.js";
import {
  alwaysLogAnalytics,
  alwaysLogMetrics,
  analyticsDisabled,
  getAllPublicMetadata,
  getAllSensitiveMetadata,
  getArrayContainsDuplicates,
  getArrayRejectingUndefined,
  isShopify,
  isSpinEnvironment,
  isUnitTest,
  opentelemetryDomain,
  outputContent,
  outputDebug,
  outputToken
} from "./chunk-PJKCWDDX.js";
import {
  reportingRateLimit
} from "./chunk-XEDHKQZA.js";
import {
  __commonJS,
  __require,
  __toESM,
  init_cjs_shims
} from "./chunk-POZ5MGPT.js";

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationTemporality.js
var require_AggregationTemporality = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationTemporality.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AggregationTemporality = void 0;
    var AggregationTemporality2;
    (function(AggregationTemporality3) {
      AggregationTemporality3[AggregationTemporality3.DELTA = 0] = "DELTA", AggregationTemporality3[AggregationTemporality3.CUMULATIVE = 1] = "CUMULATIVE";
    })(AggregationTemporality2 = exports.AggregationTemporality || (exports.AggregationTemporality = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricData.js
var require_MetricData = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricData.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DataPointType = void 0;
    var DataPointType;
    (function(DataPointType2) {
      DataPointType2[DataPointType2.HISTOGRAM = 0] = "HISTOGRAM", DataPointType2[DataPointType2.EXPONENTIAL_HISTOGRAM = 1] = "EXPONENTIAL_HISTOGRAM", DataPointType2[DataPointType2.GAUGE = 2] = "GAUGE", DataPointType2[DataPointType2.SUM = 3] = "SUM";
    })(DataPointType = exports.DataPointType || (exports.DataPointType = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis == "object" ? globalThis : global;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/platform/node/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_globalThis(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/platform/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_node(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/version.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.VERSION = void 0;
    exports.VERSION = "1.6.0";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/internal/semver.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isCompatible = exports._makeCompatibilityCheck = void 0;
    var version_1 = require_version(), re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    function _makeCompatibilityCheck(ownVersion) {
      let acceptedVersions = /* @__PURE__ */ new Set([ownVersion]), rejectedVersions = /* @__PURE__ */ new Set(), myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch)
        return () => !1;
      let ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
      };
      if (ownVersionParsed.prerelease != null)
        return function(globalVersion) {
          return globalVersion === ownVersion;
        };
      function _reject(v) {
        return rejectedVersions.add(v), !1;
      }
      function _accept(v) {
        return acceptedVersions.add(v), !0;
      }
      return function(globalVersion) {
        if (acceptedVersions.has(globalVersion))
          return !0;
        if (rejectedVersions.has(globalVersion))
          return !1;
        let globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch)
          return _reject(globalVersion);
        let globalVersionParsed = {
          major: +globalVersionMatch[1],
          minor: +globalVersionMatch[2],
          patch: +globalVersionMatch[3],
          prerelease: globalVersionMatch[4]
        };
        return globalVersionParsed.prerelease != null || ownVersionParsed.major !== globalVersionParsed.major ? _reject(globalVersion) : ownVersionParsed.major === 0 ? ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch ? _accept(globalVersion) : _reject(globalVersion) : ownVersionParsed.minor <= globalVersionParsed.minor ? _accept(globalVersion) : _reject(globalVersion);
      };
    }
    exports._makeCompatibilityCheck = _makeCompatibilityCheck;
    exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/internal/global-utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = void 0;
    var platform_1 = require_platform(), version_1 = require_version(), semver_1 = require_semver(), major = version_1.VERSION.split(".")[0], GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`), _global = platform_1._globalThis;
    function registerGlobal(type, instance, diag4, allowOverride = !1) {
      var _a;
      let api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: version_1.VERSION
      };
      if (!allowOverride && api[type]) {
        let err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
        return diag4.error(err.stack || err.message), !1;
      }
      if (api.version !== version_1.VERSION) {
        let err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
        return diag4.error(err.stack || err.message), !1;
      }
      return api[type] = instance, diag4.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`), !0;
    }
    exports.registerGlobal = registerGlobal;
    function getGlobal(type) {
      var _a, _b;
      let globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
      if (!(!globalVersion || !(0, semver_1.isCompatible)(globalVersion)))
        return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
    }
    exports.getGlobal = getGlobal;
    function unregisterGlobal(type, diag4) {
      diag4.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
      let api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
      api && delete api[type];
    }
    exports.unregisterGlobal = unregisterGlobal;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DiagComponentLogger = void 0;
    var global_utils_1 = require_global_utils(), DiagComponentLogger = class {
      constructor(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      debug(...args) {
        return logProxy("debug", this._namespace, args);
      }
      error(...args) {
        return logProxy("error", this._namespace, args);
      }
      info(...args) {
        return logProxy("info", this._namespace, args);
      }
      warn(...args) {
        return logProxy("warn", this._namespace, args);
      }
      verbose(...args) {
        return logProxy("verbose", this._namespace, args);
      }
    };
    exports.DiagComponentLogger = DiagComponentLogger;
    function logProxy(funcName, namespace, args) {
      let logger = (0, global_utils_1.getGlobal)("diag");
      if (logger)
        return args.unshift(namespace), logger[funcName](...args);
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/diag/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DiagLogLevel = void 0;
    var DiagLogLevel2;
    (function(DiagLogLevel3) {
      DiagLogLevel3[DiagLogLevel3.NONE = 0] = "NONE", DiagLogLevel3[DiagLogLevel3.ERROR = 30] = "ERROR", DiagLogLevel3[DiagLogLevel3.WARN = 50] = "WARN", DiagLogLevel3[DiagLogLevel3.INFO = 60] = "INFO", DiagLogLevel3[DiagLogLevel3.DEBUG = 70] = "DEBUG", DiagLogLevel3[DiagLogLevel3.VERBOSE = 80] = "VERBOSE", DiagLogLevel3[DiagLogLevel3.ALL = 9999] = "ALL";
    })(DiagLogLevel2 = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.createLogLevelDiagLogger = void 0;
    var types_1 = require_types();
    function createLogLevelDiagLogger(maxLevel, logger) {
      maxLevel < types_1.DiagLogLevel.NONE ? maxLevel = types_1.DiagLogLevel.NONE : maxLevel > types_1.DiagLogLevel.ALL && (maxLevel = types_1.DiagLogLevel.ALL), logger = logger || {};
      function _filterFunc(funcName, theLevel) {
        let theFunc = logger[funcName];
        return typeof theFunc == "function" && maxLevel >= theLevel ? theFunc.bind(logger) : function() {
        };
      }
      return {
        error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
        warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
        info: _filterFunc("info", types_1.DiagLogLevel.INFO),
        debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
        verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
      };
    }
    exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/api/diag.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DiagAPI = void 0;
    var ComponentLogger_1 = require_ComponentLogger(), logLevelLogger_1 = require_logLevelLogger(), types_1 = require_types(), global_utils_1 = require_global_utils(), API_NAME = "diag", DiagAPI = class _DiagAPI {
      /**
       * Private internal constructor
       * @private
       */
      constructor() {
        function _logProxy(funcName) {
          return function(...args) {
            let logger = (0, global_utils_1.getGlobal)("diag");
            if (logger)
              return logger[funcName](...args);
          };
        }
        let self2 = this, setLogger = (logger, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
          var _a, _b, _c;
          if (logger === self2) {
            let err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            return self2.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message), !1;
          }
          typeof optionsOrLogLevel == "number" && (optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          });
          let oldLogger = (0, global_utils_1.getGlobal)("diag"), newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : types_1.DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            let stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn(`Current logger will be overwritten from ${stack}`), newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
          }
          return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, !0);
        };
        self2.setLogger = setLogger, self2.disable = () => {
          (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
        }, self2.createComponentLogger = (options) => new ComponentLogger_1.DiagComponentLogger(options), self2.verbose = _logProxy("verbose"), self2.debug = _logProxy("debug"), self2.info = _logProxy("info"), self2.warn = _logProxy("warn"), self2.error = _logProxy("error");
      }
      /** Get the singleton instance of the DiagAPI API */
      static instance() {
        return this._instance || (this._instance = new _DiagAPI()), this._instance;
      }
    };
    exports.DiagAPI = DiagAPI;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.BaggageImpl = void 0;
    var BaggageImpl = class _BaggageImpl {
      constructor(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      getEntry(key) {
        let entry = this._entries.get(key);
        if (entry)
          return Object.assign({}, entry);
      }
      getAllEntries() {
        return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
      }
      setEntry(key, entry) {
        let newBaggage = new _BaggageImpl(this._entries);
        return newBaggage._entries.set(key, entry), newBaggage;
      }
      removeEntry(key) {
        let newBaggage = new _BaggageImpl(this._entries);
        return newBaggage._entries.delete(key), newBaggage;
      }
      removeEntries(...keys) {
        let newBaggage = new _BaggageImpl(this._entries);
        for (let key of keys)
          newBaggage._entries.delete(key);
        return newBaggage;
      }
      clear() {
        return new _BaggageImpl();
      }
    };
    exports.BaggageImpl = BaggageImpl;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.baggageEntryMetadataSymbol = void 0;
    exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/baggage/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.baggageEntryMetadataFromString = exports.createBaggage = void 0;
    var diag_1 = require_diag(), baggage_impl_1 = require_baggage_impl(), symbol_1 = require_symbol(), diag4 = diag_1.DiagAPI.instance();
    function createBaggage(entries = {}) {
      return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
    }
    exports.createBaggage = createBaggage;
    function baggageEntryMetadataFromString(str) {
      return typeof str != "string" && (diag4.error(`Cannot create baggage metadata from unknown type: ${typeof str}`), str = ""), {
        __TYPE__: symbol_1.baggageEntryMetadataSymbol,
        toString() {
          return str;
        }
      };
    }
    exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/context/context.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ROOT_CONTEXT = exports.createContextKey = void 0;
    function createContextKey(description) {
      return Symbol.for(description);
    }
    exports.createContextKey = createContextKey;
    var BaseContext = class _BaseContext {
      /**
       * Construct a new context which inherits values from an optional parent context.
       *
       * @param parentContext a context from which to inherit values
       */
      constructor(parentContext) {
        let self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map(), self2.getValue = (key) => self2._currentContext.get(key), self2.setValue = (key, value) => {
          let context = new _BaseContext(self2._currentContext);
          return context._currentContext.set(key, value), context;
        }, self2.deleteValue = (key) => {
          let context = new _BaseContext(self2._currentContext);
          return context._currentContext.delete(key), context;
        };
      }
    };
    exports.ROOT_CONTEXT = new BaseContext();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DiagConsoleLogger = void 0;
    var consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ], DiagConsoleLogger2 = class {
      constructor() {
        function _consoleFunc(funcName) {
          return function(...args) {
            if (console) {
              let theFunc = console[funcName];
              if (typeof theFunc != "function" && (theFunc = console.log), typeof theFunc == "function")
                return theFunc.apply(console, args);
            }
          };
        }
        for (let i = 0; i < consoleMap.length; i++)
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    };
    exports.DiagConsoleLogger = DiagConsoleLogger2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = void 0;
    var NoopMeter = class {
      constructor() {
      }
      /**
       * @see {@link Meter.createHistogram}
       */
      createHistogram(_name, _options) {
        return exports.NOOP_HISTOGRAM_METRIC;
      }
      /**
       * @see {@link Meter.createCounter}
       */
      createCounter(_name, _options) {
        return exports.NOOP_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createUpDownCounter}
       */
      createUpDownCounter(_name, _options) {
        return exports.NOOP_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableGauge}
       */
      createObservableGauge(_name, _options) {
        return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createObservableCounter}
       */
      createObservableCounter(_name, _options) {
        return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableUpDownCounter}
       */
      createObservableUpDownCounter(_name, _options) {
        return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(_callback, _observables) {
      }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(_callback) {
      }
    };
    exports.NoopMeter = NoopMeter;
    var NoopMetric = class {
    };
    exports.NoopMetric = NoopMetric;
    var NoopCounterMetric = class extends NoopMetric {
      add(_value, _attributes) {
      }
    };
    exports.NoopCounterMetric = NoopCounterMetric;
    var NoopUpDownCounterMetric = class extends NoopMetric {
      add(_value, _attributes) {
      }
    };
    exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
    var NoopHistogramMetric = class extends NoopMetric {
      record(_value, _attributes) {
      }
    };
    exports.NoopHistogramMetric = NoopHistogramMetric;
    var NoopObservableMetric = class {
      addCallback(_callback) {
      }
      removeCallback(_callback) {
      }
    };
    exports.NoopObservableMetric = NoopObservableMetric;
    var NoopObservableCounterMetric = class extends NoopObservableMetric {
    };
    exports.NoopObservableCounterMetric = NoopObservableCounterMetric;
    var NoopObservableGaugeMetric = class extends NoopObservableMetric {
    };
    exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
    var NoopObservableUpDownCounterMetric = class extends NoopObservableMetric {
    };
    exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
    exports.NOOP_METER = new NoopMeter();
    exports.NOOP_COUNTER_METRIC = new NoopCounterMetric();
    exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
    function createNoopMeter() {
      return exports.NOOP_METER;
    }
    exports.createNoopMeter = createNoopMeter;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/metrics/Metric.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ValueType = void 0;
    var ValueType2;
    (function(ValueType3) {
      ValueType3[ValueType3.INT = 0] = "INT", ValueType3[ValueType3.DOUBLE = 1] = "DOUBLE";
    })(ValueType2 = exports.ValueType || (exports.ValueType = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.defaultTextMapSetter = exports.defaultTextMapGetter = void 0;
    exports.defaultTextMapGetter = {
      get(carrier, key) {
        if (carrier != null)
          return carrier[key];
      },
      keys(carrier) {
        return carrier == null ? [] : Object.keys(carrier);
      }
    };
    exports.defaultTextMapSetter = {
      set(carrier, key, value) {
        carrier != null && (carrier[key] = value);
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.NoopContextManager = void 0;
    var context_1 = require_context(), NoopContextManager = class {
      active() {
        return context_1.ROOT_CONTEXT;
      }
      with(_context, fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      bind(_context, target) {
        return target;
      }
      enable() {
        return this;
      }
      disable() {
        return this;
      }
    };
    exports.NoopContextManager = NoopContextManager;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/api/context.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ContextAPI = void 0;
    var NoopContextManager_1 = require_NoopContextManager(), global_utils_1 = require_global_utils(), diag_1 = require_diag(), API_NAME = "context", NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager(), ContextAPI = class _ContextAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Context API */
      static getInstance() {
        return this._instance || (this._instance = new _ContextAPI()), this._instance;
      }
      /**
       * Set the current context manager.
       *
       * @returns true if the context manager was successfully registered, else false
       */
      setGlobalContextManager(contextManager) {
        return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
      }
      /**
       * Get the currently active context
       */
      active() {
        return this._getContextManager().active();
      }
      /**
       * Execute a function with an active context
       *
       * @param context context to be active during function execution
       * @param fn function to execute in a context
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      with(context, fn, thisArg, ...args) {
        return this._getContextManager().with(context, fn, thisArg, ...args);
      }
      /**
       * Bind a context to a target function or event emitter
       *
       * @param context context to bind to the event emitter or function. Defaults to the currently active context
       * @param target function or event emitter to bind
       */
      bind(context, target) {
        return this._getContextManager().bind(context, target);
      }
      _getContextManager() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
      }
      /** Disable and remove the global context manager */
      disable() {
        this._getContextManager().disable(), (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    exports.ContextAPI = ContextAPI;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/trace_flags.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TraceFlags = void 0;
    var TraceFlags;
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2.NONE = 0] = "NONE", TraceFlags2[TraceFlags2.SAMPLED = 1] = "SAMPLED";
    })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = void 0;
    var trace_flags_1 = require_trace_flags();
    exports.INVALID_SPANID = "0000000000000000";
    exports.INVALID_TRACEID = "00000000000000000000000000000000";
    exports.INVALID_SPAN_CONTEXT = {
      traceId: exports.INVALID_TRACEID,
      spanId: exports.INVALID_SPANID,
      traceFlags: trace_flags_1.TraceFlags.NONE
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.NonRecordingSpan = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants(), NonRecordingSpan = class {
      constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
        this._spanContext = _spanContext;
      }
      // Returns a SpanContext.
      spanContext() {
        return this._spanContext;
      }
      // By default does nothing
      setAttribute(_key, _value) {
        return this;
      }
      // By default does nothing
      setAttributes(_attributes) {
        return this;
      }
      // By default does nothing
      addEvent(_name, _attributes) {
        return this;
      }
      // By default does nothing
      setStatus(_status) {
        return this;
      }
      // By default does nothing
      updateName(_name) {
        return this;
      }
      // By default does nothing
      end(_endTime) {
      }
      // isRecording always returns false for NonRecordingSpan.
      isRecording() {
        return !1;
      }
      // By default does nothing
      recordException(_exception, _time) {
      }
    };
    exports.NonRecordingSpan = NonRecordingSpan;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/context-utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = void 0;
    var context_1 = require_context(), NonRecordingSpan_1 = require_NonRecordingSpan(), context_2 = require_context2(), SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
    function getSpan(context) {
      return context.getValue(SPAN_KEY) || void 0;
    }
    exports.getSpan = getSpan;
    function getActiveSpan() {
      return getSpan(context_2.ContextAPI.getInstance().active());
    }
    exports.getActiveSpan = getActiveSpan;
    function setSpan(context, span) {
      return context.setValue(SPAN_KEY, span);
    }
    exports.setSpan = setSpan;
    function deleteSpan(context) {
      return context.deleteValue(SPAN_KEY);
    }
    exports.deleteSpan = deleteSpan;
    function setSpanContext(context, spanContext) {
      return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
    }
    exports.setSpanContext = setSpanContext;
    function getSpanContext(context) {
      var _a;
      return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
    }
    exports.getSpanContext = getSpanContext;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants(), NonRecordingSpan_1 = require_NonRecordingSpan(), VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i, VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
    function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
    }
    exports.isValidTraceId = isValidTraceId;
    function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
    }
    exports.isValidSpanId = isValidSpanId;
    function isSpanContextValid(spanContext) {
      return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
    }
    exports.isSpanContextValid = isSpanContextValid;
    function wrapSpanContext(spanContext) {
      return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
    }
    exports.wrapSpanContext = wrapSpanContext;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.NoopTracer = void 0;
    var context_1 = require_context2(), context_utils_1 = require_context_utils(), NonRecordingSpan_1 = require_NonRecordingSpan(), spancontext_utils_1 = require_spancontext_utils(), contextApi = context_1.ContextAPI.getInstance(), NoopTracer = class {
      // startSpan starts a noop span.
      startSpan(name, options, context = contextApi.active()) {
        if (!!options?.root)
          return new NonRecordingSpan_1.NonRecordingSpan();
        let parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
        return isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext) ? new NonRecordingSpan_1.NonRecordingSpan(parentFromContext) : new NonRecordingSpan_1.NonRecordingSpan();
      }
      startActiveSpan(name, arg2, arg3, arg4) {
        let opts, ctx, fn;
        if (arguments.length < 2)
          return;
        arguments.length === 2 ? fn = arg2 : arguments.length === 3 ? (opts = arg2, fn = arg3) : (opts = arg2, ctx = arg3, fn = arg4);
        let parentContext = ctx ?? contextApi.active(), span = this.startSpan(name, opts, parentContext), contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      }
    };
    exports.NoopTracer = NoopTracer;
    function isSpanContext(spanContext) {
      return typeof spanContext == "object" && typeof spanContext.spanId == "string" && typeof spanContext.traceId == "string" && typeof spanContext.traceFlags == "number";
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ProxyTracer = void 0;
    var NoopTracer_1 = require_NoopTracer(), NOOP_TRACER = new NoopTracer_1.NoopTracer(), ProxyTracer = class {
      constructor(_provider, name, version, options) {
        this._provider = _provider, this.name = name, this.version = version, this.options = options;
      }
      startSpan(name, options, context) {
        return this._getTracer().startSpan(name, options, context);
      }
      startActiveSpan(_name, _options, _context, _fn) {
        let tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      }
      /**
       * Try to get a tracer from the proxy tracer provider.
       * If the proxy tracer provider has no delegate, return a noop tracer.
       */
      _getTracer() {
        if (this._delegate)
          return this._delegate;
        let tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        return tracer ? (this._delegate = tracer, this._delegate) : NOOP_TRACER;
      }
    };
    exports.ProxyTracer = ProxyTracer;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.NoopTracerProvider = void 0;
    var NoopTracer_1 = require_NoopTracer(), NoopTracerProvider = class {
      getTracer(_name, _version, _options) {
        return new NoopTracer_1.NoopTracer();
      }
    };
    exports.NoopTracerProvider = NoopTracerProvider;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ProxyTracerProvider = void 0;
    var ProxyTracer_1 = require_ProxyTracer(), NoopTracerProvider_1 = require_NoopTracerProvider(), NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider(), ProxyTracerProvider = class {
      /**
       * Get a {@link ProxyTracer}
       */
      getTracer(name, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer_1.ProxyTracer(this, name, version, options);
      }
      getDelegate() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      }
      /**
       * Set the delegate tracer provider
       */
      setDelegate(delegate) {
        this._delegate = delegate;
      }
      getDelegateTracer(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      }
    };
    exports.ProxyTracerProvider = ProxyTracerProvider;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.SamplingDecision = void 0;
    var SamplingDecision;
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2.NOT_RECORD = 0] = "NOT_RECORD", SamplingDecision2[SamplingDecision2.RECORD = 1] = "RECORD", SamplingDecision2[SamplingDecision2.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/span_kind.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.SpanKind = void 0;
    var SpanKind;
    (function(SpanKind2) {
      SpanKind2[SpanKind2.INTERNAL = 0] = "INTERNAL", SpanKind2[SpanKind2.SERVER = 1] = "SERVER", SpanKind2[SpanKind2.CLIENT = 2] = "CLIENT", SpanKind2[SpanKind2.PRODUCER = 3] = "PRODUCER", SpanKind2[SpanKind2.CONSUMER = 4] = "CONSUMER";
    })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/status.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.SpanStatusCode = void 0;
    var SpanStatusCode;
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2.UNSET = 0] = "UNSET", SpanStatusCode2[SpanStatusCode2.OK = 1] = "OK", SpanStatusCode2[SpanStatusCode2.ERROR = 2] = "ERROR";
    })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]", VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`, VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`, VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`), VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/, INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    exports.validateKey = validateKey;
    function validateValue(value) {
      return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
    }
    exports.validateValue = validateValue;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TraceStateImpl = void 0;
    var tracestate_validators_1 = require_tracestate_validators(), MAX_TRACE_STATE_ITEMS = 32, MAX_TRACE_STATE_LEN = 512, LIST_MEMBERS_SEPARATOR = ",", LIST_MEMBER_KEY_VALUE_SPLITTER = "=", TraceStateImpl = class _TraceStateImpl {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map(), rawTraceState && this._parse(rawTraceState);
      }
      set(key, value) {
        let traceState = this._clone();
        return traceState._internalState.has(key) && traceState._internalState.delete(key), traceState._internalState.set(key, value), traceState;
      }
      unset(key) {
        let traceState = this._clone();
        return traceState._internalState.delete(key), traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => (agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key)), agg), []).join(LIST_MEMBERS_SEPARATOR);
      }
      _parse(rawTraceState) {
        rawTraceState.length > MAX_TRACE_STATE_LEN || (this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
          let listMember = part.trim(), i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            let key = listMember.slice(0, i), value = listMember.slice(i + 1, part.length);
            (0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value) && agg.set(key, value);
          }
          return agg;
        }, /* @__PURE__ */ new Map()), this._internalState.size > MAX_TRACE_STATE_ITEMS && (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS))));
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        let traceState = new _TraceStateImpl();
        return traceState._internalState = new Map(this._internalState), traceState;
      }
    };
    exports.TraceStateImpl = TraceStateImpl;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace/internal/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.createTraceState = void 0;
    var tracestate_impl_1 = require_tracestate_impl();
    function createTraceState(rawTraceState) {
      return new tracestate_impl_1.TraceStateImpl(rawTraceState);
    }
    exports.createTraceState = createTraceState;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/context-api.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.context = void 0;
    var context_1 = require_context2();
    exports.context = context_1.ContextAPI.getInstance();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/diag-api.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.diag = void 0;
    var diag_1 = require_diag();
    exports.diag = diag_1.DiagAPI.instance();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = void 0;
    var NoopMeter_1 = require_NoopMeter(), NoopMeterProvider = class {
      getMeter(_name, _version, _options) {
        return NoopMeter_1.NOOP_METER;
      }
    };
    exports.NoopMeterProvider = NoopMeterProvider;
    exports.NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/api/metrics.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MetricsAPI = void 0;
    var NoopMeterProvider_1 = require_NoopMeterProvider(), global_utils_1 = require_global_utils(), diag_1 = require_diag(), API_NAME = "metrics", MetricsAPI = class _MetricsAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Metrics API */
      static getInstance() {
        return this._instance || (this._instance = new _MetricsAPI()), this._instance;
      }
      /**
       * Set the current global meter provider.
       * Returns true if the meter provider was successfully registered, else false.
       */
      setGlobalMeterProvider(provider) {
        return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
      }
      /**
       * Returns the global meter provider.
       */
      getMeterProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
      }
      /**
       * Returns a meter from the global meter provider.
       */
      getMeter(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      }
      /** Remove the global meter provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    exports.MetricsAPI = MetricsAPI;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/metrics-api.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.metrics = void 0;
    var metrics_1 = require_metrics();
    exports.metrics = metrics_1.MetricsAPI.getInstance();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.NoopTextMapPropagator = void 0;
    var NoopTextMapPropagator = class {
      /** Noop inject function does nothing */
      inject(_context, _carrier) {
      }
      /** Noop extract function does nothing and returns the input context */
      extract(context, _carrier) {
        return context;
      }
      fields() {
        return [];
      }
    };
    exports.NoopTextMapPropagator = NoopTextMapPropagator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = void 0;
    var context_1 = require_context2(), context_2 = require_context(), BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
    function getBaggage(context) {
      return context.getValue(BAGGAGE_KEY) || void 0;
    }
    exports.getBaggage = getBaggage;
    function getActiveBaggage() {
      return getBaggage(context_1.ContextAPI.getInstance().active());
    }
    exports.getActiveBaggage = getActiveBaggage;
    function setBaggage(context, baggage) {
      return context.setValue(BAGGAGE_KEY, baggage);
    }
    exports.setBaggage = setBaggage;
    function deleteBaggage(context) {
      return context.deleteValue(BAGGAGE_KEY);
    }
    exports.deleteBaggage = deleteBaggage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/api/propagation.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.PropagationAPI = void 0;
    var global_utils_1 = require_global_utils(), NoopTextMapPropagator_1 = require_NoopTextMapPropagator(), TextMapPropagator_1 = require_TextMapPropagator(), context_helpers_1 = require_context_helpers(), utils_1 = require_utils(), diag_1 = require_diag(), API_NAME = "propagation", NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator(), PropagationAPI = class _PropagationAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this.createBaggage = utils_1.createBaggage, this.getBaggage = context_helpers_1.getBaggage, this.getActiveBaggage = context_helpers_1.getActiveBaggage, this.setBaggage = context_helpers_1.setBaggage, this.deleteBaggage = context_helpers_1.deleteBaggage;
      }
      /** Get the singleton instance of the Propagator API */
      static getInstance() {
        return this._instance || (this._instance = new _PropagationAPI()), this._instance;
      }
      /**
       * Set the current propagator.
       *
       * @returns true if the propagator was successfully registered, else false
       */
      setGlobalPropagator(propagator) {
        return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
      }
      /**
       * Inject context into a carrier to be propagated inter-process
       *
       * @param context Context carrying tracing data to inject
       * @param carrier carrier to inject context into
       * @param setter Function used to set values on the carrier
       */
      inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
        return this._getGlobalPropagator().inject(context, carrier, setter);
      }
      /**
       * Extract context from a carrier
       *
       * @param context Context which the newly created context will inherit from
       * @param carrier Carrier to extract context from
       * @param getter Function used to extract keys from a carrier
       */
      extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
        return this._getGlobalPropagator().extract(context, carrier, getter);
      }
      /**
       * Return a list of all fields which may be used by the propagator.
       */
      fields() {
        return this._getGlobalPropagator().fields();
      }
      /** Remove the global propagator */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
      _getGlobalPropagator() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
      }
    };
    exports.PropagationAPI = PropagationAPI;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/propagation-api.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.propagation = void 0;
    var propagation_1 = require_propagation();
    exports.propagation = propagation_1.PropagationAPI.getInstance();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/api/trace.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TraceAPI = void 0;
    var global_utils_1 = require_global_utils(), ProxyTracerProvider_1 = require_ProxyTracerProvider(), spancontext_utils_1 = require_spancontext_utils(), context_utils_1 = require_context_utils(), diag_1 = require_diag(), API_NAME = "trace", TraceAPI = class _TraceAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider(), this.wrapSpanContext = spancontext_utils_1.wrapSpanContext, this.isSpanContextValid = spancontext_utils_1.isSpanContextValid, this.deleteSpan = context_utils_1.deleteSpan, this.getSpan = context_utils_1.getSpan, this.getActiveSpan = context_utils_1.getActiveSpan, this.getSpanContext = context_utils_1.getSpanContext, this.setSpan = context_utils_1.setSpan, this.setSpanContext = context_utils_1.setSpanContext;
      }
      /** Get the singleton instance of the Trace API */
      static getInstance() {
        return this._instance || (this._instance = new _TraceAPI()), this._instance;
      }
      /**
       * Set the current global tracer.
       *
       * @returns true if the tracer provider was successfully registered, else false
       */
      setGlobalTracerProvider(provider) {
        let success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
        return success && this._proxyTracerProvider.setDelegate(provider), success;
      }
      /**
       * Returns the global tracer provider.
       */
      getTracerProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
      }
      /**
       * Returns a tracer from the global tracer provider.
       */
      getTracer(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      }
      /** Remove the global tracer provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance()), this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
      }
    };
    exports.TraceAPI = TraceAPI;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/trace-api.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.trace = void 0;
    var trace_1 = require_trace();
    exports.trace = trace_1.TraceAPI.getInstance();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+api@1.6.0/node_modules/@opentelemetry/api/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = void 0;
    var utils_1 = require_utils();
    Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: !0, get: function() {
      return utils_1.baggageEntryMetadataFromString;
    } });
    var context_1 = require_context();
    Object.defineProperty(exports, "createContextKey", { enumerable: !0, get: function() {
      return context_1.createContextKey;
    } });
    Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: !0, get: function() {
      return context_1.ROOT_CONTEXT;
    } });
    var consoleLogger_1 = require_consoleLogger();
    Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: !0, get: function() {
      return consoleLogger_1.DiagConsoleLogger;
    } });
    var types_1 = require_types();
    Object.defineProperty(exports, "DiagLogLevel", { enumerable: !0, get: function() {
      return types_1.DiagLogLevel;
    } });
    var NoopMeter_1 = require_NoopMeter();
    Object.defineProperty(exports, "createNoopMeter", { enumerable: !0, get: function() {
      return NoopMeter_1.createNoopMeter;
    } });
    var Metric_1 = require_Metric();
    Object.defineProperty(exports, "ValueType", { enumerable: !0, get: function() {
      return Metric_1.ValueType;
    } });
    var TextMapPropagator_1 = require_TextMapPropagator();
    Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: !0, get: function() {
      return TextMapPropagator_1.defaultTextMapGetter;
    } });
    Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: !0, get: function() {
      return TextMapPropagator_1.defaultTextMapSetter;
    } });
    var ProxyTracer_1 = require_ProxyTracer();
    Object.defineProperty(exports, "ProxyTracer", { enumerable: !0, get: function() {
      return ProxyTracer_1.ProxyTracer;
    } });
    var ProxyTracerProvider_1 = require_ProxyTracerProvider();
    Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: !0, get: function() {
      return ProxyTracerProvider_1.ProxyTracerProvider;
    } });
    var SamplingResult_1 = require_SamplingResult();
    Object.defineProperty(exports, "SamplingDecision", { enumerable: !0, get: function() {
      return SamplingResult_1.SamplingDecision;
    } });
    var span_kind_1 = require_span_kind();
    Object.defineProperty(exports, "SpanKind", { enumerable: !0, get: function() {
      return span_kind_1.SpanKind;
    } });
    var status_1 = require_status();
    Object.defineProperty(exports, "SpanStatusCode", { enumerable: !0, get: function() {
      return status_1.SpanStatusCode;
    } });
    var trace_flags_1 = require_trace_flags();
    Object.defineProperty(exports, "TraceFlags", { enumerable: !0, get: function() {
      return trace_flags_1.TraceFlags;
    } });
    var utils_2 = require_utils2();
    Object.defineProperty(exports, "createTraceState", { enumerable: !0, get: function() {
      return utils_2.createTraceState;
    } });
    var spancontext_utils_1 = require_spancontext_utils();
    Object.defineProperty(exports, "isSpanContextValid", { enumerable: !0, get: function() {
      return spancontext_utils_1.isSpanContextValid;
    } });
    Object.defineProperty(exports, "isValidTraceId", { enumerable: !0, get: function() {
      return spancontext_utils_1.isValidTraceId;
    } });
    Object.defineProperty(exports, "isValidSpanId", { enumerable: !0, get: function() {
      return spancontext_utils_1.isValidSpanId;
    } });
    var invalid_span_constants_1 = require_invalid_span_constants();
    Object.defineProperty(exports, "INVALID_SPANID", { enumerable: !0, get: function() {
      return invalid_span_constants_1.INVALID_SPANID;
    } });
    Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: !0, get: function() {
      return invalid_span_constants_1.INVALID_TRACEID;
    } });
    Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: !0, get: function() {
      return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
    } });
    var context_api_1 = require_context_api();
    Object.defineProperty(exports, "context", { enumerable: !0, get: function() {
      return context_api_1.context;
    } });
    var diag_api_1 = require_diag_api();
    Object.defineProperty(exports, "diag", { enumerable: !0, get: function() {
      return diag_api_1.diag;
    } });
    var metrics_api_1 = require_metrics_api();
    Object.defineProperty(exports, "metrics", { enumerable: !0, get: function() {
      return metrics_api_1.metrics;
    } });
    var propagation_api_1 = require_propagation_api();
    Object.defineProperty(exports, "propagation", { enumerable: !0, get: function() {
      return propagation_api_1.propagation;
    } });
    var trace_api_1 = require_trace_api();
    Object.defineProperty(exports, "trace", { enumerable: !0, get: function() {
      return trace_api_1.trace;
    } });
    exports.default = {
      context: context_api_1.context,
      diag: diag_api_1.diag,
      metrics: metrics_api_1.metrics,
      propagation: propagation_api_1.propagation,
      trace: trace_api_1.trace
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.equalsCaseInsensitive = exports.binarySearchLB = exports.setEquals = exports.FlatMap = exports.isPromiseAllSettledRejectionResult = exports.PromiseAllSettled = exports.callWithTimeout = exports.TimeoutError = exports.instrumentationScopeId = exports.hashAttributes = exports.isNotNullish = void 0;
    function isNotNullish(item) {
      return item != null;
    }
    exports.isNotNullish = isNotNullish;
    function hashAttributes(attributes) {
      let keys = Object.keys(attributes);
      return keys.length === 0 ? "" : (keys = keys.sort(), JSON.stringify(keys.map((key) => [key, attributes[key]])));
    }
    exports.hashAttributes = hashAttributes;
    function instrumentationScopeId(instrumentationScope2) {
      var _a, _b;
      return `${instrumentationScope2.name}:${(_a = instrumentationScope2.version) !== null && _a !== void 0 ? _a : ""}:${(_b = instrumentationScope2.schemaUrl) !== null && _b !== void 0 ? _b : ""}`;
    }
    exports.instrumentationScopeId = instrumentationScopeId;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message), Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout) {
      let timeoutHandle, timeoutPromise = new Promise(function(_resolve, reject) {
        timeoutHandle = setTimeout(function() {
          reject(new TimeoutError("Operation timed out."));
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => (clearTimeout(timeoutHandle), result), (reason) => {
        throw clearTimeout(timeoutHandle), reason;
      });
    }
    exports.callWithTimeout = callWithTimeout;
    async function PromiseAllSettled(promises) {
      return Promise.all(promises.map(async (p) => {
        try {
          return {
            status: "fulfilled",
            value: await p
          };
        } catch (e) {
          return {
            status: "rejected",
            reason: e
          };
        }
      }));
    }
    exports.PromiseAllSettled = PromiseAllSettled;
    function isPromiseAllSettledRejectionResult(it) {
      return it.status === "rejected";
    }
    exports.isPromiseAllSettledRejectionResult = isPromiseAllSettledRejectionResult;
    function FlatMap(arr, fn) {
      let result = [];
      return arr.forEach((it) => {
        result.push(...fn(it));
      }), result;
    }
    exports.FlatMap = FlatMap;
    function setEquals(lhs, rhs) {
      if (lhs.size !== rhs.size)
        return !1;
      for (let item of lhs)
        if (!rhs.has(item))
          return !1;
      return !0;
    }
    exports.setEquals = setEquals;
    function binarySearchLB(arr, value) {
      let lo = 0, hi = arr.length - 1;
      for (; hi - lo > 1; ) {
        let mid = Math.trunc((hi + lo) / 2);
        arr[mid] <= value ? lo = mid : hi = mid - 1;
      }
      return arr[hi] <= value ? hi : arr[lo] <= value ? lo : -1;
    }
    exports.binarySearchLB = binarySearchLB;
    function equalsCaseInsensitive(lhs, rhs) {
      return lhs.toLowerCase() === rhs.toLowerCase();
    }
    exports.equalsCaseInsensitive = equalsCaseInsensitive;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/types.js
var require_types2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AggregatorKind = void 0;
    var AggregatorKind;
    (function(AggregatorKind2) {
      AggregatorKind2[AggregatorKind2.DROP = 0] = "DROP", AggregatorKind2[AggregatorKind2.SUM = 1] = "SUM", AggregatorKind2[AggregatorKind2.LAST_VALUE = 2] = "LAST_VALUE", AggregatorKind2[AggregatorKind2.HISTOGRAM = 3] = "HISTOGRAM", AggregatorKind2[AggregatorKind2.EXPONENTIAL_HISTOGRAM = 4] = "EXPONENTIAL_HISTOGRAM";
    })(AggregatorKind = exports.AggregatorKind || (exports.AggregatorKind = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Drop.js
var require_Drop = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Drop.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DropAggregator = void 0;
    var types_1 = require_types2(), DropAggregator = class {
      constructor() {
        this.kind = types_1.AggregatorKind.DROP;
      }
      createAccumulation() {
      }
      merge(_previous, _delta) {
      }
      diff(_previous, _current) {
      }
      toMetricData(_descriptor, _aggregationTemporality, _accumulationByAttributes, _endTime) {
      }
    };
    exports.DropAggregator = DropAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js
var require_InstrumentDescriptor = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isValidName = exports.isDescriptorCompatibleWith = exports.createInstrumentDescriptorWithView = exports.createInstrumentDescriptor = exports.InstrumentType = void 0;
    var api_1 = require_src(), utils_1 = require_utils3(), InstrumentType;
    (function(InstrumentType2) {
      InstrumentType2.COUNTER = "COUNTER", InstrumentType2.HISTOGRAM = "HISTOGRAM", InstrumentType2.UP_DOWN_COUNTER = "UP_DOWN_COUNTER", InstrumentType2.OBSERVABLE_COUNTER = "OBSERVABLE_COUNTER", InstrumentType2.OBSERVABLE_GAUGE = "OBSERVABLE_GAUGE", InstrumentType2.OBSERVABLE_UP_DOWN_COUNTER = "OBSERVABLE_UP_DOWN_COUNTER";
    })(InstrumentType = exports.InstrumentType || (exports.InstrumentType = {}));
    function createInstrumentDescriptor(name, type, options) {
      var _a, _b, _c;
      return isValidName(name) || api_1.diag.warn(`Invalid metric name: "${name}". The metric name should be a ASCII string with a length no greater than 255 characters.`), {
        name,
        type,
        description: (_a = options?.description) !== null && _a !== void 0 ? _a : "",
        unit: (_b = options?.unit) !== null && _b !== void 0 ? _b : "",
        valueType: (_c = options?.valueType) !== null && _c !== void 0 ? _c : api_1.ValueType.DOUBLE
      };
    }
    exports.createInstrumentDescriptor = createInstrumentDescriptor;
    function createInstrumentDescriptorWithView(view, instrument) {
      var _a, _b;
      return {
        name: (_a = view.name) !== null && _a !== void 0 ? _a : instrument.name,
        description: (_b = view.description) !== null && _b !== void 0 ? _b : instrument.description,
        type: instrument.type,
        unit: instrument.unit,
        valueType: instrument.valueType
      };
    }
    exports.createInstrumentDescriptorWithView = createInstrumentDescriptorWithView;
    function isDescriptorCompatibleWith(descriptor, otherDescriptor) {
      return (0, utils_1.equalsCaseInsensitive)(descriptor.name, otherDescriptor.name) && descriptor.unit === otherDescriptor.unit && descriptor.type === otherDescriptor.type && descriptor.valueType === otherDescriptor.valueType;
    }
    exports.isDescriptorCompatibleWith = isDescriptorCompatibleWith;
    var NAME_REGEXP = /^[a-z][a-z0-9_.\-/]{0,254}$/i;
    function isValidName(name) {
      return name.match(NAME_REGEXP) != null;
    }
    exports.isValidName = isValidName;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Histogram.js
var require_Histogram = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Histogram.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.HistogramAggregator = exports.HistogramAccumulation = void 0;
    var types_1 = require_types2(), MetricData_1 = require_MetricData(), InstrumentDescriptor_1 = require_InstrumentDescriptor(), utils_1 = require_utils3();
    function createNewEmptyCheckpoint(boundaries) {
      let counts = boundaries.map(() => 0);
      return counts.push(0), {
        buckets: {
          boundaries,
          counts
        },
        sum: 0,
        count: 0,
        hasMinMax: !1,
        min: 1 / 0,
        max: -1 / 0
      };
    }
    var HistogramAccumulation = class {
      constructor(startTime, _boundaries, _recordMinMax = !0, _current = createNewEmptyCheckpoint(_boundaries)) {
        this.startTime = startTime, this._boundaries = _boundaries, this._recordMinMax = _recordMinMax, this._current = _current;
      }
      record(value) {
        this._current.count += 1, this._current.sum += value, this._recordMinMax && (this._current.min = Math.min(value, this._current.min), this._current.max = Math.max(value, this._current.max), this._current.hasMinMax = !0);
        let idx = (0, utils_1.binarySearchLB)(this._boundaries, value);
        this._current.buckets.counts[idx + 1] += 1;
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports.HistogramAccumulation = HistogramAccumulation;
    var HistogramAggregator = class {
      /**
       * @param _boundaries sorted upper bounds of recorded values.
       * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
       */
      constructor(_boundaries, _recordMinMax) {
        this._boundaries = _boundaries, this._recordMinMax = _recordMinMax, this.kind = types_1.AggregatorKind.HISTOGRAM;
      }
      createAccumulation(startTime) {
        return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);
      }
      /**
       * Return the result of the merge of two histogram accumulations. As long as one Aggregator
       * instance produces all Accumulations with constant boundaries we don't need to worry about
       * merging accumulations with different boundaries.
       */
      merge(previous, delta) {
        let previousValue = previous.toPointValue(), deltaValue = delta.toPointValue(), previousCounts = previousValue.buckets.counts, deltaCounts = deltaValue.buckets.counts, mergedCounts = new Array(previousCounts.length);
        for (let idx = 0; idx < previousCounts.length; idx++)
          mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];
        let min = 1 / 0, max = -1 / 0;
        return this._recordMinMax && (previousValue.hasMinMax && deltaValue.hasMinMax ? (min = Math.min(previousValue.min, deltaValue.min), max = Math.max(previousValue.max, deltaValue.max)) : previousValue.hasMinMax ? (min = previousValue.min, max = previousValue.max) : deltaValue.hasMinMax && (min = deltaValue.min, max = deltaValue.max)), new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
          buckets: {
            boundaries: previousValue.buckets.boundaries,
            counts: mergedCounts
          },
          count: previousValue.count + deltaValue.count,
          sum: previousValue.sum + deltaValue.sum,
          hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),
          min,
          max
        });
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        let previousValue = previous.toPointValue(), currentValue = current.toPointValue(), previousCounts = previousValue.buckets.counts, currentCounts = currentValue.buckets.counts, diffedCounts = new Array(previousCounts.length);
        for (let idx = 0; idx < previousCounts.length; idx++)
          diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];
        return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
          buckets: {
            boundaries: previousValue.buckets.boundaries,
            counts: diffedCounts
          },
          count: currentValue.count - previousValue.count,
          sum: currentValue.sum - previousValue.sum,
          hasMinMax: !1,
          min: 1 / 0,
          max: -1 / 0
        });
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.HISTOGRAM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            let pointValue = accumulation.toPointValue(), allowsNegativeValues = descriptor.type === InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: {
                min: pointValue.hasMinMax ? pointValue.min : void 0,
                max: pointValue.hasMinMax ? pointValue.max : void 0,
                sum: allowsNegativeValues ? void 0 : pointValue.sum,
                buckets: pointValue.buckets,
                count: pointValue.count
              }
            };
          })
        };
      }
    };
    exports.HistogramAggregator = HistogramAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/Buckets.js
var require_Buckets = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/Buckets.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Buckets = void 0;
    var Buckets = class _Buckets {
      /**
       * The term index refers to the number of the exponential histogram bucket
       * used to determine its boundaries. The lower boundary of a bucket is
       * determined by base ** index and the upper boundary of a bucket is
       * determined by base ** (index + 1). index values are signed to account
       * for values less than or equal to 1.
       *
       * indexBase is the index of the 0th position in the
       * backing array, i.e., backing[0] is the count
       * in the bucket with index `indexBase`.
       *
       * indexStart is the smallest index value represented
       * in the backing array.
       *
       * indexEnd is the largest index value represented in
       * the backing array.
       */
      constructor(backing = new BucketsBacking(), indexBase = 0, indexStart = 0, indexEnd = 0) {
        this.backing = backing, this.indexBase = indexBase, this.indexStart = indexStart, this.indexEnd = indexEnd;
      }
      /**
       * Offset is the bucket index of the smallest entry in the counts array
       * @returns {number}
       */
      get offset() {
        return this.indexStart;
      }
      /**
       * Buckets is a view into the backing array.
       * @returns {number}
       */
      get length() {
        return this.backing.length === 0 || this.indexEnd === this.indexStart && this.at(0) === 0 ? 0 : this.indexEnd - this.indexStart + 1;
      }
      /**
       * An array of counts, where count[i] carries the count
       * of the bucket at index (offset+i).  count[i] is the count of
       * values greater than base^(offset+i) and less than or equal to
       * base^(offset+i+1).
       * @returns {number} The logical counts based on the backing array
       */
      counts() {
        return Array.from({ length: this.length }, (_, i) => this.at(i));
      }
      /**
       * At returns the count of the bucket at a position in the logical
       * array of counts.
       * @param position
       * @returns {number}
       */
      at(position) {
        let bias = this.indexBase - this.indexStart;
        return position < bias && (position += this.backing.length), position -= bias, this.backing.countAt(position);
      }
      /**
       * incrementBucket increments the backing array index by `increment`
       * @param bucketIndex
       * @param increment
       */
      incrementBucket(bucketIndex, increment) {
        this.backing.increment(bucketIndex, increment);
      }
      /**
       * decrementBucket decrements the backing array index by `decrement`
       * if decrement is greater than the current value, it's set to 0.
       * @param bucketIndex
       * @param decrement
       */
      decrementBucket(bucketIndex, decrement) {
        this.backing.decrement(bucketIndex, decrement);
      }
      /**
       * trim removes leading and / or trailing zero buckets (which can occur
       * after diffing two histos) and rotates the backing array so that the
       * smallest non-zero index is in the 0th position of the backing array
       */
      trim() {
        for (let i = 0; i < this.length; i++)
          if (this.at(i) !== 0) {
            this.indexStart += i;
            break;
          } else if (i === this.length - 1) {
            this.indexStart = this.indexEnd = this.indexBase = 0;
            return;
          }
        for (let i = this.length - 1; i >= 0; i--)
          if (this.at(i) !== 0) {
            this.indexEnd -= this.length - i - 1;
            break;
          }
        this._rotate();
      }
      /**
       * downscale first rotates, then collapses 2**`by`-to-1 buckets.
       * @param by
       */
      downscale(by) {
        this._rotate();
        let size = 1 + this.indexEnd - this.indexStart, each = 1 << by, inpos = 0, outpos = 0;
        for (let pos = this.indexStart; pos <= this.indexEnd; ) {
          let mod = pos % each;
          mod < 0 && (mod += each);
          for (let i = mod; i < each && inpos < size; i++)
            this._relocateBucket(outpos, inpos), inpos++, pos++;
          outpos++;
        }
        this.indexStart >>= by, this.indexEnd >>= by, this.indexBase = this.indexStart;
      }
      /**
       * Clone returns a deep copy of Buckets
       * @returns {Buckets}
       */
      clone() {
        return new _Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);
      }
      /**
       * _rotate shifts the backing array contents so that indexStart ==
       * indexBase to simplify the downscale logic.
       */
      _rotate() {
        let bias = this.indexBase - this.indexStart;
        bias !== 0 && (bias > 0 ? (this.backing.reverse(0, this.backing.length), this.backing.reverse(0, bias), this.backing.reverse(bias, this.backing.length)) : (this.backing.reverse(0, this.backing.length), this.backing.reverse(0, this.backing.length + bias)), this.indexBase = this.indexStart);
      }
      /**
       * _relocateBucket adds the count in counts[src] to counts[dest] and
       * resets count[src] to zero.
       */
      _relocateBucket(dest, src) {
        dest !== src && this.incrementBucket(dest, this.backing.emptyBucket(src));
      }
    };
    exports.Buckets = Buckets;
    var BucketsBacking = class _BucketsBacking {
      constructor(_counts = [0]) {
        this._counts = _counts;
      }
      /**
       * length returns the physical size of the backing array, which
       * is >= buckets.length()
       */
      get length() {
        return this._counts.length;
      }
      /**
       * countAt returns the count in a specific bucket
       */
      countAt(pos) {
        return this._counts[pos];
      }
      /**
       * growTo grows a backing array and copies old entries
       * into their correct new positions.
       */
      growTo(newSize, oldPositiveLimit, newPositiveLimit) {
        let tmp = new Array(newSize).fill(0);
        tmp.splice(newPositiveLimit, this._counts.length - oldPositiveLimit, ...this._counts.slice(oldPositiveLimit)), tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit)), this._counts = tmp;
      }
      /**
       * reverse the items in the backing array in the range [from, limit).
       */
      reverse(from, limit) {
        let num = Math.floor((from + limit) / 2) - from;
        for (let i = 0; i < num; i++) {
          let tmp = this._counts[from + i];
          this._counts[from + i] = this._counts[limit - i - 1], this._counts[limit - i - 1] = tmp;
        }
      }
      /**
       * emptyBucket empties the count from a bucket, for
       * moving into another.
       */
      emptyBucket(src) {
        let tmp = this._counts[src];
        return this._counts[src] = 0, tmp;
      }
      /**
       * increments a bucket by `increment`
       */
      increment(bucketIndex, increment) {
        this._counts[bucketIndex] += increment;
      }
      /**
       * decrements a bucket by `decrement`
       */
      decrement(bucketIndex, decrement) {
        this._counts[bucketIndex] >= decrement ? this._counts[bucketIndex] -= decrement : this._counts[bucketIndex] = 0;
      }
      /**
       * clone returns a deep copy of BucketsBacking
       */
      clone() {
        return new _BucketsBacking([...this._counts]);
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ieee754.js
var require_ieee754 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ieee754.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getSignificand = exports.getNormalBase2 = exports.MIN_VALUE = exports.MAX_NORMAL_EXPONENT = exports.MIN_NORMAL_EXPONENT = exports.SIGNIFICAND_WIDTH = void 0;
    exports.SIGNIFICAND_WIDTH = 52;
    var EXPONENT_MASK = 2146435072, SIGNIFICAND_MASK = 1048575, EXPONENT_BIAS = 1023;
    exports.MIN_NORMAL_EXPONENT = -EXPONENT_BIAS + 1;
    exports.MAX_NORMAL_EXPONENT = EXPONENT_BIAS;
    exports.MIN_VALUE = Math.pow(2, -1022);
    function getNormalBase2(value) {
      let dv = new DataView(new ArrayBuffer(8));
      return dv.setFloat64(0, value), ((dv.getUint32(0) & EXPONENT_MASK) >> 20) - EXPONENT_BIAS;
    }
    exports.getNormalBase2 = getNormalBase2;
    function getSignificand(value) {
      let dv = new DataView(new ArrayBuffer(8));
      dv.setFloat64(0, value);
      let hiBits = dv.getUint32(0), loBits = dv.getUint32(4);
      return (hiBits & SIGNIFICAND_MASK) * Math.pow(2, 32) + loBits;
    }
    exports.getSignificand = getSignificand;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/util.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.nextGreaterSquare = exports.ldexp = void 0;
    function ldexp(frac, exp) {
      return frac === 0 || frac === Number.POSITIVE_INFINITY || frac === Number.NEGATIVE_INFINITY || Number.isNaN(frac) ? frac : frac * Math.pow(2, exp);
    }
    exports.ldexp = ldexp;
    function nextGreaterSquare(v) {
      return v--, v |= v >> 1, v |= v >> 2, v |= v >> 4, v |= v >> 8, v |= v >> 16, v++, v;
    }
    exports.nextGreaterSquare = nextGreaterSquare;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/types.js
var require_types3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MappingError = void 0;
    var MappingError = class extends Error {
    };
    exports.MappingError = MappingError;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ExponentMapping.js
var require_ExponentMapping = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ExponentMapping.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ExponentMapping = void 0;
    var ieee754 = require_ieee754(), util = require_util(), types_1 = require_types3(), ExponentMapping = class {
      constructor(scale) {
        this._shift = -scale;
      }
      /**
       * Maps positive floating point values to indexes corresponding to scale
       * @param value
       * @returns {number} index for provided value at the current scale
       */
      mapToIndex(value) {
        if (value < ieee754.MIN_VALUE)
          return this._minNormalLowerBoundaryIndex();
        let exp = ieee754.getNormalBase2(value), correction = this._rightShift(ieee754.getSignificand(value) - 1, ieee754.SIGNIFICAND_WIDTH);
        return exp + correction >> this._shift;
      }
      /**
       * Returns the lower bucket boundary for the given index for scale
       *
       * @param index
       * @returns {number}
       */
      lowerBoundary(index) {
        let minIndex = this._minNormalLowerBoundaryIndex();
        if (index < minIndex)
          throw new types_1.MappingError(`underflow: ${index} is < minimum lower boundary: ${minIndex}`);
        let maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index > maxIndex)
          throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
        return util.ldexp(1, index << this._shift);
      }
      /**
       * The scale used by this mapping
       * @returns {number}
       */
      get scale() {
        return this._shift === 0 ? 0 : -this._shift;
      }
      _minNormalLowerBoundaryIndex() {
        let index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;
        return this._shift < 2 && index--, index;
      }
      _maxNormalLowerBoundaryIndex() {
        return ieee754.MAX_NORMAL_EXPONENT >> this._shift;
      }
      _rightShift(value, shift) {
        return Math.floor(value * Math.pow(2, -shift));
      }
    };
    exports.ExponentMapping = ExponentMapping;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/LogarithmMapping.js
var require_LogarithmMapping = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/LogarithmMapping.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.LogarithmMapping = void 0;
    var ieee754 = require_ieee754(), util = require_util(), types_1 = require_types3(), LogarithmMapping = class {
      constructor(scale) {
        this._scale = scale, this._scaleFactor = util.ldexp(Math.LOG2E, scale), this._inverseFactor = util.ldexp(Math.LN2, -scale);
      }
      /**
       * Maps positive floating point values to indexes corresponding to scale
       * @param value
       * @returns {number} index for provided value at the current scale
       */
      mapToIndex(value) {
        if (value <= ieee754.MIN_VALUE)
          return this._minNormalLowerBoundaryIndex() - 1;
        if (ieee754.getSignificand(value) === 0)
          return (ieee754.getNormalBase2(value) << this._scale) - 1;
        let index = Math.floor(Math.log(value) * this._scaleFactor), maxIndex = this._maxNormalLowerBoundaryIndex();
        return index >= maxIndex ? maxIndex : index;
      }
      /**
       * Returns the lower bucket boundary for the given index for scale
       *
       * @param index
       * @returns {number}
       */
      lowerBoundary(index) {
        let maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index >= maxIndex) {
          if (index === maxIndex)
            return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);
          throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
        }
        let minIndex = this._minNormalLowerBoundaryIndex();
        if (index <= minIndex) {
          if (index === minIndex)
            return ieee754.MIN_VALUE;
          if (index === minIndex - 1)
            return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;
          throw new types_1.MappingError(`overflow: ${index} is < minimum lower boundary: ${minIndex}`);
        }
        return Math.exp(index * this._inverseFactor);
      }
      /**
       * The scale used by this mapping
       * @returns {number}
       */
      get scale() {
        return this._scale;
      }
      _minNormalLowerBoundaryIndex() {
        return ieee754.MIN_NORMAL_EXPONENT << this._scale;
      }
      _maxNormalLowerBoundaryIndex() {
        return (ieee754.MAX_NORMAL_EXPONENT + 1 << this._scale) - 1;
      }
    };
    exports.LogarithmMapping = LogarithmMapping;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/getMapping.js
var require_getMapping = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/getMapping.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMapping = void 0;
    var ExponentMapping_1 = require_ExponentMapping(), LogarithmMapping_1 = require_LogarithmMapping(), types_1 = require_types3(), MIN_SCALE = -10, MAX_SCALE = 20, PREBUILT_MAPPINGS = Array.from({ length: 31 }, (_, i) => i > 10 ? new LogarithmMapping_1.LogarithmMapping(i - 10) : new ExponentMapping_1.ExponentMapping(i - 10));
    function getMapping(scale) {
      if (scale > MAX_SCALE || scale < MIN_SCALE)
        throw new types_1.MappingError(`expected scale >= ${MIN_SCALE} && <= ${MAX_SCALE}, got: ${scale}`);
      return PREBUILT_MAPPINGS[scale + 10];
    }
    exports.getMapping = getMapping;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/ExponentialHistogram.js
var require_ExponentialHistogram = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/ExponentialHistogram.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ExponentialHistogramAggregator = exports.ExponentialHistogramAccumulation = void 0;
    var types_1 = require_types2(), MetricData_1 = require_MetricData(), api_1 = require_src(), InstrumentDescriptor_1 = require_InstrumentDescriptor(), Buckets_1 = require_Buckets(), getMapping_1 = require_getMapping(), util_1 = require_util(), HighLow = class _HighLow {
      constructor(low, high) {
        this.low = low, this.high = high;
      }
      static combine(h1, h2) {
        return new _HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));
      }
    }, MAX_SCALE = 20, DEFAULT_MAX_SIZE = 160, MIN_MAX_SIZE = 2, ExponentialHistogramAccumulation = class _ExponentialHistogramAccumulation {
      constructor(startTime = startTime, _maxSize = DEFAULT_MAX_SIZE, _recordMinMax = !0, _sum = 0, _count = 0, _zeroCount = 0, _min = Number.POSITIVE_INFINITY, _max = Number.NEGATIVE_INFINITY, _positive = new Buckets_1.Buckets(), _negative = new Buckets_1.Buckets(), _mapping = (0, getMapping_1.getMapping)(MAX_SCALE)) {
        this.startTime = startTime, this._maxSize = _maxSize, this._recordMinMax = _recordMinMax, this._sum = _sum, this._count = _count, this._zeroCount = _zeroCount, this._min = _min, this._max = _max, this._positive = _positive, this._negative = _negative, this._mapping = _mapping, this._maxSize < MIN_MAX_SIZE && (api_1.diag.warn(`Exponential Histogram Max Size set to ${this._maxSize},                 changing to the minimum size of: ${MIN_MAX_SIZE}`), this._maxSize = MIN_MAX_SIZE);
      }
      /**
       * record updates a histogram with a single count
       * @param {Number} value
       */
      record(value) {
        this.updateByIncrement(value, 1);
      }
      /**
       * Sets the start time for this accumulation
       * @param {HrTime} startTime
       */
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      /**
       * Returns the datapoint representation of this accumulation
       * @param {HrTime} startTime
       */
      toPointValue() {
        return {
          hasMinMax: this._recordMinMax,
          min: this.min,
          max: this.max,
          sum: this.sum,
          positive: {
            offset: this.positive.offset,
            bucketCounts: this.positive.counts()
          },
          negative: {
            offset: this.negative.offset,
            bucketCounts: this.negative.counts()
          },
          count: this.count,
          scale: this.scale,
          zeroCount: this.zeroCount
        };
      }
      /**
       * @returns {Number} The sum of values recorded by this accumulation
       */
      get sum() {
        return this._sum;
      }
      /**
       * @returns {Number} The minimum value recorded by this accumulation
       */
      get min() {
        return this._min;
      }
      /**
       * @returns {Number} The maximum value recorded by this accumulation
       */
      get max() {
        return this._max;
      }
      /**
       * @returns {Number} The count of values recorded by this accumulation
       */
      get count() {
        return this._count;
      }
      /**
       * @returns {Number} The number of 0 values recorded by this accumulation
       */
      get zeroCount() {
        return this._zeroCount;
      }
      /**
       * @returns {Number} The scale used by thie accumulation
       */
      get scale() {
        return this._count === this._zeroCount ? 0 : this._mapping.scale;
      }
      /**
       * positive holds the postive values
       * @returns {Buckets}
       */
      get positive() {
        return this._positive;
      }
      /**
       * negative holds the negative values by their absolute value
       * @returns {Buckets}
       */
      get negative() {
        return this._negative;
      }
      /**
       * uppdateByIncr supports updating a histogram with a non-negative
       * increment.
       * @param value
       * @param increment
       */
      updateByIncrement(value, increment) {
        if (value > this._max && (this._max = value), value < this._min && (this._min = value), this._count += increment, value === 0) {
          this._zeroCount += increment;
          return;
        }
        this._sum += value * increment, value > 0 ? this._updateBuckets(this._positive, value, increment) : this._updateBuckets(this._negative, -value, increment);
      }
      /**
       * merge combines data from previous value into self
       * @param {ExponentialHistogramAccumulation} previous
       */
      merge(previous) {
        this._count === 0 ? (this._min = previous.min, this._max = previous.max) : previous.count !== 0 && (previous.min < this.min && (this._min = previous.min), previous.max > this.max && (this._max = previous.max)), this.startTime = previous.startTime, this._sum += previous.sum, this._count += previous.count, this._zeroCount += previous.zeroCount;
        let minScale = this._minScale(previous);
        this._downscale(this.scale - minScale), this._mergeBuckets(this.positive, previous, previous.positive, minScale), this._mergeBuckets(this.negative, previous, previous.negative, minScale);
      }
      /**
       * diff substracts other from self
       * @param {ExponentialHistogramAccumulation} other
       */
      diff(other) {
        this._min = 1 / 0, this._max = -1 / 0, this._sum -= other.sum, this._count -= other.count, this._zeroCount -= other.zeroCount;
        let minScale = this._minScale(other);
        this._downscale(this.scale - minScale), this._diffBuckets(this.positive, other, other.positive, minScale), this._diffBuckets(this.negative, other, other.negative, minScale);
      }
      /**
       * clone returns a deep copy of self
       * @returns {ExponentialHistogramAccumulation}
       */
      clone() {
        return new _ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);
      }
      /**
       * _updateBuckets maps the incoming value to a bucket index for the current
       * scale. If the bucket index is outside of the range of the backing array,
       * it will rescale the backing array and update the mapping for the new scale.
       */
      _updateBuckets(buckets, value, increment) {
        let index = this._mapping.mapToIndex(value), rescalingNeeded = !1, high = 0, low = 0;
        if (buckets.length === 0 ? (buckets.indexStart = index, buckets.indexEnd = buckets.indexStart, buckets.indexBase = buckets.indexStart) : index < buckets.indexStart && buckets.indexEnd - index >= this._maxSize ? (rescalingNeeded = !0, low = index, high = buckets.indexEnd) : index > buckets.indexEnd && index - buckets.indexStart >= this._maxSize && (rescalingNeeded = !0, low = buckets.indexStart, high = index), rescalingNeeded) {
          let change = this._changeScale(high, low);
          this._downscale(change), index = this._mapping.mapToIndex(value);
        }
        this._incrementIndexBy(buckets, index, increment);
      }
      /**
       * _incrementIndexBy increments the count of the bucket specified by `index`.
       * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]
       * the boundaries of the backing array will be adjusted and more buckets will
       * be added if needed.
       */
      _incrementIndexBy(buckets, index, increment) {
        if (increment === 0)
          return;
        if (index < buckets.indexStart) {
          let span = buckets.indexEnd - index;
          span >= buckets.backing.length && this._grow(buckets, span + 1), buckets.indexStart = index;
        } else if (index > buckets.indexEnd) {
          let span = index - buckets.indexStart;
          span >= buckets.backing.length && this._grow(buckets, span + 1), buckets.indexEnd = index;
        }
        let bucketIndex = index - buckets.indexBase;
        bucketIndex < 0 && (bucketIndex += buckets.backing.length), buckets.incrementBucket(bucketIndex, increment);
      }
      /**
       * grow resizes the backing array by doubling in size up to maxSize.
       * This extends the array with a bunch of zeros and copies the
       * existing counts to the same position.
       */
      _grow(buckets, needed) {
        let size = buckets.backing.length, bias = buckets.indexBase - buckets.indexStart, oldPositiveLimit = size - bias, newSize = (0, util_1.nextGreaterSquare)(needed);
        newSize > this._maxSize && (newSize = this._maxSize);
        let newPositiveLimit = newSize - bias;
        buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);
      }
      /**
       * _changeScale computes how much downscaling is needed by shifting the
       * high and low values until they are separated by no more than size.
       */
      _changeScale(high, low) {
        let change = 0;
        for (; high - low >= this._maxSize; )
          high >>= 1, low >>= 1, change++;
        return change;
      }
      /**
       * _downscale subtracts `change` from the current mapping scale.
       */
      _downscale(change) {
        if (change === 0)
          return;
        if (change < 0)
          throw new Error(`impossible change of scale: ${this.scale}`);
        let newScale = this._mapping.scale - change;
        this._positive.downscale(change), this._negative.downscale(change), this._mapping = (0, getMapping_1.getMapping)(newScale);
      }
      /**
       * _minScale is used by diff and merge to compute an ideal combined scale
       */
      _minScale(other) {
        let minScale = Math.min(this.scale, other.scale), highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale)), highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));
        return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));
      }
      /**
       * _highLowAtScale is used by diff and merge to compute an ideal combined scale.
       */
      _highLowAtScale(buckets, currentScale, newScale) {
        if (buckets.length === 0)
          return new HighLow(0, -1);
        let shift = currentScale - newScale;
        return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);
      }
      /**
       * _mergeBuckets translates index values from another histogram and
       * adds the values into the corresponding buckets of this histogram.
       */
      _mergeBuckets(ours, other, theirs, scale) {
        let theirOffset = theirs.offset, theirChange = other.scale - scale;
        for (let i = 0; i < theirs.length; i++)
          this._incrementIndexBy(ours, theirOffset + i >> theirChange, theirs.at(i));
      }
      /**
       * _diffBuckets translates index values from another histogram and
       * subtracts the values in the corresponding buckets of this histogram.
       */
      _diffBuckets(ours, other, theirs, scale) {
        let theirOffset = theirs.offset, theirChange = other.scale - scale;
        for (let i = 0; i < theirs.length; i++) {
          let bucketIndex = (theirOffset + i >> theirChange) - ours.indexBase;
          bucketIndex < 0 && (bucketIndex += ours.backing.length), ours.decrementBucket(bucketIndex, theirs.at(i));
        }
        ours.trim();
      }
    };
    exports.ExponentialHistogramAccumulation = ExponentialHistogramAccumulation;
    var ExponentialHistogramAggregator = class {
      /**
       * @param _maxSize Maximum number of buckets for each of the positive
       *    and negative ranges, exclusive of the zero-bucket.
       * @param _recordMinMax If set to true, min and max will be recorded.
       *    Otherwise, min and max will not be recorded.
       */
      constructor(_maxSize, _recordMinMax) {
        this._maxSize = _maxSize, this._recordMinMax = _recordMinMax, this.kind = types_1.AggregatorKind.EXPONENTIAL_HISTOGRAM;
      }
      createAccumulation(startTime) {
        return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);
      }
      /**
       * Return the result of the merge of two exponential histogram accumulations.
       */
      merge(previous, delta) {
        let result = delta.clone();
        return result.merge(previous), result;
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        let result = current.clone();
        return result.diff(previous), result;
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.EXPONENTIAL_HISTOGRAM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            let pointValue = accumulation.toPointValue(), allowsNegativeValues = descriptor.type === InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: {
                min: pointValue.hasMinMax ? pointValue.min : void 0,
                max: pointValue.hasMinMax ? pointValue.max : void 0,
                sum: allowsNegativeValues ? void 0 : pointValue.sum,
                positive: {
                  offset: pointValue.positive.offset,
                  bucketCounts: pointValue.positive.bucketCounts
                },
                negative: {
                  offset: pointValue.negative.offset,
                  bucketCounts: pointValue.negative.bucketCounts
                },
                count: pointValue.count,
                scale: pointValue.scale,
                zeroCount: pointValue.zeroCount
              }
            };
          })
        };
      }
    };
    exports.ExponentialHistogramAggregator = ExponentialHistogramAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = void 0;
    var api_1 = require_src(), SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context) {
      return context.setValue(SUPPRESS_TRACING_KEY, !0);
    }
    exports.suppressTracing = suppressTracing;
    function unsuppressTracing(context) {
      return context.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context) {
      return context.getValue(SUPPRESS_TRACING_KEY) === !0;
    }
    exports.isTracingSuppressed = isTracingSuppressed;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports.BAGGAGE_HEADER = "baggage";
    exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = void 0;
    var api_1 = require_src(), constants_1 = require_constants();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        let value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        return value.metadata !== void 0 && (entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString()), entry;
      });
    }
    exports.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      let valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      let keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      let separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      let key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim()), value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim()), metadata;
      return valueProps.length > 0 && (metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR))), { key, value, metadata };
    }
    exports.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      return typeof value != "string" || value.length === 0 ? {} : value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => parsePairKeyValue(entry)).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => (headers[keyPair.key] = keyPair.value, headers), {});
    }
    exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.W3CBaggagePropagator = void 0;
    var api_1 = require_src(), suppress_tracing_1 = require_suppress_tracing(), constants_1 = require_constants(), utils_1 = require_utils4(), W3CBaggagePropagator = class {
      inject(context, carrier, setter) {
        let baggage = api_1.propagation.getBaggage(context);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context))
          return;
        let keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS), headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        headerValue.length > 0 && setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
      }
      extract(context, carrier, getter) {
        let headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER), baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context;
        let baggage = {};
        return baggageString.length === 0 || (baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).forEach((entry) => {
          let keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            let baggageEntry = { value: keyPair.value };
            keyPair.metadata && (baggageEntry.metadata = keyPair.metadata), baggage[keyPair.key] = baggageEntry;
          }
        }), Object.entries(baggage).length === 0) ? context : api_1.propagation.setBaggage(context, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock, this._epochMillis = systemClock.now(), this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        let delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports.AnchoredClock = AnchoredClock;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = void 0;
    var api_1 = require_src();
    function sanitizeAttributes(attributes) {
      let out = {};
      if (typeof attributes != "object" || attributes == null)
        return out;
      for (let [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        Array.isArray(val) ? out[key] = val.slice() : out[key] = val;
      }
      return out;
    }
    exports.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key == "string" && key.length > 0;
    }
    exports.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      return val == null ? !0 : Array.isArray(val) ? isHomogeneousAttributeValueArray(val) : isValidPrimitiveAttributeValue(val);
    }
    exports.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (let element of arr)
        if (element != null) {
          if (!type) {
            if (isValidPrimitiveAttributeValue(element)) {
              type = typeof element;
              continue;
            }
            return !1;
          }
          if (typeof element !== type)
            return !1;
        }
      return !0;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return !0;
      }
      return !1;
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.loggingErrorHandler = void 0;
    var api_1 = require_src();
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      return typeof ex == "string" ? ex : JSON.stringify(flattenException(ex));
    }
    function flattenException(ex) {
      let result = {}, current = ex;
      for (; current !== null; )
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result[propertyName])
            return;
          let value = current[propertyName];
          value && (result[propertyName] = String(value));
        }), current = Object.getPrototypeOf(current);
      return result;
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.globalErrorHandler = exports.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler(), delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch {
      }
    }
    exports.globalErrorHandler = globalErrorHandler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2.AlwaysOff = "always_off", TracesSamplerValues2.AlwaysOn = "always_on", TracesSamplerValues2.ParentBasedAlwaysOff = "parentbased_always_off", TracesSamplerValues2.ParentBasedAlwaysOn = "parentbased_always_on", TracesSamplerValues2.ParentBasedTraceIdRatio = "parentbased_traceidratio", TracesSamplerValues2.TraceIdRatio = "traceidratio";
    })(TracesSamplerValues = exports.TracesSamplerValues || (exports.TracesSamplerValues = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/browser/globalThis.js
var require_globalThis2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/browser/globalThis.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof global == "object" ? global : {};
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getEnvWithoutDefaults = exports.parseEnvironment = exports.DEFAULT_ENVIRONMENT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = require_src(), sampling_1 = require_sampling(), globalThis_1 = require_globalThis2(), DEFAULT_LIST_SEPARATOR = ",", ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1 / 0;
    exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: !1,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
    };
    function parseBoolean(key, environment, values) {
      if (typeof values[key] > "u")
        return;
      let value = String(values[key]);
      environment[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment, values, min = -1 / 0, max = 1 / 0) {
      if (typeof values[name] < "u") {
        let value = Number(values[name]);
        isNaN(value) || (value < min ? environment[name] = min : value > max ? environment[name] = max : environment[name] = value);
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      let givenValue = input[name];
      typeof givenValue == "string" && (output[name] = givenValue.split(separator).map((v) => v.trim()));
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment, values) {
      let value = values[key];
      if (typeof value == "string") {
        let theLevel = logLevelMap[value.toUpperCase()];
        theLevel != null && (environment[key] = theLevel);
      }
    }
    function parseEnvironment(values) {
      let environment = {};
      for (let env in exports.DEFAULT_ENVIRONMENT) {
        let key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment, values);
            break;
          default:
            if (isEnvVarABoolean(key))
              parseBoolean(key, environment, values);
            else if (isEnvVarANumber(key))
              parseNumber(key, environment, values);
            else if (isEnvVarAList(key))
              parseStringList(key, environment, values);
            else {
              let value = values[key];
              typeof value < "u" && value !== null && (environment[key] = String(value));
            }
        }
      }
      return environment;
    }
    exports.parseEnvironment = parseEnvironment;
    function getEnvWithoutDefaults() {
      return typeof process < "u" && process && process.env ? parseEnvironment(process.env) : parseEnvironment(globalThis_1._globalThis);
    }
    exports.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getEnv = void 0;
    var os = __require("os"), environment_1 = require_environment();
    function getEnv() {
      let processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({
        HOSTNAME: os.hostname()
      }, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports.getEnv = getEnv;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis == "object" ? globalThis : global;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base64 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.hexToBase64 = void 0;
    function intValue(charCode) {
      return charCode >= 48 && charCode <= 57 ? charCode - 48 : charCode >= 97 && charCode <= 102 ? charCode - 87 : charCode - 55;
    }
    var buf8 = Buffer.alloc(8), buf16 = Buffer.alloc(16);
    function hexToBase64(hexStr) {
      let buf;
      hexStr.length === 16 ? buf = buf8 : hexStr.length === 32 ? buf = buf16 : buf = Buffer.alloc(hexStr.length / 2);
      let offset = 0;
      for (let i = 0; i < hexStr.length; i += 2) {
        let hi = intValue(hexStr.charCodeAt(i)), lo = intValue(hexStr.charCodeAt(i + 1));
        buf.writeUInt8(hi << 4 | lo, offset++);
      }
      return buf.toString("base64");
    }
    exports.hexToBase64 = hexToBase64;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8, TRACE_ID_BYTES = 16, RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES), this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function() {
        for (let i = 0; i < bytes / 4; i++)
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
        for (let i = 0; i < bytes && !(SHARED_BUFFER[i] > 0); i++)
          i === bytes - 1 && (SHARED_BUFFER[bytes - 1] = 1);
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.otperformance = void 0;
    var perf_hooks_1 = __require("perf_hooks");
    exports.otperformance = perf_hooks_1.performance;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/version.js
var require_version2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/version.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.VERSION = void 0;
    exports.VERSION = "1.17.1";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.1/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.1/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MessageTypeValues = exports.RpcGrpcStatusCodeValues = exports.MessagingOperationValues = exports.MessagingDestinationKindValues = exports.HttpFlavorValues = exports.NetHostConnectionSubtypeValues = exports.NetHostConnectionTypeValues = exports.NetTransportValues = exports.FaasInvokedProviderValues = exports.FaasDocumentOperationValues = exports.FaasTriggerValues = exports.DbCassandraConsistencyLevelValues = exports.DbSystemValues = exports.SemanticAttributes = void 0;
    exports.SemanticAttributes = {
      /**
       * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).
       *
       * Note: This may be different from `faas.id` if an alias is involved.
       */
      AWS_LAMBDA_INVOKED_ARN: "aws.lambda.invoked_arn",
      /**
       * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
       */
      DB_SYSTEM: "db.system",
      /**
       * The connection string used to connect to the database. It is recommended to remove embedded credentials.
       */
      DB_CONNECTION_STRING: "db.connection_string",
      /**
       * Username for accessing the database.
       */
      DB_USER: "db.user",
      /**
       * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.
       */
      DB_JDBC_DRIVER_CLASSNAME: "db.jdbc.driver_classname",
      /**
       * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).
       *
       * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.
       */
      DB_NAME: "db.name",
      /**
       * The database statement being executed.
       *
       * Note: The value may be sanitized to exclude sensitive information.
       */
      DB_STATEMENT: "db.statement",
      /**
       * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.
       *
       * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.
       */
      DB_OPERATION: "db.operation",
      /**
       * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.
       *
       * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).
       */
      DB_MSSQL_INSTANCE_NAME: "db.mssql.instance_name",
      /**
       * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.
       */
      DB_CASSANDRA_KEYSPACE: "db.cassandra.keyspace",
      /**
       * The fetch size used for paging, i.e. how many rows will be returned at once.
       */
      DB_CASSANDRA_PAGE_SIZE: "db.cassandra.page_size",
      /**
       * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
       */
      DB_CASSANDRA_CONSISTENCY_LEVEL: "db.cassandra.consistency_level",
      /**
       * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
       *
       * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
       */
      DB_CASSANDRA_TABLE: "db.cassandra.table",
      /**
       * Whether or not the query is idempotent.
       */
      DB_CASSANDRA_IDEMPOTENCE: "db.cassandra.idempotence",
      /**
       * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.
       */
      DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: "db.cassandra.speculative_execution_count",
      /**
       * The ID of the coordinating node for a query.
       */
      DB_CASSANDRA_COORDINATOR_ID: "db.cassandra.coordinator.id",
      /**
       * The data center of the coordinating node for a query.
       */
      DB_CASSANDRA_COORDINATOR_DC: "db.cassandra.coordinator.dc",
      /**
       * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.
       */
      DB_HBASE_NAMESPACE: "db.hbase.namespace",
      /**
       * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.
       */
      DB_REDIS_DATABASE_INDEX: "db.redis.database_index",
      /**
       * The collection being accessed within the database stated in `db.name`.
       */
      DB_MONGODB_COLLECTION: "db.mongodb.collection",
      /**
       * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
       *
       * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
       */
      DB_SQL_TABLE: "db.sql.table",
      /**
       * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
       */
      EXCEPTION_TYPE: "exception.type",
      /**
       * The exception message.
       */
      EXCEPTION_MESSAGE: "exception.message",
      /**
       * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
       */
      EXCEPTION_STACKTRACE: "exception.stacktrace",
      /**
        * SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.
        *
        * Note: An exception is considered to have escaped (or left) the scope of a span,
      if that span is ended while the exception is still logically &#34;in flight&#34;.
      This may be actually &#34;in flight&#34; in some languages (e.g. if the exception
      is passed to a Context manager&#39;s `__exit__` method in Python) but will
      usually be caught at the point of recording the exception in most languages.
      
      It is usually not possible to determine at the point where an exception is thrown
      whether it will escape the scope of a span.
      However, it is trivial to know that an exception
      will escape, if one checks for an active exception just before ending the span,
      as done in the [example above](#exception-end-example).
      
      It follows that an exception may still escape the scope of the span
      even if the `exception.escaped` attribute was not set or set to false,
      since the event might have been recorded at a time where it was not
      clear whether the exception will escape.
        */
      EXCEPTION_ESCAPED: "exception.escaped",
      /**
       * Type of the trigger on which the function is executed.
       */
      FAAS_TRIGGER: "faas.trigger",
      /**
       * The execution ID of the current function execution.
       */
      FAAS_EXECUTION: "faas.execution",
      /**
       * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.
       */
      FAAS_DOCUMENT_COLLECTION: "faas.document.collection",
      /**
       * Describes the type of the operation that was performed on the data.
       */
      FAAS_DOCUMENT_OPERATION: "faas.document.operation",
      /**
       * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
       */
      FAAS_DOCUMENT_TIME: "faas.document.time",
      /**
       * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.
       */
      FAAS_DOCUMENT_NAME: "faas.document.name",
      /**
       * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
       */
      FAAS_TIME: "faas.time",
      /**
       * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).
       */
      FAAS_CRON: "faas.cron",
      /**
       * A boolean that is true if the serverless function is executed for the first time (aka cold-start).
       */
      FAAS_COLDSTART: "faas.coldstart",
      /**
       * The name of the invoked function.
       *
       * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.
       */
      FAAS_INVOKED_NAME: "faas.invoked_name",
      /**
       * The cloud provider of the invoked function.
       *
       * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
       */
      FAAS_INVOKED_PROVIDER: "faas.invoked_provider",
      /**
       * The cloud region of the invoked function.
       *
       * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.
       */
      FAAS_INVOKED_REGION: "faas.invoked_region",
      /**
       * Transport protocol used. See note below.
       */
      NET_TRANSPORT: "net.transport",
      /**
       * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).
       */
      NET_PEER_IP: "net.peer.ip",
      /**
       * Remote port number.
       */
      NET_PEER_PORT: "net.peer.port",
      /**
       * Remote hostname or similar, see note below.
       */
      NET_PEER_NAME: "net.peer.name",
      /**
       * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.
       */
      NET_HOST_IP: "net.host.ip",
      /**
       * Like `net.peer.port` but for the host port.
       */
      NET_HOST_PORT: "net.host.port",
      /**
       * Local hostname or similar, see note below.
       */
      NET_HOST_NAME: "net.host.name",
      /**
       * The internet connection type currently being used by the host.
       */
      NET_HOST_CONNECTION_TYPE: "net.host.connection.type",
      /**
       * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
       */
      NET_HOST_CONNECTION_SUBTYPE: "net.host.connection.subtype",
      /**
       * The name of the mobile carrier.
       */
      NET_HOST_CARRIER_NAME: "net.host.carrier.name",
      /**
       * The mobile carrier country code.
       */
      NET_HOST_CARRIER_MCC: "net.host.carrier.mcc",
      /**
       * The mobile carrier network code.
       */
      NET_HOST_CARRIER_MNC: "net.host.carrier.mnc",
      /**
       * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.
       */
      NET_HOST_CARRIER_ICC: "net.host.carrier.icc",
      /**
       * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.
       */
      PEER_SERVICE: "peer.service",
      /**
       * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.
       */
      ENDUSER_ID: "enduser.id",
      /**
       * Actual/assumed role the client is making the request under extracted from token or application security context.
       */
      ENDUSER_ROLE: "enduser.role",
      /**
       * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).
       */
      ENDUSER_SCOPE: "enduser.scope",
      /**
       * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).
       */
      THREAD_ID: "thread.id",
      /**
       * Current thread name.
       */
      THREAD_NAME: "thread.name",
      /**
       * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).
       */
      CODE_FUNCTION: "code.function",
      /**
       * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.
       */
      CODE_NAMESPACE: "code.namespace",
      /**
       * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).
       */
      CODE_FILEPATH: "code.filepath",
      /**
       * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.
       */
      CODE_LINENO: "code.lineno",
      /**
       * HTTP request method.
       */
      HTTP_METHOD: "http.method",
      /**
       * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
       *
       * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
       */
      HTTP_URL: "http.url",
      /**
       * The full request target as passed in a HTTP request line or equivalent.
       */
      HTTP_TARGET: "http.target",
      /**
       * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
       *
       * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
       */
      HTTP_HOST: "http.host",
      /**
       * The URI scheme identifying the used protocol.
       */
      HTTP_SCHEME: "http.scheme",
      /**
       * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
       */
      HTTP_STATUS_CODE: "http.status_code",
      /**
       * Kind of HTTP protocol used.
       *
       * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
       */
      HTTP_FLAVOR: "http.flavor",
      /**
       * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
       */
      HTTP_USER_AGENT: "http.user_agent",
      /**
       * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
       */
      HTTP_REQUEST_CONTENT_LENGTH: "http.request_content_length",
      /**
       * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
       */
      HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: "http.request_content_length_uncompressed",
      /**
       * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
       */
      HTTP_RESPONSE_CONTENT_LENGTH: "http.response_content_length",
      /**
       * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
       */
      HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: "http.response_content_length_uncompressed",
      /**
       * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).
       *
       * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.
       */
      HTTP_SERVER_NAME: "http.server_name",
      /**
       * The matched route (path template).
       */
      HTTP_ROUTE: "http.route",
      /**
        * The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).
        *
        * Note: This is not necessarily the same as `net.peer.ip`, which would
      identify the network-level peer, which may be a proxy.
      
      This attribute should be set when a source of information different
      from the one used for `net.peer.ip`, is available even if that other
      source just confirms the same value as `net.peer.ip`.
      Rationale: For `net.peer.ip`, one typically does not know if it
      comes from a proxy, reverse proxy, or the actual client. Setting
      `http.client_ip` when it&#39;s the same as `net.peer.ip` means that
      one is at least somewhat confident that the address is not that of
      the closest proxy.
        */
      HTTP_CLIENT_IP: "http.client_ip",
      /**
       * The keys in the `RequestItems` object field.
       */
      AWS_DYNAMODB_TABLE_NAMES: "aws.dynamodb.table_names",
      /**
       * The JSON-serialized value of each item in the `ConsumedCapacity` response field.
       */
      AWS_DYNAMODB_CONSUMED_CAPACITY: "aws.dynamodb.consumed_capacity",
      /**
       * The JSON-serialized value of the `ItemCollectionMetrics` response field.
       */
      AWS_DYNAMODB_ITEM_COLLECTION_METRICS: "aws.dynamodb.item_collection_metrics",
      /**
       * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.
       */
      AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: "aws.dynamodb.provisioned_read_capacity",
      /**
       * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.
       */
      AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: "aws.dynamodb.provisioned_write_capacity",
      /**
       * The value of the `ConsistentRead` request parameter.
       */
      AWS_DYNAMODB_CONSISTENT_READ: "aws.dynamodb.consistent_read",
      /**
       * The value of the `ProjectionExpression` request parameter.
       */
      AWS_DYNAMODB_PROJECTION: "aws.dynamodb.projection",
      /**
       * The value of the `Limit` request parameter.
       */
      AWS_DYNAMODB_LIMIT: "aws.dynamodb.limit",
      /**
       * The value of the `AttributesToGet` request parameter.
       */
      AWS_DYNAMODB_ATTRIBUTES_TO_GET: "aws.dynamodb.attributes_to_get",
      /**
       * The value of the `IndexName` request parameter.
       */
      AWS_DYNAMODB_INDEX_NAME: "aws.dynamodb.index_name",
      /**
       * The value of the `Select` request parameter.
       */
      AWS_DYNAMODB_SELECT: "aws.dynamodb.select",
      /**
       * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.
       */
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: "aws.dynamodb.global_secondary_indexes",
      /**
       * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.
       */
      AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: "aws.dynamodb.local_secondary_indexes",
      /**
       * The value of the `ExclusiveStartTableName` request parameter.
       */
      AWS_DYNAMODB_EXCLUSIVE_START_TABLE: "aws.dynamodb.exclusive_start_table",
      /**
       * The the number of items in the `TableNames` response parameter.
       */
      AWS_DYNAMODB_TABLE_COUNT: "aws.dynamodb.table_count",
      /**
       * The value of the `ScanIndexForward` request parameter.
       */
      AWS_DYNAMODB_SCAN_FORWARD: "aws.dynamodb.scan_forward",
      /**
       * The value of the `Segment` request parameter.
       */
      AWS_DYNAMODB_SEGMENT: "aws.dynamodb.segment",
      /**
       * The value of the `TotalSegments` request parameter.
       */
      AWS_DYNAMODB_TOTAL_SEGMENTS: "aws.dynamodb.total_segments",
      /**
       * The value of the `Count` response parameter.
       */
      AWS_DYNAMODB_COUNT: "aws.dynamodb.count",
      /**
       * The value of the `ScannedCount` response parameter.
       */
      AWS_DYNAMODB_SCANNED_COUNT: "aws.dynamodb.scanned_count",
      /**
       * The JSON-serialized value of each item in the `AttributeDefinitions` request field.
       */
      AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: "aws.dynamodb.attribute_definitions",
      /**
       * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.
       */
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: "aws.dynamodb.global_secondary_index_updates",
      /**
       * A string identifying the messaging system.
       */
      MESSAGING_SYSTEM: "messaging.system",
      /**
       * The message destination name. This might be equal to the span name but is required nevertheless.
       */
      MESSAGING_DESTINATION: "messaging.destination",
      /**
       * The kind of message destination.
       */
      MESSAGING_DESTINATION_KIND: "messaging.destination_kind",
      /**
       * A boolean that is true if the message destination is temporary.
       */
      MESSAGING_TEMP_DESTINATION: "messaging.temp_destination",
      /**
       * The name of the transport protocol.
       */
      MESSAGING_PROTOCOL: "messaging.protocol",
      /**
       * The version of the transport protocol.
       */
      MESSAGING_PROTOCOL_VERSION: "messaging.protocol_version",
      /**
       * Connection string.
       */
      MESSAGING_URL: "messaging.url",
      /**
       * A value used by the messaging system as an identifier for the message, represented as a string.
       */
      MESSAGING_MESSAGE_ID: "messaging.message_id",
      /**
       * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.
       */
      MESSAGING_CONVERSATION_ID: "messaging.conversation_id",
      /**
       * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.
       */
      MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: "messaging.message_payload_size_bytes",
      /**
       * The compressed size of the message payload in bytes.
       */
      MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: "messaging.message_payload_compressed_size_bytes",
      /**
       * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
       */
      MESSAGING_OPERATION: "messaging.operation",
      /**
       * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.
       */
      MESSAGING_CONSUMER_ID: "messaging.consumer_id",
      /**
       * RabbitMQ message routing key.
       */
      MESSAGING_RABBITMQ_ROUTING_KEY: "messaging.rabbitmq.routing_key",
      /**
       * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.
       *
       * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.
       */
      MESSAGING_KAFKA_MESSAGE_KEY: "messaging.kafka.message_key",
      /**
       * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
       */
      MESSAGING_KAFKA_CONSUMER_GROUP: "messaging.kafka.consumer_group",
      /**
       * Client Id for the Consumer or Producer that is handling the message.
       */
      MESSAGING_KAFKA_CLIENT_ID: "messaging.kafka.client_id",
      /**
       * Partition the message is sent to.
       */
      MESSAGING_KAFKA_PARTITION: "messaging.kafka.partition",
      /**
       * A boolean that is true if the message is a tombstone.
       */
      MESSAGING_KAFKA_TOMBSTONE: "messaging.kafka.tombstone",
      /**
       * A string identifying the remoting system.
       */
      RPC_SYSTEM: "rpc.system",
      /**
       * The full (logical) name of the service being called, including its package name, if applicable.
       *
       * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).
       */
      RPC_SERVICE: "rpc.service",
      /**
       * The name of the (logical) method being called, must be equal to the $method part in the span name.
       *
       * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).
       */
      RPC_METHOD: "rpc.method",
      /**
       * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
       */
      RPC_GRPC_STATUS_CODE: "rpc.grpc.status_code",
      /**
       * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.
       */
      RPC_JSONRPC_VERSION: "rpc.jsonrpc.version",
      /**
       * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.
       */
      RPC_JSONRPC_REQUEST_ID: "rpc.jsonrpc.request_id",
      /**
       * `error.code` property of response if it is an error response.
       */
      RPC_JSONRPC_ERROR_CODE: "rpc.jsonrpc.error_code",
      /**
       * `error.message` property of response if it is an error response.
       */
      RPC_JSONRPC_ERROR_MESSAGE: "rpc.jsonrpc.error_message",
      /**
       * Whether this is a received or sent message.
       */
      MESSAGE_TYPE: "message.type",
      /**
       * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.
       *
       * Note: This way we guarantee that the values will be consistent between different implementations.
       */
      MESSAGE_ID: "message.id",
      /**
       * Compressed size of the message in bytes.
       */
      MESSAGE_COMPRESSED_SIZE: "message.compressed_size",
      /**
       * Uncompressed size of the message in bytes.
       */
      MESSAGE_UNCOMPRESSED_SIZE: "message.uncompressed_size"
    };
    exports.DbSystemValues = {
      /** Some other SQL database. Fallback only. See notes. */
      OTHER_SQL: "other_sql",
      /** Microsoft SQL Server. */
      MSSQL: "mssql",
      /** MySQL. */
      MYSQL: "mysql",
      /** Oracle Database. */
      ORACLE: "oracle",
      /** IBM Db2. */
      DB2: "db2",
      /** PostgreSQL. */
      POSTGRESQL: "postgresql",
      /** Amazon Redshift. */
      REDSHIFT: "redshift",
      /** Apache Hive. */
      HIVE: "hive",
      /** Cloudscape. */
      CLOUDSCAPE: "cloudscape",
      /** HyperSQL DataBase. */
      HSQLDB: "hsqldb",
      /** Progress Database. */
      PROGRESS: "progress",
      /** SAP MaxDB. */
      MAXDB: "maxdb",
      /** SAP HANA. */
      HANADB: "hanadb",
      /** Ingres. */
      INGRES: "ingres",
      /** FirstSQL. */
      FIRSTSQL: "firstsql",
      /** EnterpriseDB. */
      EDB: "edb",
      /** InterSystems Cach. */
      CACHE: "cache",
      /** Adabas (Adaptable Database System). */
      ADABAS: "adabas",
      /** Firebird. */
      FIREBIRD: "firebird",
      /** Apache Derby. */
      DERBY: "derby",
      /** FileMaker. */
      FILEMAKER: "filemaker",
      /** Informix. */
      INFORMIX: "informix",
      /** InstantDB. */
      INSTANTDB: "instantdb",
      /** InterBase. */
      INTERBASE: "interbase",
      /** MariaDB. */
      MARIADB: "mariadb",
      /** Netezza. */
      NETEZZA: "netezza",
      /** Pervasive PSQL. */
      PERVASIVE: "pervasive",
      /** PointBase. */
      POINTBASE: "pointbase",
      /** SQLite. */
      SQLITE: "sqlite",
      /** Sybase. */
      SYBASE: "sybase",
      /** Teradata. */
      TERADATA: "teradata",
      /** Vertica. */
      VERTICA: "vertica",
      /** H2. */
      H2: "h2",
      /** ColdFusion IMQ. */
      COLDFUSION: "coldfusion",
      /** Apache Cassandra. */
      CASSANDRA: "cassandra",
      /** Apache HBase. */
      HBASE: "hbase",
      /** MongoDB. */
      MONGODB: "mongodb",
      /** Redis. */
      REDIS: "redis",
      /** Couchbase. */
      COUCHBASE: "couchbase",
      /** CouchDB. */
      COUCHDB: "couchdb",
      /** Microsoft Azure Cosmos DB. */
      COSMOSDB: "cosmosdb",
      /** Amazon DynamoDB. */
      DYNAMODB: "dynamodb",
      /** Neo4j. */
      NEO4J: "neo4j",
      /** Apache Geode. */
      GEODE: "geode",
      /** Elasticsearch. */
      ELASTICSEARCH: "elasticsearch",
      /** Memcached. */
      MEMCACHED: "memcached",
      /** CockroachDB. */
      COCKROACHDB: "cockroachdb"
    };
    exports.DbCassandraConsistencyLevelValues = {
      /** all. */
      ALL: "all",
      /** each_quorum. */
      EACH_QUORUM: "each_quorum",
      /** quorum. */
      QUORUM: "quorum",
      /** local_quorum. */
      LOCAL_QUORUM: "local_quorum",
      /** one. */
      ONE: "one",
      /** two. */
      TWO: "two",
      /** three. */
      THREE: "three",
      /** local_one. */
      LOCAL_ONE: "local_one",
      /** any. */
      ANY: "any",
      /** serial. */
      SERIAL: "serial",
      /** local_serial. */
      LOCAL_SERIAL: "local_serial"
    };
    exports.FaasTriggerValues = {
      /** A response to some data source operation such as a database or filesystem read/write. */
      DATASOURCE: "datasource",
      /** To provide an answer to an inbound HTTP request. */
      HTTP: "http",
      /** A function is set to be executed when messages are sent to a messaging system. */
      PUBSUB: "pubsub",
      /** A function is scheduled to be executed regularly. */
      TIMER: "timer",
      /** If none of the others apply. */
      OTHER: "other"
    };
    exports.FaasDocumentOperationValues = {
      /** When a new object is created. */
      INSERT: "insert",
      /** When an object is modified. */
      EDIT: "edit",
      /** When an object is deleted. */
      DELETE: "delete"
    };
    exports.FaasInvokedProviderValues = {
      /** Alibaba Cloud. */
      ALIBABA_CLOUD: "alibaba_cloud",
      /** Amazon Web Services. */
      AWS: "aws",
      /** Microsoft Azure. */
      AZURE: "azure",
      /** Google Cloud Platform. */
      GCP: "gcp"
    };
    exports.NetTransportValues = {
      /** ip_tcp. */
      IP_TCP: "ip_tcp",
      /** ip_udp. */
      IP_UDP: "ip_udp",
      /** Another IP-based protocol. */
      IP: "ip",
      /** Unix Domain socket. See below. */
      UNIX: "unix",
      /** Named or anonymous pipe. See note below. */
      PIPE: "pipe",
      /** In-process communication. */
      INPROC: "inproc",
      /** Something else (non IP-based). */
      OTHER: "other"
    };
    exports.NetHostConnectionTypeValues = {
      /** wifi. */
      WIFI: "wifi",
      /** wired. */
      WIRED: "wired",
      /** cell. */
      CELL: "cell",
      /** unavailable. */
      UNAVAILABLE: "unavailable",
      /** unknown. */
      UNKNOWN: "unknown"
    };
    exports.NetHostConnectionSubtypeValues = {
      /** GPRS. */
      GPRS: "gprs",
      /** EDGE. */
      EDGE: "edge",
      /** UMTS. */
      UMTS: "umts",
      /** CDMA. */
      CDMA: "cdma",
      /** EVDO Rel. 0. */
      EVDO_0: "evdo_0",
      /** EVDO Rev. A. */
      EVDO_A: "evdo_a",
      /** CDMA2000 1XRTT. */
      CDMA2000_1XRTT: "cdma2000_1xrtt",
      /** HSDPA. */
      HSDPA: "hsdpa",
      /** HSUPA. */
      HSUPA: "hsupa",
      /** HSPA. */
      HSPA: "hspa",
      /** IDEN. */
      IDEN: "iden",
      /** EVDO Rev. B. */
      EVDO_B: "evdo_b",
      /** LTE. */
      LTE: "lte",
      /** EHRPD. */
      EHRPD: "ehrpd",
      /** HSPAP. */
      HSPAP: "hspap",
      /** GSM. */
      GSM: "gsm",
      /** TD-SCDMA. */
      TD_SCDMA: "td_scdma",
      /** IWLAN. */
      IWLAN: "iwlan",
      /** 5G NR (New Radio). */
      NR: "nr",
      /** 5G NRNSA (New Radio Non-Standalone). */
      NRNSA: "nrnsa",
      /** LTE CA. */
      LTE_CA: "lte_ca"
    };
    exports.HttpFlavorValues = {
      /** HTTP 1.0. */
      HTTP_1_0: "1.0",
      /** HTTP 1.1. */
      HTTP_1_1: "1.1",
      /** HTTP 2. */
      HTTP_2_0: "2.0",
      /** SPDY protocol. */
      SPDY: "SPDY",
      /** QUIC protocol. */
      QUIC: "QUIC"
    };
    exports.MessagingDestinationKindValues = {
      /** A message sent to a queue. */
      QUEUE: "queue",
      /** A message sent to a topic. */
      TOPIC: "topic"
    };
    exports.MessagingOperationValues = {
      /** receive. */
      RECEIVE: "receive",
      /** process. */
      PROCESS: "process"
    };
    exports.RpcGrpcStatusCodeValues = {
      /** OK. */
      OK: 0,
      /** CANCELLED. */
      CANCELLED: 1,
      /** UNKNOWN. */
      UNKNOWN: 2,
      /** INVALID_ARGUMENT. */
      INVALID_ARGUMENT: 3,
      /** DEADLINE_EXCEEDED. */
      DEADLINE_EXCEEDED: 4,
      /** NOT_FOUND. */
      NOT_FOUND: 5,
      /** ALREADY_EXISTS. */
      ALREADY_EXISTS: 6,
      /** PERMISSION_DENIED. */
      PERMISSION_DENIED: 7,
      /** RESOURCE_EXHAUSTED. */
      RESOURCE_EXHAUSTED: 8,
      /** FAILED_PRECONDITION. */
      FAILED_PRECONDITION: 9,
      /** ABORTED. */
      ABORTED: 10,
      /** OUT_OF_RANGE. */
      OUT_OF_RANGE: 11,
      /** UNIMPLEMENTED. */
      UNIMPLEMENTED: 12,
      /** INTERNAL. */
      INTERNAL: 13,
      /** UNAVAILABLE. */
      UNAVAILABLE: 14,
      /** DATA_LOSS. */
      DATA_LOSS: 15,
      /** UNAUTHENTICATED. */
      UNAUTHENTICATED: 16
    };
    exports.MessageTypeValues = {
      /** sent. */
      SENT: "SENT",
      /** received. */
      RECEIVED: "RECEIVED"
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.1/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.1/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_SemanticAttributes(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.1/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.1/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TelemetrySdkLanguageValues = exports.OsTypeValues = exports.HostArchValues = exports.AwsEcsLaunchtypeValues = exports.CloudPlatformValues = exports.CloudProviderValues = exports.SemanticResourceAttributes = void 0;
    exports.SemanticResourceAttributes = {
      /**
       * Name of the cloud provider.
       */
      CLOUD_PROVIDER: "cloud.provider",
      /**
       * The cloud account ID the resource is assigned to.
       */
      CLOUD_ACCOUNT_ID: "cloud.account.id",
      /**
       * The geographical region the resource is running. Refer to your provider&#39;s docs to see the available regions, for example [Alibaba Cloud regions](https://www.alibabacloud.com/help/doc-detail/40654.htm), [AWS regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/), [Azure regions](https://azure.microsoft.com/en-us/global-infrastructure/geographies/), or [Google Cloud regions](https://cloud.google.com/about/locations).
       */
      CLOUD_REGION: "cloud.region",
      /**
       * Cloud regions often have multiple, isolated locations known as zones to increase availability. Availability zone represents the zone where the resource is running.
       *
       * Note: Availability zones are called &#34;zones&#34; on Alibaba Cloud and Google Cloud.
       */
      CLOUD_AVAILABILITY_ZONE: "cloud.availability_zone",
      /**
       * The cloud platform in use.
       *
       * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
       */
      CLOUD_PLATFORM: "cloud.platform",
      /**
       * The Amazon Resource Name (ARN) of an [ECS container instance](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html).
       */
      AWS_ECS_CONTAINER_ARN: "aws.ecs.container.arn",
      /**
       * The ARN of an [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html).
       */
      AWS_ECS_CLUSTER_ARN: "aws.ecs.cluster.arn",
      /**
       * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
       */
      AWS_ECS_LAUNCHTYPE: "aws.ecs.launchtype",
      /**
       * The ARN of an [ECS task definition](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html).
       */
      AWS_ECS_TASK_ARN: "aws.ecs.task.arn",
      /**
       * The task definition family this task definition is a member of.
       */
      AWS_ECS_TASK_FAMILY: "aws.ecs.task.family",
      /**
       * The revision for this task definition.
       */
      AWS_ECS_TASK_REVISION: "aws.ecs.task.revision",
      /**
       * The ARN of an EKS cluster.
       */
      AWS_EKS_CLUSTER_ARN: "aws.eks.cluster.arn",
      /**
       * The name(s) of the AWS log group(s) an application is writing to.
       *
       * Note: Multiple log groups must be supported for cases like multi-container applications, where a single application has sidecar containers, and each write to their own log group.
       */
      AWS_LOG_GROUP_NAMES: "aws.log.group.names",
      /**
       * The Amazon Resource Name(s) (ARN) of the AWS log group(s).
       *
       * Note: See the [log group ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format).
       */
      AWS_LOG_GROUP_ARNS: "aws.log.group.arns",
      /**
       * The name(s) of the AWS log stream(s) an application is writing to.
       */
      AWS_LOG_STREAM_NAMES: "aws.log.stream.names",
      /**
       * The ARN(s) of the AWS log stream(s).
       *
       * Note: See the [log stream ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format). One log group can contain several log streams, so these ARNs necessarily identify both a log group and a log stream.
       */
      AWS_LOG_STREAM_ARNS: "aws.log.stream.arns",
      /**
       * Container name.
       */
      CONTAINER_NAME: "container.name",
      /**
       * Container ID. Usually a UUID, as for example used to [identify Docker containers](https://docs.docker.com/engine/reference/run/#container-identification). The UUID might be abbreviated.
       */
      CONTAINER_ID: "container.id",
      /**
       * The container runtime managing this container.
       */
      CONTAINER_RUNTIME: "container.runtime",
      /**
       * Name of the image the container was built on.
       */
      CONTAINER_IMAGE_NAME: "container.image.name",
      /**
       * Container image tag.
       */
      CONTAINER_IMAGE_TAG: "container.image.tag",
      /**
       * Name of the [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
       */
      DEPLOYMENT_ENVIRONMENT: "deployment.environment",
      /**
       * A unique identifier representing the device.
       *
       * Note: The device identifier MUST only be defined using the values outlined below. This value is not an advertising identifier and MUST NOT be used as such. On iOS (Swift or Objective-C), this value MUST be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor). On Android (Java or Kotlin), this value MUST be equal to the Firebase Installation ID or a globally unique UUID which is persisted across sessions in your application. More information can be found [here](https://developer.android.com/training/articles/user-data-ids) on best practices and exact implementation details. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply, ensure you do your own due diligence.
       */
      DEVICE_ID: "device.id",
      /**
       * The model identifier for the device.
       *
       * Note: It&#39;s recommended this value represents a machine readable version of the model identifier rather than the market or consumer-friendly name of the device.
       */
      DEVICE_MODEL_IDENTIFIER: "device.model.identifier",
      /**
       * The marketing name for the device model.
       *
       * Note: It&#39;s recommended this value represents a human readable version of the device model rather than a machine readable alternative.
       */
      DEVICE_MODEL_NAME: "device.model.name",
      /**
       * The name of the single function that this runtime instance executes.
       *
       * Note: This is the name of the function as configured/deployed on the FaaS platform and is usually different from the name of the callback function (which may be stored in the [`code.namespace`/`code.function`](../../trace/semantic_conventions/span-general.md#source-code-attributes) span attributes).
       */
      FAAS_NAME: "faas.name",
      /**
        * The unique ID of the single function that this runtime instance executes.
        *
        * Note: Depending on the cloud provider, use:
      
      * **AWS Lambda:** The function [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
      Take care not to use the &#34;invoked ARN&#34; directly but replace any
      [alias suffix](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html) with the resolved function version, as the same runtime instance may be invokable with multiple
      different aliases.
      * **GCP:** The [URI of the resource](https://cloud.google.com/iam/docs/full-resource-names)
      * **Azure:** The [Fully Qualified Resource ID](https://docs.microsoft.com/en-us/rest/api/resources/resources/get-by-id).
      
      On some providers, it may not be possible to determine the full ID at startup,
      which is why this field cannot be made required. For example, on AWS the account ID
      part of the ARN is not available without calling another AWS API
      which may be deemed too slow for a short-running lambda function.
      As an alternative, consider setting `faas.id` as a span attribute instead.
        */
      FAAS_ID: "faas.id",
      /**
        * The immutable version of the function being executed.
        *
        * Note: Depending on the cloud provider and platform, use:
      
      * **AWS Lambda:** The [function version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
        (an integer represented as a decimal string).
      * **Google Cloud Run:** The [revision](https://cloud.google.com/run/docs/managing/revisions)
        (i.e., the function name plus the revision suffix).
      * **Google Cloud Functions:** The value of the
        [`K_REVISION` environment variable](https://cloud.google.com/functions/docs/env-var#runtime_environment_variables_set_automatically).
      * **Azure Functions:** Not applicable. Do not set this attribute.
        */
      FAAS_VERSION: "faas.version",
      /**
       * The execution environment ID as a string, that will be potentially reused for other invocations to the same function/function version.
       *
       * Note: * **AWS Lambda:** Use the (full) log stream name.
       */
      FAAS_INSTANCE: "faas.instance",
      /**
       * The amount of memory available to the serverless function in MiB.
       *
       * Note: It&#39;s recommended to set this attribute since e.g. too little memory can easily stop a Java AWS Lambda function from working correctly. On AWS Lambda, the environment variable `AWS_LAMBDA_FUNCTION_MEMORY_SIZE` provides this information.
       */
      FAAS_MAX_MEMORY: "faas.max_memory",
      /**
       * Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider.
       */
      HOST_ID: "host.id",
      /**
       * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
       */
      HOST_NAME: "host.name",
      /**
       * Type of host. For Cloud, this must be the machine type.
       */
      HOST_TYPE: "host.type",
      /**
       * The CPU architecture the host system is running on.
       */
      HOST_ARCH: "host.arch",
      /**
       * Name of the VM image or OS install the host was instantiated from.
       */
      HOST_IMAGE_NAME: "host.image.name",
      /**
       * VM image ID. For Cloud, this value is from the provider.
       */
      HOST_IMAGE_ID: "host.image.id",
      /**
       * The version string of the VM image as defined in [Version SpanAttributes](README.md#version-attributes).
       */
      HOST_IMAGE_VERSION: "host.image.version",
      /**
       * The name of the cluster.
       */
      K8S_CLUSTER_NAME: "k8s.cluster.name",
      /**
       * The name of the Node.
       */
      K8S_NODE_NAME: "k8s.node.name",
      /**
       * The UID of the Node.
       */
      K8S_NODE_UID: "k8s.node.uid",
      /**
       * The name of the namespace that the pod is running in.
       */
      K8S_NAMESPACE_NAME: "k8s.namespace.name",
      /**
       * The UID of the Pod.
       */
      K8S_POD_UID: "k8s.pod.uid",
      /**
       * The name of the Pod.
       */
      K8S_POD_NAME: "k8s.pod.name",
      /**
       * The name of the Container in a Pod template.
       */
      K8S_CONTAINER_NAME: "k8s.container.name",
      /**
       * The UID of the ReplicaSet.
       */
      K8S_REPLICASET_UID: "k8s.replicaset.uid",
      /**
       * The name of the ReplicaSet.
       */
      K8S_REPLICASET_NAME: "k8s.replicaset.name",
      /**
       * The UID of the Deployment.
       */
      K8S_DEPLOYMENT_UID: "k8s.deployment.uid",
      /**
       * The name of the Deployment.
       */
      K8S_DEPLOYMENT_NAME: "k8s.deployment.name",
      /**
       * The UID of the StatefulSet.
       */
      K8S_STATEFULSET_UID: "k8s.statefulset.uid",
      /**
       * The name of the StatefulSet.
       */
      K8S_STATEFULSET_NAME: "k8s.statefulset.name",
      /**
       * The UID of the DaemonSet.
       */
      K8S_DAEMONSET_UID: "k8s.daemonset.uid",
      /**
       * The name of the DaemonSet.
       */
      K8S_DAEMONSET_NAME: "k8s.daemonset.name",
      /**
       * The UID of the Job.
       */
      K8S_JOB_UID: "k8s.job.uid",
      /**
       * The name of the Job.
       */
      K8S_JOB_NAME: "k8s.job.name",
      /**
       * The UID of the CronJob.
       */
      K8S_CRONJOB_UID: "k8s.cronjob.uid",
      /**
       * The name of the CronJob.
       */
      K8S_CRONJOB_NAME: "k8s.cronjob.name",
      /**
       * The operating system type.
       */
      OS_TYPE: "os.type",
      /**
       * Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands.
       */
      OS_DESCRIPTION: "os.description",
      /**
       * Human readable operating system name.
       */
      OS_NAME: "os.name",
      /**
       * The version string of the operating system as defined in [Version SpanAttributes](../../resource/semantic_conventions/README.md#version-attributes).
       */
      OS_VERSION: "os.version",
      /**
       * Process identifier (PID).
       */
      PROCESS_PID: "process.pid",
      /**
       * The name of the process executable. On Linux based systems, can be set to the `Name` in `proc/[pid]/status`. On Windows, can be set to the base name of `GetProcessImageFileNameW`.
       */
      PROCESS_EXECUTABLE_NAME: "process.executable.name",
      /**
       * The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`.
       */
      PROCESS_EXECUTABLE_PATH: "process.executable.path",
      /**
       * The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`.
       */
      PROCESS_COMMAND: "process.command",
      /**
       * The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead.
       */
      PROCESS_COMMAND_LINE: "process.command_line",
      /**
       * All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`.
       */
      PROCESS_COMMAND_ARGS: "process.command_args",
      /**
       * The username of the user that owns the process.
       */
      PROCESS_OWNER: "process.owner",
      /**
       * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
       */
      PROCESS_RUNTIME_NAME: "process.runtime.name",
      /**
       * The version of the runtime of this process, as returned by the runtime without modification.
       */
      PROCESS_RUNTIME_VERSION: "process.runtime.version",
      /**
       * An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment.
       */
      PROCESS_RUNTIME_DESCRIPTION: "process.runtime.description",
      /**
       * Logical name of the service.
       *
       * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
       */
      SERVICE_NAME: "service.name",
      /**
       * A namespace for `service.name`.
       *
       * Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
       */
      SERVICE_NAMESPACE: "service.namespace",
      /**
       * The string ID of the service instance.
       *
       * Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled service). It is preferable for the ID to be persistent and stay the same for the lifetime of the service instance, however it is acceptable that the ID is ephemeral and changes during important lifetime events for the service (e.g. service restarts). If the service has no inherent unique ID that can be used as the value of this attribute it is recommended to generate a random Version 1 or Version 4 RFC 4122 UUID (services aiming for reproducible UUIDs may also use Version 5, see RFC 4122 for more recommendations).
       */
      SERVICE_INSTANCE_ID: "service.instance.id",
      /**
       * The version string of the service API or implementation.
       */
      SERVICE_VERSION: "service.version",
      /**
       * The name of the telemetry SDK as defined above.
       */
      TELEMETRY_SDK_NAME: "telemetry.sdk.name",
      /**
       * The language of the telemetry SDK.
       */
      TELEMETRY_SDK_LANGUAGE: "telemetry.sdk.language",
      /**
       * The version string of the telemetry SDK.
       */
      TELEMETRY_SDK_VERSION: "telemetry.sdk.version",
      /**
       * The version string of the auto instrumentation agent, if used.
       */
      TELEMETRY_AUTO_VERSION: "telemetry.auto.version",
      /**
       * The name of the web engine.
       */
      WEBENGINE_NAME: "webengine.name",
      /**
       * The version of the web engine.
       */
      WEBENGINE_VERSION: "webengine.version",
      /**
       * Additional description of the web engine (e.g. detailed version and edition information).
       */
      WEBENGINE_DESCRIPTION: "webengine.description"
    };
    exports.CloudProviderValues = {
      /** Alibaba Cloud. */
      ALIBABA_CLOUD: "alibaba_cloud",
      /** Amazon Web Services. */
      AWS: "aws",
      /** Microsoft Azure. */
      AZURE: "azure",
      /** Google Cloud Platform. */
      GCP: "gcp"
    };
    exports.CloudPlatformValues = {
      /** Alibaba Cloud Elastic Compute Service. */
      ALIBABA_CLOUD_ECS: "alibaba_cloud_ecs",
      /** Alibaba Cloud Function Compute. */
      ALIBABA_CLOUD_FC: "alibaba_cloud_fc",
      /** AWS Elastic Compute Cloud. */
      AWS_EC2: "aws_ec2",
      /** AWS Elastic Container Service. */
      AWS_ECS: "aws_ecs",
      /** AWS Elastic Kubernetes Service. */
      AWS_EKS: "aws_eks",
      /** AWS Lambda. */
      AWS_LAMBDA: "aws_lambda",
      /** AWS Elastic Beanstalk. */
      AWS_ELASTIC_BEANSTALK: "aws_elastic_beanstalk",
      /** Azure Virtual Machines. */
      AZURE_VM: "azure_vm",
      /** Azure Container Instances. */
      AZURE_CONTAINER_INSTANCES: "azure_container_instances",
      /** Azure Kubernetes Service. */
      AZURE_AKS: "azure_aks",
      /** Azure Functions. */
      AZURE_FUNCTIONS: "azure_functions",
      /** Azure App Service. */
      AZURE_APP_SERVICE: "azure_app_service",
      /** Google Cloud Compute Engine (GCE). */
      GCP_COMPUTE_ENGINE: "gcp_compute_engine",
      /** Google Cloud Run. */
      GCP_CLOUD_RUN: "gcp_cloud_run",
      /** Google Cloud Kubernetes Engine (GKE). */
      GCP_KUBERNETES_ENGINE: "gcp_kubernetes_engine",
      /** Google Cloud Functions (GCF). */
      GCP_CLOUD_FUNCTIONS: "gcp_cloud_functions",
      /** Google Cloud App Engine (GAE). */
      GCP_APP_ENGINE: "gcp_app_engine"
    };
    exports.AwsEcsLaunchtypeValues = {
      /** ec2. */
      EC2: "ec2",
      /** fargate. */
      FARGATE: "fargate"
    };
    exports.HostArchValues = {
      /** AMD64. */
      AMD64: "amd64",
      /** ARM32. */
      ARM32: "arm32",
      /** ARM64. */
      ARM64: "arm64",
      /** Itanium. */
      IA64: "ia64",
      /** 32-bit PowerPC. */
      PPC32: "ppc32",
      /** 64-bit PowerPC. */
      PPC64: "ppc64",
      /** 32-bit x86. */
      X86: "x86"
    };
    exports.OsTypeValues = {
      /** Microsoft Windows. */
      WINDOWS: "windows",
      /** Linux. */
      LINUX: "linux",
      /** Apple Darwin. */
      DARWIN: "darwin",
      /** FreeBSD. */
      FREEBSD: "freebsd",
      /** NetBSD. */
      NETBSD: "netbsd",
      /** OpenBSD. */
      OPENBSD: "openbsd",
      /** DragonFly BSD. */
      DRAGONFLYBSD: "dragonflybsd",
      /** HP-UX (Hewlett Packard Unix). */
      HPUX: "hpux",
      /** AIX (Advanced Interactive eXecutive). */
      AIX: "aix",
      /** Oracle Solaris. */
      SOLARIS: "solaris",
      /** IBM z/OS. */
      Z_OS: "z_os"
    };
    exports.TelemetrySdkLanguageValues = {
      /** cpp. */
      CPP: "cpp",
      /** dotnet. */
      DOTNET: "dotnet",
      /** erlang. */
      ERLANG: "erlang",
      /** go. */
      GO: "go",
      /** java. */
      JAVA: "java",
      /** nodejs. */
      NODEJS: "nodejs",
      /** php. */
      PHP: "php",
      /** python. */
      PYTHON: "python",
      /** ruby. */
      RUBY: "ruby",
      /** webjs. */
      WEBJS: "webjs"
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.1/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.1/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_SemanticResourceAttributes(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.1/node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.1/node_modules/@opentelemetry/semantic-conventions/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_trace2(), exports);
    __exportStar(require_resource(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.SDK_INFO = void 0;
    var version_1 = require_version2(), semantic_conventions_1 = require_src2();
    exports.SDK_INFO = {
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TelemetrySdkLanguageValues.NODEJS,
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports.unrefTimer = unrefTimer;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_environment2(), exports);
    __exportStar(require_globalThis3(), exports);
    __exportStar(require_hex_to_base64(), exports);
    __exportStar(require_RandomIdGenerator(), exports);
    __exportStar(require_performance(), exports);
    __exportStar(require_sdk_info(), exports);
    __exportStar(require_timer_util(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_node2(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/time.js
var require_time = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/time.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = void 0;
    var platform_1 = require_platform2(), NANOSECOND_DIGITS = 9, NANOSECOND_DIGITS_IN_MILLIS = 6, MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS), SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      let epochSeconds = epochMillis / 1e3, seconds = Math.trunc(epochSeconds), nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin != "number") {
        let perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      let timeOrigin = millisToHrTime(getTimeOrigin()), now = millisToHrTime(typeof performanceNow == "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time))
        return time;
      if (typeof time == "number")
        return time < getTimeOrigin() ? hrTime(time) : millisToHrTime(time);
      if (time instanceof Date)
        return millisToHrTime(time.getTime());
      throw TypeError("Invalid input type");
    }
    exports.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0], nanos = endTime[1] - startTime[1];
      return nanos < 0 && (seconds -= 1, nanos += SECOND_TO_NANOSECONDS), [seconds, nanos];
    }
    exports.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      let precision = NANOSECOND_DIGITS, tmp = `${"0".repeat(precision)}${time[1]}Z`, nanoString = tmp.substr(tmp.length - precision - 1);
      return new Date(time[0] * 1e3).toISOString().replace("000Z", nanoString);
    }
    exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] == "number" && typeof value[1] == "number";
    }
    exports.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value == "number" || value instanceof Date;
    }
    exports.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      let out = [time1[0] + time2[0], time1[1] + time2[1]];
      return out[1] >= SECOND_TO_NANOSECONDS && (out[1] -= SECOND_TO_NANOSECONDS, out[0] += 1), out;
    }
    exports.addHrTimes = addHrTimes;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/types.js
var require_types4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ExportResultCode = void 0;
    var ExportResultCode2;
    (function(ExportResultCode3) {
      ExportResultCode3[ExportResultCode3.SUCCESS = 0] = "SUCCESS", ExportResultCode3[ExportResultCode3.FAILED = 1] = "FAILED";
    })(ExportResultCode2 = exports.ExportResultCode || (exports.ExportResultCode = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.CompositePropagator = void 0;
    var api_1 = require_src(), CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [], this._fields = Array.from(new Set(this._propagators.map((p) => typeof p.fields == "function" ? p.fields() : []).reduce((x, y) => x.concat(y), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context, carrier, setter) {
        for (let propagator of this._propagators)
          try {
            propagator.inject(context, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports.CompositePropagator = CompositePropagator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]", VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`, VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`, VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`), VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/, INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    exports.validateKey = validateKey;
    function validateValue(value) {
      return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
    }
    exports.validateValue = validateValue;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TraceState = void 0;
    var validators_1 = require_validators(), MAX_TRACE_STATE_ITEMS = 32, MAX_TRACE_STATE_LEN = 512, LIST_MEMBERS_SEPARATOR = ",", LIST_MEMBER_KEY_VALUE_SPLITTER = "=", TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map(), rawTraceState && this._parse(rawTraceState);
      }
      set(key, value) {
        let traceState = this._clone();
        return traceState._internalState.has(key) && traceState._internalState.delete(key), traceState._internalState.set(key, value), traceState;
      }
      unset(key) {
        let traceState = this._clone();
        return traceState._internalState.delete(key), traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => (agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key)), agg), []).join(LIST_MEMBERS_SEPARATOR);
      }
      _parse(rawTraceState) {
        rawTraceState.length > MAX_TRACE_STATE_LEN || (this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
          let listMember = part.trim(), i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            let key = listMember.slice(0, i), value = listMember.slice(i + 1, part.length);
            (0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value) && agg.set(key, value);
          }
          return agg;
        }, /* @__PURE__ */ new Map()), this._internalState.size > MAX_TRACE_STATE_ITEMS && (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS))));
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        let traceState = new _TraceState();
        return traceState._internalState = new Map(this._internalState), traceState;
      }
    };
    exports.TraceState = TraceState;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = void 0;
    var api_1 = require_src(), suppress_tracing_1 = require_suppress_tracing(), TraceState_1 = require_TraceState();
    exports.TRACE_PARENT_HEADER = "traceparent";
    exports.TRACE_STATE_HEADER = "tracestate";
    var VERSION = "00", VERSION_PART = "(?!ff)[\\da-f]{2}", TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}", PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}", FLAGS_PART = "[\\da-f]{2}", TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      let match = TRACE_PARENT_REGEX.exec(traceParent);
      return !match || match[1] === "00" && match[5] ? null : {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    exports.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context, carrier, setter) {
        let spanContext = api_1.trace.getSpanContext(context);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        let traceParent = `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent), spanContext.traceState && setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
      }
      extract(context, carrier, getter) {
        let traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context;
        let traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent != "string")
          return context;
        let spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context;
        spanContext.isRemote = !0;
        let traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          let state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state == "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context, spanContext);
      }
      fields() {
        return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
      }
    };
    exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js
var require_IdGenerator = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = void 0;
    var api_1 = require_src(), RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA"), RPCType;
    (function(RPCType2) {
      RPCType2.HTTP = "http";
    })(RPCType = exports.RPCType || (exports.RPCType = {}));
    function setRPCMetadata(context, meta) {
      return context.setValue(RPC_METADATA_KEY, meta);
    }
    exports.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context) {
      return context.deleteValue(RPC_METADATA_KEY);
    }
    exports.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context) {
      return context.getValue(RPC_METADATA_KEY);
    }
    exports.getRPCMetadata = getRPCMetadata;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AlwaysOffSampler = void 0;
    var api_1 = require_src(), AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AlwaysOnSampler = void 0;
    var api_1 = require_src(), AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ParentBasedSampler = void 0;
    var api_1 = require_src(), global_error_handler_1 = require_global_error_handler(), AlwaysOffSampler_1 = require_AlwaysOffSampler(), AlwaysOnSampler_1 = require_AlwaysOnSampler(), ParentBasedSampler = class {
      constructor(config) {
        var _a, _b, _c, _d;
        this._root = config.root, this._root || ((0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured")), this._root = new AlwaysOnSampler_1.AlwaysOnSampler()), this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler(), this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler(), this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler(), this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        let parentContext = api_1.trace.getSpanContext(context);
        return !parentContext || !(0, api_1.isSpanContextValid)(parentContext) ? this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links) : parentContext.isRemote ? parentContext.traceFlags & api_1.TraceFlags.SAMPLED ? this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : parentContext.traceFlags & api_1.TraceFlags.SAMPLED ? this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports.ParentBasedSampler = ParentBasedSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TraceIdRatioBasedSampler = void 0;
    var api_1 = require_src(), TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio, this._ratio = this._normalize(_ratio), this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        return typeof ratio != "number" || isNaN(ratio) ? 0 : ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
          let pos = i * 8, part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isPlainObject = void 0;
    var objectTag = "[object Object]", nullTag = "[object Null]", undefinedTag = "[object Undefined]", funcProto = Function.prototype, funcToString = funcProto.toString, objectCtorString = funcToString.call(Object), getPrototype = overArg(Object.getPrototypeOf, Object), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, symToStringTag = Symbol ? Symbol.toStringTag : void 0, nativeObjectToString = objectProto.toString;
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag)
        return !1;
      let proto = getPrototype(value);
      if (proto === null)
        return !0;
      let Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      return value == null ? value === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      let isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag], unmasked = !1;
      try {
        value[symToStringTag] = void 0, unmasked = !0;
      } catch {
      }
      let result = nativeObjectToString.call(value);
      return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.merge = void 0;
    var lodash_merge_1 = require_lodash_merge(), MAX_LEVEL = 20;
    function merge(...args) {
      let result = args.shift(), objects = /* @__PURE__ */ new WeakMap();
      for (; args.length > 0; )
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      return result;
    }
    exports.merge = merge;
    function takeValue(value) {
      return isArray(value) ? value.slice() : value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result;
      if (!(level > MAX_LEVEL)) {
        if (level++, isPrimitive(one) || isPrimitive(two) || isFunction(two))
          result = takeValue(two);
        else if (isArray(one)) {
          if (result = one.slice(), isArray(two))
            for (let i = 0, j = two.length; i < j; i++)
              result.push(takeValue(two[i]));
          else if (isObject(two)) {
            let keys = Object.keys(two);
            for (let i = 0, j = keys.length; i < j; i++) {
              let key = keys[i];
              result[key] = takeValue(two[key]);
            }
          }
        } else if (isObject(one))
          if (isObject(two)) {
            if (!shouldMerge(one, two))
              return two;
            result = Object.assign({}, one);
            let keys = Object.keys(two);
            for (let i = 0, j = keys.length; i < j; i++) {
              let key = keys[i], twoValue = two[key];
              if (isPrimitive(twoValue))
                typeof twoValue > "u" ? delete result[key] : result[key] = twoValue;
              else {
                let obj1 = result[key], obj2 = twoValue;
                if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects))
                  delete result[key];
                else {
                  if (isObject(obj1) && isObject(obj2)) {
                    let arr1 = objects.get(obj1) || [], arr2 = objects.get(obj2) || [];
                    arr1.push({ obj: one, key }), arr2.push({ obj: two, key }), objects.set(obj1, arr1), objects.set(obj2, arr2);
                  }
                  result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
                }
              }
            }
          } else
            result = two;
        return result;
      }
    }
    function wasObjectReferenced(obj, key, objects) {
      let arr = objects.get(obj[key]) || [];
      for (let i = 0, j = arr.length; i < j; i++) {
        let info = arr[i];
        if (info.key === key && info.obj === obj)
          return !0;
      }
      return !1;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value == "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value == "object";
    }
    function isPrimitive(value) {
      return typeof value == "string" || typeof value == "number" || typeof value == "boolean" || typeof value > "u" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      return !(!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two));
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.callWithTimeout = exports.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message), Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout) {
      let timeoutHandle, timeoutPromise = new Promise(function(_resolve, reject) {
        timeoutHandle = setTimeout(function() {
          reject(new TimeoutError("Operation timed out."));
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => (clearTimeout(timeoutHandle), result), (reason) => {
        throw clearTimeout(timeoutHandle), reason;
      });
    }
    exports.callWithTimeout = callWithTimeout;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/url.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isUrlIgnored = exports.urlMatches = void 0;
    function urlMatches(url2, urlToMatch) {
      return typeof urlToMatch == "string" ? url2 === urlToMatch : !!url2.match(urlToMatch);
    }
    exports.urlMatches = urlMatches;
    function isUrlIgnored(url2, ignoredUrls) {
      if (!ignoredUrls)
        return !1;
      for (let ignoreUrl of ignoredUrls)
        if (urlMatches(url2, ignoreUrl))
          return !0;
      return !1;
    }
    exports.isUrlIgnored = isUrlIgnored;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isWrapped = void 0;
    function isWrapped(func) {
      return typeof func == "function" && typeof func.__original == "function" && typeof func.__unwrap == "function" && func.__wrapped === !0;
    }
    exports.isWrapped = isWrapped;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve, this._reject = reject;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports.Deferred = Deferred;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.BindOnceFuture = void 0;
    var promise_1 = require_promise(), BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback, this._that = _that, this._isCalled = !1, this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = !0;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports.BindOnceFuture = BindOnceFuture;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports._export = void 0;
    var api_1 = require_src(), suppress_tracing_1 = require_suppress_tracing();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result) => {
            resolve(result);
          });
        });
      });
    }
    exports._export = _export;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.internal = exports.baggageUtils = void 0;
    __exportStar(require_W3CBaggagePropagator(), exports);
    __exportStar(require_anchored_clock(), exports);
    __exportStar(require_attributes(), exports);
    __exportStar(require_global_error_handler(), exports);
    __exportStar(require_logging_error_handler(), exports);
    __exportStar(require_time(), exports);
    __exportStar(require_types4(), exports);
    __exportStar(require_ExportResult(), exports);
    __exportStar(require_version2(), exports);
    exports.baggageUtils = require_utils4();
    __exportStar(require_platform2(), exports);
    __exportStar(require_composite(), exports);
    __exportStar(require_W3CTraceContextPropagator(), exports);
    __exportStar(require_IdGenerator(), exports);
    __exportStar(require_rpc_metadata(), exports);
    __exportStar(require_AlwaysOffSampler(), exports);
    __exportStar(require_AlwaysOnSampler(), exports);
    __exportStar(require_ParentBasedSampler(), exports);
    __exportStar(require_TraceIdRatioBasedSampler(), exports);
    __exportStar(require_suppress_tracing(), exports);
    __exportStar(require_TraceState(), exports);
    __exportStar(require_environment(), exports);
    __exportStar(require_merge(), exports);
    __exportStar(require_sampling(), exports);
    __exportStar(require_timeout(), exports);
    __exportStar(require_url(), exports);
    __exportStar(require_wrap(), exports);
    __exportStar(require_callback(), exports);
    __exportStar(require_version2(), exports);
    var exporter_1 = require_exporter();
    exports.internal = {
      _export: exporter_1._export
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/LastValue.js
var require_LastValue = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/LastValue.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.LastValueAggregator = exports.LastValueAccumulation = void 0;
    var types_1 = require_types2(), core_1 = require_src3(), MetricData_1 = require_MetricData(), LastValueAccumulation = class {
      constructor(startTime, _current = 0, sampleTime = [0, 0]) {
        this.startTime = startTime, this._current = _current, this.sampleTime = sampleTime;
      }
      record(value) {
        this._current = value, this.sampleTime = (0, core_1.millisToHrTime)(Date.now());
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports.LastValueAccumulation = LastValueAccumulation;
    var LastValueAggregator = class {
      constructor() {
        this.kind = types_1.AggregatorKind.LAST_VALUE;
      }
      createAccumulation(startTime) {
        return new LastValueAccumulation(startTime);
      }
      /**
       * Returns the result of the merge of the given accumulations.
       *
       * Return the newly captured (delta) accumulation for LastValueAggregator.
       */
      merge(previous, delta) {
        let latestAccumulation = (0, core_1.hrTimeToMicroseconds)(delta.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? delta : previous;
        return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       *
       * A delta aggregation is not meaningful to LastValueAggregator, just return
       * the newly captured (delta) accumulation for LastValueAggregator.
       */
      diff(previous, current) {
        let latestAccumulation = (0, core_1.hrTimeToMicroseconds)(current.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? current : previous;
        return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.GAUGE,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => ({
            attributes,
            startTime: accumulation.startTime,
            endTime,
            value: accumulation.toPointValue()
          }))
        };
      }
    };
    exports.LastValueAggregator = LastValueAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Sum.js
var require_Sum = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Sum.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.SumAggregator = exports.SumAccumulation = void 0;
    var types_1 = require_types2(), MetricData_1 = require_MetricData(), SumAccumulation = class {
      constructor(startTime, monotonic, _current = 0, reset = !1) {
        this.startTime = startTime, this.monotonic = monotonic, this._current = _current, this.reset = reset;
      }
      record(value) {
        this.monotonic && value < 0 || (this._current += value);
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports.SumAccumulation = SumAccumulation;
    var SumAggregator = class {
      constructor(monotonic) {
        this.monotonic = monotonic, this.kind = types_1.AggregatorKind.SUM;
      }
      createAccumulation(startTime) {
        return new SumAccumulation(startTime, this.monotonic);
      }
      /**
       * Returns the result of the merge of the given accumulations.
       */
      merge(previous, delta) {
        let prevPv = previous.toPointValue(), deltaPv = delta.toPointValue();
        return delta.reset ? new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset) : new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        let prevPv = previous.toPointValue(), currPv = current.toPointValue();
        return this.monotonic && prevPv > currPv ? new SumAccumulation(current.startTime, this.monotonic, currPv, !0) : new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.SUM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => ({
            attributes,
            startTime: accumulation.startTime,
            endTime,
            value: accumulation.toPointValue()
          })),
          isMonotonic: this.monotonic
        };
      }
    };
    exports.SumAggregator = SumAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/index.js
var require_aggregator = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_Drop(), exports);
    __exportStar(require_Histogram(), exports);
    __exportStar(require_ExponentialHistogram(), exports);
    __exportStar(require_LastValue(), exports);
    __exportStar(require_Sum(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Aggregation.js
var require_Aggregation = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Aggregation.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DefaultAggregation = exports.ExponentialHistogramAggregation = exports.ExplicitBucketHistogramAggregation = exports.HistogramAggregation = exports.LastValueAggregation = exports.SumAggregation = exports.DropAggregation = exports.Aggregation = void 0;
    var api = require_src(), aggregator_1 = require_aggregator(), InstrumentDescriptor_1 = require_InstrumentDescriptor(), Aggregation = class {
      static Drop() {
        return DROP_AGGREGATION;
      }
      static Sum() {
        return SUM_AGGREGATION;
      }
      static LastValue() {
        return LAST_VALUE_AGGREGATION;
      }
      static Histogram() {
        return HISTOGRAM_AGGREGATION;
      }
      static ExponentialHistogram() {
        return EXPONENTIAL_HISTOGRAM_AGGREGATION;
      }
      static Default() {
        return DEFAULT_AGGREGATION;
      }
    };
    exports.Aggregation = Aggregation;
    var DropAggregation = class _DropAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _DropAggregation.DEFAULT_INSTANCE;
      }
    };
    exports.DropAggregation = DropAggregation;
    DropAggregation.DEFAULT_INSTANCE = new aggregator_1.DropAggregator();
    var SumAggregation = class _SumAggregation extends Aggregation {
      createAggregator(instrument) {
        switch (instrument.type) {
          case InstrumentDescriptor_1.InstrumentType.COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.HISTOGRAM:
            return _SumAggregation.MONOTONIC_INSTANCE;
          default:
            return _SumAggregation.NON_MONOTONIC_INSTANCE;
        }
      }
    };
    exports.SumAggregation = SumAggregation;
    SumAggregation.MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(!0);
    SumAggregation.NON_MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(!1);
    var LastValueAggregation = class _LastValueAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _LastValueAggregation.DEFAULT_INSTANCE;
      }
    };
    exports.LastValueAggregation = LastValueAggregation;
    LastValueAggregation.DEFAULT_INSTANCE = new aggregator_1.LastValueAggregator();
    var HistogramAggregation = class _HistogramAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _HistogramAggregation.DEFAULT_INSTANCE;
      }
    };
    exports.HistogramAggregation = HistogramAggregation;
    HistogramAggregation.DEFAULT_INSTANCE = new aggregator_1.HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1e3, 2500, 5e3, 7500, 1e4], !0);
    var ExplicitBucketHistogramAggregation2 = class extends Aggregation {
      /**
       * @param boundaries the bucket boundaries of the histogram aggregation
       * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
       */
      constructor(boundaries, _recordMinMax = !0) {
        if (super(), this._recordMinMax = _recordMinMax, boundaries === void 0 || boundaries.length === 0)
          throw new Error("HistogramAggregator should be created with boundaries.");
        boundaries = boundaries.concat(), boundaries = boundaries.sort((a, b) => a - b);
        let minusInfinityIndex = boundaries.lastIndexOf(-1 / 0), infinityIndex = boundaries.indexOf(1 / 0);
        infinityIndex === -1 && (infinityIndex = void 0), this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);
      }
      createAggregator(_instrument) {
        return new aggregator_1.HistogramAggregator(this._boundaries, this._recordMinMax);
      }
    };
    exports.ExplicitBucketHistogramAggregation = ExplicitBucketHistogramAggregation2;
    var ExponentialHistogramAggregation = class extends Aggregation {
      constructor(_maxSize = 160, _recordMinMax = !0) {
        super(), this._maxSize = _maxSize, this._recordMinMax = _recordMinMax;
      }
      createAggregator(_instrument) {
        return new aggregator_1.ExponentialHistogramAggregator(this._maxSize, this._recordMinMax);
      }
    };
    exports.ExponentialHistogramAggregation = ExponentialHistogramAggregation;
    var DefaultAggregation = class extends Aggregation {
      _resolve(instrument) {
        switch (instrument.type) {
          case InstrumentDescriptor_1.InstrumentType.COUNTER:
          case InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
            return SUM_AGGREGATION;
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE:
            return LAST_VALUE_AGGREGATION;
          case InstrumentDescriptor_1.InstrumentType.HISTOGRAM:
            return HISTOGRAM_AGGREGATION;
        }
        return api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`), DROP_AGGREGATION;
      }
      createAggregator(instrument) {
        return this._resolve(instrument).createAggregator(instrument);
      }
    };
    exports.DefaultAggregation = DefaultAggregation;
    var DROP_AGGREGATION = new DropAggregation(), SUM_AGGREGATION = new SumAggregation(), LAST_VALUE_AGGREGATION = new LastValueAggregation(), HISTOGRAM_AGGREGATION = new HistogramAggregation(), EXPONENTIAL_HISTOGRAM_AGGREGATION = new ExponentialHistogramAggregation(), DEFAULT_AGGREGATION = new DefaultAggregation();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationSelector.js
var require_AggregationSelector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationSelector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = exports.DEFAULT_AGGREGATION_SELECTOR = void 0;
    var Aggregation_1 = require_Aggregation(), AggregationTemporality_1 = require_AggregationTemporality(), DEFAULT_AGGREGATION_SELECTOR = (_instrumentType) => Aggregation_1.Aggregation.Default();
    exports.DEFAULT_AGGREGATION_SELECTOR = DEFAULT_AGGREGATION_SELECTOR;
    var DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = (_instrumentType) => AggregationTemporality_1.AggregationTemporality.CUMULATIVE;
    exports.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricReader.js
var require_MetricReader = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricReader.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MetricReader = void 0;
    var api = require_src(), utils_1 = require_utils3(), AggregationSelector_1 = require_AggregationSelector(), MetricReader2 = class {
      constructor(options) {
        var _a, _b, _c;
        this._shutdown = !1, this._aggregationSelector = (_a = options?.aggregationSelector) !== null && _a !== void 0 ? _a : AggregationSelector_1.DEFAULT_AGGREGATION_SELECTOR, this._aggregationTemporalitySelector = (_b = options?.aggregationTemporalitySelector) !== null && _b !== void 0 ? _b : AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR, this._metricProducers = (_c = options?.metricProducers) !== null && _c !== void 0 ? _c : [];
      }
      /**
       * Set the {@link MetricProducer} used by this instance. **This should only be called by the
       * SDK and should be considered internal.**
       *
       * To add additional {@link MetricProducer}s to a {@link MetricReader}, pass them to the
       * constructor as {@link MetricReaderOptions.metricProducers}.
       *
       * @internal
       * @param metricProducer
       */
      setMetricProducer(metricProducer) {
        if (this._sdkMetricProducer)
          throw new Error("MetricReader can not be bound to a MeterProvider again.");
        this._sdkMetricProducer = metricProducer, this.onInitialized();
      }
      /**
       * Select the {@link Aggregation} for the given {@link InstrumentType} for this
       * reader.
       */
      selectAggregation(instrumentType) {
        return this._aggregationSelector(instrumentType);
      }
      /**
       * Select the {@link AggregationTemporality} for the given
       * {@link InstrumentType} for this reader.
       */
      selectAggregationTemporality(instrumentType) {
        return this._aggregationTemporalitySelector(instrumentType);
      }
      /**
       * Handle once the SDK has initialized this {@link MetricReader}
       * Overriding this method is optional.
       */
      onInitialized() {
      }
      /**
       * Collect all metrics from the associated {@link MetricProducer}
       */
      async collect(options) {
        if (this._sdkMetricProducer === void 0)
          throw new Error("MetricReader is not bound to a MetricProducer");
        if (this._shutdown)
          throw new Error("MetricReader is shutdown");
        let [sdkCollectionResults, ...additionalCollectionResults] = await Promise.all([
          this._sdkMetricProducer.collect({
            timeoutMillis: options?.timeoutMillis
          }),
          ...this._metricProducers.map((producer) => producer.collect({
            timeoutMillis: options?.timeoutMillis
          }))
        ]), errors = sdkCollectionResults.errors.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result) => result.errors)), resource = sdkCollectionResults.resourceMetrics.resource, scopeMetrics = sdkCollectionResults.resourceMetrics.scopeMetrics.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result) => result.resourceMetrics.scopeMetrics));
        return {
          resourceMetrics: {
            resource,
            scopeMetrics
          },
          errors
        };
      }
      /**
       * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.
       *
       * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
       * @param options options with timeout.
       */
      async shutdown(options) {
        if (this._shutdown) {
          api.diag.error("Cannot call shutdown twice.");
          return;
        }
        options?.timeoutMillis == null ? await this.onShutdown() : await (0, utils_1.callWithTimeout)(this.onShutdown(), options.timeoutMillis), this._shutdown = !0;
      }
      /**
       * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.
       *
       * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
       * @param options options with timeout.
       */
      async forceFlush(options) {
        if (this._shutdown) {
          api.diag.warn("Cannot forceFlush on already shutdown MetricReader.");
          return;
        }
        if (options?.timeoutMillis == null) {
          await this.onForceFlush();
          return;
        }
        await (0, utils_1.callWithTimeout)(this.onForceFlush(), options.timeoutMillis);
      }
    };
    exports.MetricReader = MetricReader2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/PeriodicExportingMetricReader.js
var require_PeriodicExportingMetricReader = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/PeriodicExportingMetricReader.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.PeriodicExportingMetricReader = void 0;
    var api = require_src(), core_1 = require_src3(), MetricReader_1 = require_MetricReader(), utils_1 = require_utils3(), api_1 = require_src(), PeriodicExportingMetricReader = class extends MetricReader_1.MetricReader {
      constructor(options) {
        var _a, _b, _c, _d;
        if (super({
          aggregationSelector: (_a = options.exporter.selectAggregation) === null || _a === void 0 ? void 0 : _a.bind(options.exporter),
          aggregationTemporalitySelector: (_b = options.exporter.selectAggregationTemporality) === null || _b === void 0 ? void 0 : _b.bind(options.exporter),
          metricProducers: options.metricProducers
        }), options.exportIntervalMillis !== void 0 && options.exportIntervalMillis <= 0)
          throw Error("exportIntervalMillis must be greater than 0");
        if (options.exportTimeoutMillis !== void 0 && options.exportTimeoutMillis <= 0)
          throw Error("exportTimeoutMillis must be greater than 0");
        if (options.exportTimeoutMillis !== void 0 && options.exportIntervalMillis !== void 0 && options.exportIntervalMillis < options.exportTimeoutMillis)
          throw Error("exportIntervalMillis must be greater than or equal to exportTimeoutMillis");
        this._exportInterval = (_c = options.exportIntervalMillis) !== null && _c !== void 0 ? _c : 6e4, this._exportTimeout = (_d = options.exportTimeoutMillis) !== null && _d !== void 0 ? _d : 3e4, this._exporter = options.exporter;
      }
      async _runOnce() {
        try {
          await (0, utils_1.callWithTimeout)(this._doRun(), this._exportTimeout);
        } catch (err) {
          if (err instanceof utils_1.TimeoutError) {
            api.diag.error("Export took longer than %s milliseconds and timed out.", this._exportTimeout);
            return;
          }
          (0, core_1.globalErrorHandler)(err);
        }
      }
      async _doRun() {
        var _a, _b;
        let { resourceMetrics, errors } = await this.collect({
          timeoutMillis: this._exportTimeout
        });
        errors.length > 0 && api.diag.error("PeriodicExportingMetricReader: metrics collection errors", ...errors);
        let doExport = async () => {
          let result = await core_1.internal._export(this._exporter, resourceMetrics);
          if (result.code !== core_1.ExportResultCode.SUCCESS)
            throw new Error(`PeriodicExportingMetricReader: metrics export failed (error ${result.error})`);
        };
        resourceMetrics.resource.asyncAttributesPending ? (_b = (_a = resourceMetrics.resource).waitForAsyncAttributes) === null || _b === void 0 || _b.call(_a).then(doExport, (err) => api_1.diag.debug("Error while resolving async portion of resource: ", err)) : await doExport();
      }
      onInitialized() {
        this._interval = setInterval(() => {
          this._runOnce();
        }, this._exportInterval), (0, core_1.unrefTimer)(this._interval);
      }
      async onForceFlush() {
        await this._runOnce(), await this._exporter.forceFlush();
      }
      async onShutdown() {
        this._interval && clearInterval(this._interval), await this._exporter.shutdown();
      }
    };
    exports.PeriodicExportingMetricReader = PeriodicExportingMetricReader;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/InMemoryMetricExporter.js
var require_InMemoryMetricExporter = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/InMemoryMetricExporter.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.InMemoryMetricExporter = void 0;
    var core_1 = require_src3(), InMemoryMetricExporter = class {
      constructor(aggregationTemporality) {
        this._shutdown = !1, this._metrics = [], this._aggregationTemporality = aggregationTemporality;
      }
      /**
       * @inheritedDoc
       */
      export(metrics, resultCallback) {
        if (this._shutdown) {
          setTimeout(() => resultCallback({ code: core_1.ExportResultCode.FAILED }), 0);
          return;
        }
        this._metrics.push(metrics), setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
      }
      /**
       * Returns all the collected resource metrics
       * @returns ResourceMetrics[]
       */
      getMetrics() {
        return this._metrics;
      }
      forceFlush() {
        return Promise.resolve();
      }
      reset() {
        this._metrics = [];
      }
      selectAggregationTemporality(_instrumentType) {
        return this._aggregationTemporality;
      }
      shutdown() {
        return this._shutdown = !0, Promise.resolve();
      }
    };
    exports.InMemoryMetricExporter = InMemoryMetricExporter;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/ConsoleMetricExporter.js
var require_ConsoleMetricExporter = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/ConsoleMetricExporter.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ConsoleMetricExporter = void 0;
    var core_1 = require_src3(), AggregationSelector_1 = require_AggregationSelector(), ConsoleMetricExporter2 = class _ConsoleMetricExporter {
      constructor(options) {
        var _a;
        this._shutdown = !1, this._temporalitySelector = (_a = options?.temporalitySelector) !== null && _a !== void 0 ? _a : AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
      }
      export(metrics, resultCallback) {
        if (this._shutdown) {
          setImmediate(resultCallback, { code: core_1.ExportResultCode.FAILED });
          return;
        }
        return _ConsoleMetricExporter._sendMetrics(metrics, resultCallback);
      }
      forceFlush() {
        return Promise.resolve();
      }
      selectAggregationTemporality(_instrumentType) {
        return this._temporalitySelector(_instrumentType);
      }
      shutdown() {
        return this._shutdown = !0, Promise.resolve();
      }
      static _sendMetrics(metrics, done) {
        for (let scopeMetrics of metrics.scopeMetrics)
          for (let metric of scopeMetrics.metrics)
            console.dir({
              descriptor: metric.descriptor,
              dataPointType: metric.dataPointType,
              dataPoints: metric.dataPoints
            });
        done({ code: core_1.ExportResultCode.SUCCESS });
      }
    };
    exports.ConsoleMetricExporter = ConsoleMetricExporter2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js
var require_default_service_name = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.defaultServiceName = void 0;
    function defaultServiceName() {
      return `unknown_service:${process.argv0}`;
    }
    exports.defaultServiceName = defaultServiceName;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/utils.js
var require_utils5 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.normalizeType = exports.normalizeArch = void 0;
    var normalizeArch = (nodeArchString) => {
      switch (nodeArchString) {
        case "arm":
          return "arm32";
        case "ppc":
          return "ppc32";
        case "x64":
          return "amd64";
        default:
          return nodeArchString;
      }
    };
    exports.normalizeArch = normalizeArch;
    var normalizeType = (nodePlatform) => {
      switch (nodePlatform) {
        case "sunos":
          return "solaris";
        case "win32":
          return "windows";
        default:
          return nodePlatform;
      }
    };
    exports.normalizeType = normalizeType;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/execAsync.js
var require_execAsync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/execAsync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.execAsync = void 0;
    var child_process = __require("child_process"), util = __require("util");
    exports.execAsync = util.promisify(child_process.exec);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-darwin.js
var require_getMachineId_darwin = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-darwin.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var execAsync_1 = require_execAsync(), api_1 = require_src();
    async function getMachineId() {
      try {
        let idLine = (await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"')).stdout.split(`
`).find((line) => line.includes("IOPlatformUUID"));
        if (!idLine)
          return "";
        let parts = idLine.split('" = "');
        if (parts.length === 2)
          return parts[1].slice(0, -1);
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-linux.js
var require_getMachineId_linux = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-linux.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var fs_1 = __require("fs"), api_1 = require_src();
    async function getMachineId() {
      let paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
      for (let path of paths)
        try {
          return (await fs_1.promises.readFile(path, { encoding: "utf8" })).trim();
        } catch (e) {
          api_1.diag.debug(`error reading machine id: ${e}`);
        }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-bsd.js
var require_getMachineId_bsd = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-bsd.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var fs_1 = __require("fs"), execAsync_1 = require_execAsync(), api_1 = require_src();
    async function getMachineId() {
      try {
        return (await fs_1.promises.readFile("/etc/hostid", { encoding: "utf8" })).trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      try {
        return (await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid")).stdout.trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-win.js
var require_getMachineId_win = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-win.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var process2 = __require("process"), execAsync_1 = require_execAsync(), api_1 = require_src();
    async function getMachineId() {
      let args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid", command = "%windir%\\System32\\REG.exe";
      process2.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process2.env && (command = "%windir%\\sysnative\\cmd.exe /c " + command);
      try {
        let parts = (await (0, execAsync_1.execAsync)(`${command} ${args}`)).stdout.split("REG_SZ");
        if (parts.length === 2)
          return parts[1].trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-unsupported.js
var require_getMachineId_unsupported = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-unsupported.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var api_1 = require_src();
    async function getMachineId() {
      return api_1.diag.debug("could not read machine-id: unsupported platform"), "";
    }
    exports.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId.js
var require_getMachineId = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var process2 = __require("process"), getMachineId;
    exports.getMachineId = getMachineId;
    switch (process2.platform) {
      case "darwin":
        exports.getMachineId = getMachineId = require_getMachineId_darwin().getMachineId;
        break;
      case "linux":
        exports.getMachineId = getMachineId = require_getMachineId_linux().getMachineId;
        break;
      case "freebsd":
        exports.getMachineId = getMachineId = require_getMachineId_bsd().getMachineId;
        break;
      case "win32":
        exports.getMachineId = getMachineId = require_getMachineId_win().getMachineId;
        break;
      default:
        exports.getMachineId = getMachineId = require_getMachineId_unsupported().getMachineId;
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/HostDetectorSync.js
var require_HostDetectorSync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/HostDetectorSync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.hostDetectorSync = void 0;
    var semantic_conventions_1 = require_src2(), Resource_1 = require_Resource(), os_1 = __require("os"), utils_1 = require_utils5(), getMachineId_1 = require_getMachineId(), HostDetectorSync = class {
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.HOST_NAME]: (0, os_1.hostname)(),
          [semantic_conventions_1.SemanticResourceAttributes.HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)())
        };
        return new Resource_1.Resource(attributes, this._getAsyncAttributes());
      }
      _getAsyncAttributes() {
        return (0, getMachineId_1.getMachineId)().then((machineId) => {
          let attributes = {};
          return machineId && (attributes[semantic_conventions_1.SemanticResourceAttributes.HOST_ID] = machineId), attributes;
        });
      }
    };
    exports.hostDetectorSync = new HostDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/HostDetector.js
var require_HostDetector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/HostDetector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.hostDetector = void 0;
    var HostDetectorSync_1 = require_HostDetectorSync(), HostDetector = class {
      detect(_config) {
        return Promise.resolve(HostDetectorSync_1.hostDetectorSync.detect(_config));
      }
    };
    exports.hostDetector = new HostDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/OSDetectorSync.js
var require_OSDetectorSync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/OSDetectorSync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.osDetectorSync = void 0;
    var semantic_conventions_1 = require_src2(), Resource_1 = require_Resource(), os_1 = __require("os"), utils_1 = require_utils5(), OSDetectorSync = class {
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
          [semantic_conventions_1.SemanticResourceAttributes.OS_VERSION]: (0, os_1.release)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports.osDetectorSync = new OSDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/OSDetector.js
var require_OSDetector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/OSDetector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.osDetector = void 0;
    var OSDetectorSync_1 = require_OSDetectorSync(), OSDetector = class {
      detect(_config) {
        return Promise.resolve(OSDetectorSync_1.osDetectorSync.detect(_config));
      }
    };
    exports.osDetector = new OSDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetectorSync.js
var require_ProcessDetectorSync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetectorSync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.processDetectorSync = void 0;
    var api_1 = require_src(), semantic_conventions_1 = require_src2(), Resource_1 = require_Resource(), os = __require("os"), ProcessDetectorSync = class {
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_PID]: process.pid,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME]: process.title,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH]: process.execPath,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_COMMAND_ARGS]: [
            process.argv[0],
            ...process.execArgv,
            ...process.argv.slice(1)
          ],
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION]: process.versions.node,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "nodejs",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
        };
        process.argv.length > 1 && (attributes[semantic_conventions_1.SemanticResourceAttributes.PROCESS_COMMAND] = process.argv[1]);
        try {
          let userInfo = os.userInfo();
          attributes[semantic_conventions_1.SemanticResourceAttributes.PROCESS_OWNER] = userInfo.username;
        } catch (e) {
          api_1.diag.debug(`error obtaining process owner: ${e}`);
        }
        return new Resource_1.Resource(attributes);
      }
    };
    exports.processDetectorSync = new ProcessDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetector.js
var require_ProcessDetector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.processDetector = void 0;
    var ProcessDetectorSync_1 = require_ProcessDetectorSync(), ProcessDetector = class {
      detect(config) {
        return Promise.resolve(ProcessDetectorSync_1.processDetectorSync.detect(config));
      }
    };
    exports.processDetector = new ProcessDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/index.js
var require_node3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_default_service_name(), exports);
    __exportStar(require_HostDetector(), exports);
    __exportStar(require_OSDetector(), exports);
    __exportStar(require_HostDetectorSync(), exports);
    __exportStar(require_OSDetectorSync(), exports);
    __exportStar(require_ProcessDetector(), exports);
    __exportStar(require_ProcessDetectorSync(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/index.js
var require_platform3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_node3(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/Resource.js
var require_Resource = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/Resource.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Resource = void 0;
    var api_1 = require_src(), semantic_conventions_1 = require_src2(), core_1 = require_src3(), platform_1 = require_platform3(), Resource2 = class _Resource {
      constructor(attributes, asyncAttributesPromise) {
        var _a;
        this._attributes = attributes, this.asyncAttributesPending = asyncAttributesPromise != null, this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {}, this._asyncAttributesPromise = asyncAttributesPromise?.then((asyncAttributes) => (this._attributes = Object.assign({}, this._attributes, asyncAttributes), this.asyncAttributesPending = !1, asyncAttributes), (err) => (api_1.diag.debug("a resource's async attributes promise rejected: %s", err), this.asyncAttributesPending = !1, {}));
      }
      /**
       * Returns an empty Resource
       */
      static empty() {
        return _Resource.EMPTY;
      }
      /**
       * Returns a Resource that identifies the SDK in use.
       */
      static default() {
        return new _Resource({
          [semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE],
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME],
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]
        });
      }
      get attributes() {
        var _a;
        return this.asyncAttributesPending && api_1.diag.error("Accessing resource attributes before async attributes settled"), (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
      }
      /**
       * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
       * this Resource's attributes. This is useful in exporters to block until resource detection
       * has finished.
       */
      async waitForAsyncAttributes() {
        this.asyncAttributesPending && await this._asyncAttributesPromise;
      }
      /**
       * Returns a new, merged {@link Resource} by merging the current Resource
       * with the other Resource. In case of a collision, other Resource takes
       * precedence.
       *
       * @param other the Resource that will be merged with this.
       * @returns the newly merged Resource.
       */
      merge(other) {
        var _a;
        if (!other)
          return this;
        let mergedSyncAttributes = Object.assign(Object.assign({}, this._syncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise)
          return new _Resource(mergedSyncAttributes);
        let mergedAttributesPromise = Promise.all([
          this._asyncAttributesPromise,
          other._asyncAttributesPromise
        ]).then(([thisAsyncAttributes, otherAsyncAttributes]) => {
          var _a2;
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this._syncAttributes), thisAsyncAttributes), (_a2 = other._syncAttributes) !== null && _a2 !== void 0 ? _a2 : other.attributes), otherAsyncAttributes);
        });
        return new _Resource(mergedSyncAttributes, mergedAttributesPromise);
      }
    };
    exports.Resource = Resource2;
    Resource2.EMPTY = new Resource2({});
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/IResource.js
var require_IResource = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/IResource.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/types.js
var require_types5 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/config.js
var require_config = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/config.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js
var require_BrowserDetector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.browserDetector = void 0;
    var __1 = require_src4(), BrowserDetector = class {
      detect(config) {
        return Promise.resolve(__1.browserDetectorSync.detect(config));
      }
    };
    exports.browserDetector = new BrowserDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js
var require_EnvDetectorSync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.envDetectorSync = void 0;
    var api_1 = require_src(), core_1 = require_src3(), semantic_conventions_1 = require_src2(), Resource_1 = require_Resource(), EnvDetectorSync = class {
      constructor() {
        this._MAX_LENGTH = 255, this._COMMA_SEPARATOR = ",", this._LABEL_KEY_VALUE_SPLITTER = "=", this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.", this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
      }
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(_config) {
        let attributes = {}, env = (0, core_1.getEnv)(), rawAttributes = env.OTEL_RESOURCE_ATTRIBUTES, serviceName = env.OTEL_SERVICE_NAME;
        if (rawAttributes)
          try {
            let parsedAttributes = this._parseResourceAttributes(rawAttributes);
            Object.assign(attributes, parsedAttributes);
          } catch (e) {
            api_1.diag.debug(`EnvDetector failed: ${e.message}`);
          }
        return serviceName && (attributes[semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME] = serviceName), new Resource_1.Resource(attributes);
      }
      /**
       * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment
       * variable.
       *
       * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing
       * the source in more detail, e.g. key1=val1,key2=val2. Domain names and
       * paths are accepted as attribute keys. Values may be quoted or unquoted in
       * general. If a value contains whitespaces, =, or " characters, it must
       * always be quoted.
       *
       * @param rawEnvAttributes The resource attributes as a comma-seperated list
       * of key/value pairs.
       * @returns The sanitized resource attributes.
       */
      _parseResourceAttributes(rawEnvAttributes) {
        if (!rawEnvAttributes)
          return {};
        let attributes = {}, rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        for (let rawAttribute of rawAttributes) {
          let keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
          if (keyValuePair.length !== 2)
            continue;
          let [key, value] = keyValuePair;
          if (key = key.trim(), value = value.trim().split(/^"|"$/).join(""), !this._isValidAndNotEmpty(key))
            throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
          if (!this._isValid(value))
            throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
          attributes[key] = decodeURIComponent(value);
        }
        return attributes;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid.
       */
      _isValid(name) {
        return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);
      }
      // https://www.w3.org/TR/baggage/#definition
      _isBaggageOctetString(str) {
        for (let i = 0; i < str.length; i++) {
          let ch = str.charCodeAt(i);
          if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126)
            return !1;
        }
        return !0;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length greater than 0 and not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid and not empty.
       */
      _isValidAndNotEmpty(str) {
        return str.length > 0 && this._isValid(str);
      }
    };
    exports.envDetectorSync = new EnvDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js
var require_EnvDetector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.envDetector = void 0;
    var EnvDetectorSync_1 = require_EnvDetectorSync(), EnvDetector = class {
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(config) {
        return Promise.resolve(EnvDetectorSync_1.envDetectorSync.detect(config));
      }
    };
    exports.envDetector = new EnvDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js
var require_BrowserDetectorSync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.browserDetectorSync = void 0;
    var semantic_conventions_1 = require_src2(), __1 = require_src4(), api_1 = require_src(), BrowserDetectorSync = class {
      detect(config) {
        if (!(typeof navigator < "u"))
          return __1.Resource.empty();
        let browserResource = {
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "browser",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION]: "Web Browser",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION]: navigator.userAgent
        };
        return this._getResourceAttributes(browserResource, config);
      }
      /**
       * Validates process resource attribute map from process variables
       *
       * @param browserResource The un-sanitized resource attributes from process as key/value pairs.
       * @param config: Config
       * @returns The sanitized resource attributes.
       */
      _getResourceAttributes(browserResource, _config) {
        return browserResource[semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === "" ? (api_1.diag.debug("BrowserDetector failed: Unable to find required browser resources. "), __1.Resource.empty()) : new __1.Resource(Object.assign({}, browserResource));
      }
    };
    exports.browserDetectorSync = new BrowserDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/index.js
var require_detectors = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_BrowserDetector(), exports);
    __exportStar(require_EnvDetector(), exports);
    __exportStar(require_BrowserDetectorSync(), exports);
    __exportStar(require_EnvDetectorSync(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/utils.js
var require_utils6 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isPromiseLike = void 0;
    var isPromiseLike = (val) => val !== null && typeof val == "object" && typeof val.then == "function";
    exports.isPromiseLike = isPromiseLike;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detect-resources.js
var require_detect_resources = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detect-resources.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.detectResourcesSync = exports.detectResources = void 0;
    var Resource_1 = require_Resource(), api_1 = require_src(), utils_1 = require_utils6(), detectResources = async (config = {}) => {
      let resources = await Promise.all((config.detectors || []).map(async (d) => {
        try {
          let resource = await d.detect(config);
          return api_1.diag.debug(`${d.constructor.name} found resource.`, resource), resource;
        } catch (e) {
          return api_1.diag.debug(`${d.constructor.name} failed: ${e.message}`), Resource_1.Resource.empty();
        }
      }));
      return logResources(resources), resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
    };
    exports.detectResources = detectResources;
    var detectResourcesSync = (config = {}) => {
      var _a;
      let resources = ((_a = config.detectors) !== null && _a !== void 0 ? _a : []).map((d) => {
        try {
          let resourceOrPromise = d.detect(config), resource;
          if ((0, utils_1.isPromiseLike)(resourceOrPromise)) {
            let createPromise = async () => (await resourceOrPromise).attributes;
            resource = new Resource_1.Resource({}, createPromise());
          } else
            resource = resourceOrPromise;
          return resource.waitForAsyncAttributes ? resource.waitForAsyncAttributes().then(() => api_1.diag.debug(`${d.constructor.name} found resource.`, resource)) : api_1.diag.debug(`${d.constructor.name} found resource.`, resource), resource;
        } catch (e) {
          return api_1.diag.error(`${d.constructor.name} failed: ${e.message}`), Resource_1.Resource.empty();
        }
      }), mergedResources = resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
      return mergedResources.waitForAsyncAttributes && mergedResources.waitForAsyncAttributes().then(() => {
        logResources(resources);
      }), mergedResources;
    };
    exports.detectResourcesSync = detectResourcesSync;
    var logResources = (resources) => {
      resources.forEach((resource) => {
        if (Object.keys(resource.attributes).length > 0) {
          let resourceDebugString = JSON.stringify(resource.attributes, null, 4);
          api_1.diag.verbose(resourceDebugString);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/index.js
var require_src4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_Resource(), exports);
    __exportStar(require_IResource(), exports);
    __exportStar(require_platform3(), exports);
    __exportStar(require_types5(), exports);
    __exportStar(require_config(), exports);
    __exportStar(require_detectors(), exports);
    __exportStar(require_detect_resources(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/ViewRegistry.js
var require_ViewRegistry = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/ViewRegistry.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ViewRegistry = void 0;
    var ViewRegistry = class {
      constructor() {
        this._registeredViews = [];
      }
      addView(view) {
        this._registeredViews.push(view);
      }
      findViews(instrument, meter) {
        return this._registeredViews.filter((registeredView) => this._matchInstrument(registeredView.instrumentSelector, instrument) && this._matchMeter(registeredView.meterSelector, meter));
      }
      _matchInstrument(selector, instrument) {
        return (selector.getType() === void 0 || instrument.type === selector.getType()) && selector.getNameFilter().match(instrument.name) && selector.getUnitFilter().match(instrument.unit);
      }
      _matchMeter(selector, meter) {
        return selector.getNameFilter().match(meter.name) && (meter.version === void 0 || selector.getVersionFilter().match(meter.version)) && (meter.schemaUrl === void 0 || selector.getSchemaUrlFilter().match(meter.schemaUrl));
      }
    };
    exports.ViewRegistry = ViewRegistry;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/Instruments.js
var require_Instruments = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/Instruments.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isObservableInstrument = exports.ObservableUpDownCounterInstrument = exports.ObservableGaugeInstrument = exports.ObservableCounterInstrument = exports.ObservableInstrument = exports.HistogramInstrument = exports.CounterInstrument = exports.UpDownCounterInstrument = exports.SyncInstrument = void 0;
    var api_1 = require_src(), core_1 = require_src3(), SyncInstrument = class {
      constructor(_writableMetricStorage, _descriptor) {
        this._writableMetricStorage = _writableMetricStorage, this._descriptor = _descriptor;
      }
      _record(value, attributes = {}, context = api_1.context.active()) {
        if (typeof value != "number") {
          api_1.diag.warn(`non-number value provided to metric ${this._descriptor.name}: ${value}`);
          return;
        }
        this._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value) && (api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`), value = Math.trunc(value), !Number.isInteger(value)) || this._writableMetricStorage.record(value, attributes, context, (0, core_1.millisToHrTime)(Date.now()));
      }
    };
    exports.SyncInstrument = SyncInstrument;
    var UpDownCounterInstrument = class extends SyncInstrument {
      /**
       * Increment value of counter by the input. Inputs may be negative.
       */
      add(value, attributes, ctx) {
        this._record(value, attributes, ctx);
      }
    };
    exports.UpDownCounterInstrument = UpDownCounterInstrument;
    var CounterInstrument = class extends SyncInstrument {
      /**
       * Increment value of counter by the input. Inputs may not be negative.
       */
      add(value, attributes, ctx) {
        if (value < 0) {
          api_1.diag.warn(`negative value provided to counter ${this._descriptor.name}: ${value}`);
          return;
        }
        this._record(value, attributes, ctx);
      }
    };
    exports.CounterInstrument = CounterInstrument;
    var HistogramInstrument = class extends SyncInstrument {
      /**
       * Records a measurement. Value of the measurement must not be negative.
       */
      record(value, attributes, ctx) {
        if (value < 0) {
          api_1.diag.warn(`negative value provided to histogram ${this._descriptor.name}: ${value}`);
          return;
        }
        this._record(value, attributes, ctx);
      }
    };
    exports.HistogramInstrument = HistogramInstrument;
    var ObservableInstrument = class {
      constructor(descriptor, metricStorages, _observableRegistry) {
        this._observableRegistry = _observableRegistry, this._descriptor = descriptor, this._metricStorages = metricStorages;
      }
      /**
       * @see {Observable.addCallback}
       */
      addCallback(callback) {
        this._observableRegistry.addCallback(callback, this);
      }
      /**
       * @see {Observable.removeCallback}
       */
      removeCallback(callback) {
        this._observableRegistry.removeCallback(callback, this);
      }
    };
    exports.ObservableInstrument = ObservableInstrument;
    var ObservableCounterInstrument = class extends ObservableInstrument {
    };
    exports.ObservableCounterInstrument = ObservableCounterInstrument;
    var ObservableGaugeInstrument = class extends ObservableInstrument {
    };
    exports.ObservableGaugeInstrument = ObservableGaugeInstrument;
    var ObservableUpDownCounterInstrument = class extends ObservableInstrument {
    };
    exports.ObservableUpDownCounterInstrument = ObservableUpDownCounterInstrument;
    function isObservableInstrument(it) {
      return it instanceof ObservableInstrument;
    }
    exports.isObservableInstrument = isObservableInstrument;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/Meter.js
var require_Meter = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/Meter.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Meter = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor(), Instruments_1 = require_Instruments(), Meter = class {
      constructor(_meterSharedState) {
        this._meterSharedState = _meterSharedState;
      }
      /**
       * Create a {@link Histogram} instrument.
       */
      createHistogram(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.HISTOGRAM, options), storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.HistogramInstrument(storage, descriptor);
      }
      /**
       * Create a {@link Counter} instrument.
       */
      createCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.COUNTER, options), storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.CounterInstrument(storage, descriptor);
      }
      /**
       * Create a {@link UpDownCounter} instrument.
       */
      createUpDownCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER, options), storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.UpDownCounterInstrument(storage, descriptor);
      }
      /**
       * Create a {@link ObservableGauge} instrument.
       */
      createObservableGauge(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE, options), storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableGaugeInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * Create a {@link ObservableCounter} instrument.
       */
      createObservableCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER, options), storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * Create a {@link ObservableUpDownCounter} instrument.
       */
      createObservableUpDownCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER, options), storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableUpDownCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(callback, observables) {
        this._meterSharedState.observableRegistry.addBatchCallback(callback, observables);
      }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(callback, observables) {
        this._meterSharedState.observableRegistry.removeBatchCallback(callback, observables);
      }
    };
    exports.Meter = Meter;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorage.js
var require_MetricStorage = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorage.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MetricStorage = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor(), MetricStorage = class {
      constructor(_instrumentDescriptor) {
        this._instrumentDescriptor = _instrumentDescriptor;
      }
      getInstrumentDescriptor() {
        return this._instrumentDescriptor;
      }
      updateDescription(description) {
        this._instrumentDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(this._instrumentDescriptor.name, this._instrumentDescriptor.type, {
          description,
          valueType: this._instrumentDescriptor.valueType,
          unit: this._instrumentDescriptor.unit
        });
      }
    };
    exports.MetricStorage = MetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/HashMap.js
var require_HashMap = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/HashMap.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AttributeHashMap = exports.HashMap = void 0;
    var utils_1 = require_utils3(), HashMap = class {
      constructor(_hash) {
        this._hash = _hash, this._valueMap = /* @__PURE__ */ new Map(), this._keyMap = /* @__PURE__ */ new Map();
      }
      get(key, hashCode) {
        return hashCode ?? (hashCode = this._hash(key)), this._valueMap.get(hashCode);
      }
      getOrDefault(key, defaultFactory) {
        let hash = this._hash(key);
        if (this._valueMap.has(hash))
          return this._valueMap.get(hash);
        let val = defaultFactory();
        return this._keyMap.has(hash) || this._keyMap.set(hash, key), this._valueMap.set(hash, val), val;
      }
      set(key, value, hashCode) {
        hashCode ?? (hashCode = this._hash(key)), this._keyMap.has(hashCode) || this._keyMap.set(hashCode, key), this._valueMap.set(hashCode, value);
      }
      has(key, hashCode) {
        return hashCode ?? (hashCode = this._hash(key)), this._valueMap.has(hashCode);
      }
      *keys() {
        let keyIterator = this._keyMap.entries(), next = keyIterator.next();
        for (; next.done !== !0; )
          yield [next.value[1], next.value[0]], next = keyIterator.next();
      }
      *entries() {
        let valueIterator = this._valueMap.entries(), next = valueIterator.next();
        for (; next.done !== !0; )
          yield [this._keyMap.get(next.value[0]), next.value[1], next.value[0]], next = valueIterator.next();
      }
      get size() {
        return this._valueMap.size;
      }
    };
    exports.HashMap = HashMap;
    var AttributeHashMap = class extends HashMap {
      constructor() {
        super(utils_1.hashAttributes);
      }
    };
    exports.AttributeHashMap = AttributeHashMap;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/DeltaMetricProcessor.js
var require_DeltaMetricProcessor = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/DeltaMetricProcessor.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DeltaMetricProcessor = void 0;
    var HashMap_1 = require_HashMap(), DeltaMetricProcessor = class {
      constructor(_aggregator) {
        this._aggregator = _aggregator, this._activeCollectionStorage = new HashMap_1.AttributeHashMap(), this._cumulativeMemoStorage = new HashMap_1.AttributeHashMap();
      }
      record(value, attributes, _context, collectionTime) {
        let accumulation = this._activeCollectionStorage.getOrDefault(attributes, () => this._aggregator.createAccumulation(collectionTime));
        accumulation?.record(value);
      }
      batchCumulate(measurements, collectionTime) {
        Array.from(measurements.entries()).forEach(([attributes, value, hashCode]) => {
          let accumulation = this._aggregator.createAccumulation(collectionTime);
          accumulation?.record(value);
          let delta = accumulation;
          if (this._cumulativeMemoStorage.has(attributes, hashCode)) {
            let previous = this._cumulativeMemoStorage.get(attributes, hashCode);
            delta = this._aggregator.diff(previous, accumulation);
          }
          if (this._activeCollectionStorage.has(attributes, hashCode)) {
            let active = this._activeCollectionStorage.get(attributes, hashCode);
            delta = this._aggregator.merge(active, delta);
          }
          this._cumulativeMemoStorage.set(attributes, accumulation, hashCode), this._activeCollectionStorage.set(attributes, delta, hashCode);
        });
      }
      /**
       * Returns a collection of delta metrics. Start time is the when first
       * time event collected.
       */
      collect() {
        let unreportedDelta = this._activeCollectionStorage;
        return this._activeCollectionStorage = new HashMap_1.AttributeHashMap(), unreportedDelta;
      }
    };
    exports.DeltaMetricProcessor = DeltaMetricProcessor;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/TemporalMetricProcessor.js
var require_TemporalMetricProcessor = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/TemporalMetricProcessor.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TemporalMetricProcessor = void 0;
    var AggregationTemporality_1 = require_AggregationTemporality(), HashMap_1 = require_HashMap(), TemporalMetricProcessor = class _TemporalMetricProcessor {
      constructor(_aggregator, collectorHandles) {
        this._aggregator = _aggregator, this._unreportedAccumulations = /* @__PURE__ */ new Map(), this._reportHistory = /* @__PURE__ */ new Map(), collectorHandles.forEach((handle) => {
          this._unreportedAccumulations.set(handle, []);
        });
      }
      /**
       * Builds the {@link MetricData} streams to report against a specific MetricCollector.
       * @param collector The information of the MetricCollector.
       * @param collectors The registered collectors.
       * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.
       * @param currentAccumulations The current accumulation of metric data from instruments.
       * @param collectionTime The current collection timestamp.
       * @returns The {@link MetricData} points or `null`.
       */
      buildMetrics(collector, instrumentDescriptor, currentAccumulations, collectionTime) {
        this._stashAccumulations(currentAccumulations);
        let unreportedAccumulations = this._getMergedUnreportedAccumulations(collector), result = unreportedAccumulations, aggregationTemporality;
        if (this._reportHistory.has(collector)) {
          let last = this._reportHistory.get(collector), lastCollectionTime = last.collectionTime;
          aggregationTemporality = last.aggregationTemporality, aggregationTemporality === AggregationTemporality_1.AggregationTemporality.CUMULATIVE ? result = _TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator) : result = _TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);
        } else
          aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);
        this._reportHistory.set(collector, {
          accumulations: result,
          collectionTime,
          aggregationTemporality
        });
        let accumulationRecords = AttributesMapToAccumulationRecords(result);
        if (accumulationRecords.length !== 0)
          return this._aggregator.toMetricData(
            instrumentDescriptor,
            aggregationTemporality,
            accumulationRecords,
            /* endTime */
            collectionTime
          );
      }
      _stashAccumulations(currentAccumulation) {
        let registeredCollectors = this._unreportedAccumulations.keys();
        for (let collector of registeredCollectors) {
          let stash = this._unreportedAccumulations.get(collector);
          stash === void 0 && (stash = [], this._unreportedAccumulations.set(collector, stash)), stash.push(currentAccumulation);
        }
      }
      _getMergedUnreportedAccumulations(collector) {
        let result = new HashMap_1.AttributeHashMap(), unreportedList = this._unreportedAccumulations.get(collector);
        if (this._unreportedAccumulations.set(collector, []), unreportedList === void 0)
          return result;
        for (let it of unreportedList)
          result = _TemporalMetricProcessor.merge(result, it, this._aggregator);
        return result;
      }
      static merge(last, current, aggregator) {
        let result = last, iterator = current.entries(), next = iterator.next();
        for (; next.done !== !0; ) {
          let [key, record, hash] = next.value;
          if (last.has(key, hash)) {
            let lastAccumulation = last.get(key, hash), accumulation = aggregator.merge(lastAccumulation, record);
            result.set(key, accumulation, hash);
          } else
            result.set(key, record, hash);
          next = iterator.next();
        }
        return result;
      }
      /**
       * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves
       * the new stream to be the initial observation time unchanged.
       */
      static calibrateStartTime(last, current, lastCollectionTime) {
        for (let [key, hash] of last.keys()) {
          let currentAccumulation = current.get(key, hash);
          currentAccumulation?.setStartTime(lastCollectionTime);
        }
        return current;
      }
    };
    exports.TemporalMetricProcessor = TemporalMetricProcessor;
    function AttributesMapToAccumulationRecords(map) {
      return Array.from(map.entries());
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/AsyncMetricStorage.js
var require_AsyncMetricStorage = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/AsyncMetricStorage.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AsyncMetricStorage = void 0;
    var MetricStorage_1 = require_MetricStorage(), DeltaMetricProcessor_1 = require_DeltaMetricProcessor(), TemporalMetricProcessor_1 = require_TemporalMetricProcessor(), HashMap_1 = require_HashMap(), AsyncMetricStorage = class extends MetricStorage_1.MetricStorage {
      constructor(_instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles) {
        super(_instrumentDescriptor), this._attributesProcessor = _attributesProcessor, this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator), this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator, collectorHandles);
      }
      record(measurements, observationTime) {
        let processed = new HashMap_1.AttributeHashMap();
        Array.from(measurements.entries()).forEach(([attributes, value]) => {
          processed.set(this._attributesProcessor.process(attributes), value);
        }), this._deltaMetricStorage.batchCumulate(processed, observationTime);
      }
      /**
       * Collects the metrics from this storage. The ObservableCallback is invoked
       * during the collection.
       *
       * Note: This is a stateful operation and may reset any interval-related
       * state for the MetricCollector.
       */
      collect(collector, collectionTime) {
        let accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
      }
    };
    exports.AsyncMetricStorage = AsyncMetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/RegistrationConflicts.js
var require_RegistrationConflicts = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/RegistrationConflicts.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getConflictResolutionRecipe = exports.getDescriptionResolutionRecipe = exports.getTypeConflictResolutionRecipe = exports.getUnitConflictResolutionRecipe = exports.getValueTypeConflictResolutionRecipe = exports.getIncompatibilityDetails = void 0;
    function getIncompatibilityDetails(existing, otherDescriptor) {
      let incompatibility = "";
      return existing.unit !== otherDescriptor.unit && (incompatibility += `	- Unit '${existing.unit}' does not match '${otherDescriptor.unit}'
`), existing.type !== otherDescriptor.type && (incompatibility += `	- Type '${existing.type}' does not match '${otherDescriptor.type}'
`), existing.valueType !== otherDescriptor.valueType && (incompatibility += `	- Value Type '${existing.valueType}' does not match '${otherDescriptor.valueType}'
`), existing.description !== otherDescriptor.description && (incompatibility += `	- Description '${existing.description}' does not match '${otherDescriptor.description}'
`), incompatibility;
    }
    exports.getIncompatibilityDetails = getIncompatibilityDetails;
    function getValueTypeConflictResolutionRecipe(existing, otherDescriptor) {
      return `	- use valueType '${existing.valueType}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
    }
    exports.getValueTypeConflictResolutionRecipe = getValueTypeConflictResolutionRecipe;
    function getUnitConflictResolutionRecipe(existing, otherDescriptor) {
      return `	- use unit '${existing.unit}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
    }
    exports.getUnitConflictResolutionRecipe = getUnitConflictResolutionRecipe;
    function getTypeConflictResolutionRecipe(existing, otherDescriptor) {
      let selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
      }, selectorString = JSON.stringify(selector);
      return `	- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'`;
    }
    exports.getTypeConflictResolutionRecipe = getTypeConflictResolutionRecipe;
    function getDescriptionResolutionRecipe(existing, otherDescriptor) {
      let selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
      }, selectorString = JSON.stringify(selector);
      return `	- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'
    	- OR - create a new view with the name ${existing.name} and description '${existing.description}' and InstrumentSelector ${selectorString}
    	- OR - create a new view with the name ${otherDescriptor.name} and description '${existing.description}' and InstrumentSelector ${selectorString}`;
    }
    exports.getDescriptionResolutionRecipe = getDescriptionResolutionRecipe;
    function getConflictResolutionRecipe(existing, otherDescriptor) {
      return existing.valueType !== otherDescriptor.valueType ? getValueTypeConflictResolutionRecipe(existing, otherDescriptor) : existing.unit !== otherDescriptor.unit ? getUnitConflictResolutionRecipe(existing, otherDescriptor) : existing.type !== otherDescriptor.type ? getTypeConflictResolutionRecipe(existing, otherDescriptor) : existing.description !== otherDescriptor.description ? getDescriptionResolutionRecipe(existing, otherDescriptor) : "";
    }
    exports.getConflictResolutionRecipe = getConflictResolutionRecipe;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorageRegistry.js
var require_MetricStorageRegistry = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorageRegistry.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MetricStorageRegistry = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor(), api = require_src(), RegistrationConflicts_1 = require_RegistrationConflicts(), MetricStorageRegistry = class _MetricStorageRegistry {
      constructor() {
        this._sharedRegistry = /* @__PURE__ */ new Map(), this._perCollectorRegistry = /* @__PURE__ */ new Map();
      }
      static create() {
        return new _MetricStorageRegistry();
      }
      getStorages(collector) {
        let storages = [];
        for (let metricStorages of this._sharedRegistry.values())
          storages = storages.concat(metricStorages);
        let perCollectorStorages = this._perCollectorRegistry.get(collector);
        if (perCollectorStorages != null)
          for (let metricStorages of perCollectorStorages.values())
            storages = storages.concat(metricStorages);
        return storages;
      }
      register(storage) {
        this._registerStorage(storage, this._sharedRegistry);
      }
      registerForCollector(collector, storage) {
        let storageMap = this._perCollectorRegistry.get(collector);
        storageMap == null && (storageMap = /* @__PURE__ */ new Map(), this._perCollectorRegistry.set(collector, storageMap)), this._registerStorage(storage, storageMap);
      }
      findOrUpdateCompatibleStorage(expectedDescriptor) {
        let storages = this._sharedRegistry.get(expectedDescriptor.name);
        return storages === void 0 ? null : this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
      }
      findOrUpdateCompatibleCollectorStorage(collector, expectedDescriptor) {
        let storageMap = this._perCollectorRegistry.get(collector);
        if (storageMap === void 0)
          return null;
        let storages = storageMap.get(expectedDescriptor.name);
        return storages === void 0 ? null : this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
      }
      _registerStorage(storage, storageMap) {
        let descriptor = storage.getInstrumentDescriptor(), storages = storageMap.get(descriptor.name);
        if (storages === void 0) {
          storageMap.set(descriptor.name, [storage]);
          return;
        }
        storages.push(storage);
      }
      _findOrUpdateCompatibleStorage(expectedDescriptor, existingStorages) {
        let compatibleStorage = null;
        for (let existingStorage of existingStorages) {
          let existingDescriptor = existingStorage.getInstrumentDescriptor();
          (0, InstrumentDescriptor_1.isDescriptorCompatibleWith)(existingDescriptor, expectedDescriptor) ? (existingDescriptor.description !== expectedDescriptor.description && (expectedDescriptor.description.length > existingDescriptor.description.length && existingStorage.updateDescription(expectedDescriptor.description), api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, ` has already been registered, but has a different description and is incompatible with another registered view.
`, `Details:
`, (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), `The longer description will be used.
To resolve the conflict:`, (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor))), compatibleStorage = existingStorage) : api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, ` has already been registered and is incompatible with another registered view.
`, `Details:
`, (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), `To resolve the conflict:
`, (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor));
        }
        return compatibleStorage;
      }
    };
    exports.MetricStorageRegistry = MetricStorageRegistry;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MultiWritableMetricStorage.js
var require_MultiWritableMetricStorage = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MultiWritableMetricStorage.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MultiMetricStorage = void 0;
    var MultiMetricStorage = class {
      constructor(_backingStorages) {
        this._backingStorages = _backingStorages;
      }
      record(value, attributes, context, recordTime) {
        this._backingStorages.forEach((it) => {
          it.record(value, attributes, context, recordTime);
        });
      }
    };
    exports.MultiMetricStorage = MultiMetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/ObservableResult.js
var require_ObservableResult = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/ObservableResult.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.BatchObservableResultImpl = exports.ObservableResultImpl = void 0;
    var api_1 = require_src(), HashMap_1 = require_HashMap(), Instruments_1 = require_Instruments(), ObservableResultImpl = class {
      constructor(_descriptor) {
        this._descriptor = _descriptor, this._buffer = new HashMap_1.AttributeHashMap();
      }
      /**
       * Observe a measurement of the value associated with the given attributes.
       */
      observe(value, attributes = {}) {
        if (typeof value != "number") {
          api_1.diag.warn(`non-number value provided to metric ${this._descriptor.name}: ${value}`);
          return;
        }
        this._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value) && (api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`), value = Math.trunc(value), !Number.isInteger(value)) || this._buffer.set(attributes, value);
      }
    };
    exports.ObservableResultImpl = ObservableResultImpl;
    var BatchObservableResultImpl = class {
      constructor() {
        this._buffer = /* @__PURE__ */ new Map();
      }
      /**
       * Observe a measurement of the value associated with the given attributes.
       */
      observe(metric, value, attributes = {}) {
        if (!(0, Instruments_1.isObservableInstrument)(metric))
          return;
        let map = this._buffer.get(metric);
        if (map == null && (map = new HashMap_1.AttributeHashMap(), this._buffer.set(metric, map)), typeof value != "number") {
          api_1.diag.warn(`non-number value provided to metric ${metric._descriptor.name}: ${value}`);
          return;
        }
        metric._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value) && (api_1.diag.warn(`INT value type cannot accept a floating-point value for ${metric._descriptor.name}, ignoring the fractional digits.`), value = Math.trunc(value), !Number.isInteger(value)) || map.set(attributes, value);
      }
    };
    exports.BatchObservableResultImpl = BatchObservableResultImpl;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/ObservableRegistry.js
var require_ObservableRegistry = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/ObservableRegistry.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ObservableRegistry = void 0;
    var api_1 = require_src(), Instruments_1 = require_Instruments(), ObservableResult_1 = require_ObservableResult(), utils_1 = require_utils3(), ObservableRegistry = class {
      constructor() {
        this._callbacks = [], this._batchCallbacks = [];
      }
      addCallback(callback, instrument) {
        this._findCallback(callback, instrument) >= 0 || this._callbacks.push({ callback, instrument });
      }
      removeCallback(callback, instrument) {
        let idx = this._findCallback(callback, instrument);
        idx < 0 || this._callbacks.splice(idx, 1);
      }
      addBatchCallback(callback, instruments) {
        let observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument));
        if (observableInstruments.size === 0) {
          api_1.diag.error("BatchObservableCallback is not associated with valid instruments", instruments);
          return;
        }
        this._findBatchCallback(callback, observableInstruments) >= 0 || this._batchCallbacks.push({ callback, instruments: observableInstruments });
      }
      removeBatchCallback(callback, instruments) {
        let observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument)), idx = this._findBatchCallback(callback, observableInstruments);
        idx < 0 || this._batchCallbacks.splice(idx, 1);
      }
      /**
       * @returns a promise of rejected reasons for invoking callbacks.
       */
      async observe(collectionTime, timeoutMillis) {
        let callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis), batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);
        return (await (0, utils_1.PromiseAllSettled)([
          ...callbackFutures,
          ...batchCallbackFutures
        ])).filter(utils_1.isPromiseAllSettledRejectionResult).map((it) => it.reason);
      }
      _observeCallbacks(observationTime, timeoutMillis) {
        return this._callbacks.map(async ({ callback, instrument }) => {
          let observableResult = new ObservableResult_1.ObservableResultImpl(instrument._descriptor), callPromise = Promise.resolve(callback(observableResult));
          timeoutMillis != null && (callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis)), await callPromise, instrument._metricStorages.forEach((metricStorage) => {
            metricStorage.record(observableResult._buffer, observationTime);
          });
        });
      }
      _observeBatchCallbacks(observationTime, timeoutMillis) {
        return this._batchCallbacks.map(async ({ callback, instruments }) => {
          let observableResult = new ObservableResult_1.BatchObservableResultImpl(), callPromise = Promise.resolve(callback(observableResult));
          timeoutMillis != null && (callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis)), await callPromise, instruments.forEach((instrument) => {
            let buffer = observableResult._buffer.get(instrument);
            buffer != null && instrument._metricStorages.forEach((metricStorage) => {
              metricStorage.record(buffer, observationTime);
            });
          });
        });
      }
      _findCallback(callback, instrument) {
        return this._callbacks.findIndex((record) => record.callback === callback && record.instrument === instrument);
      }
      _findBatchCallback(callback, instruments) {
        return this._batchCallbacks.findIndex((record) => record.callback === callback && (0, utils_1.setEquals)(record.instruments, instruments));
      }
    };
    exports.ObservableRegistry = ObservableRegistry;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/SyncMetricStorage.js
var require_SyncMetricStorage = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/SyncMetricStorage.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.SyncMetricStorage = void 0;
    var MetricStorage_1 = require_MetricStorage(), DeltaMetricProcessor_1 = require_DeltaMetricProcessor(), TemporalMetricProcessor_1 = require_TemporalMetricProcessor(), SyncMetricStorage = class extends MetricStorage_1.MetricStorage {
      constructor(instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles) {
        super(instrumentDescriptor), this._attributesProcessor = _attributesProcessor, this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator), this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator, collectorHandles);
      }
      record(value, attributes, context, recordTime) {
        attributes = this._attributesProcessor.process(attributes, context), this._deltaMetricStorage.record(value, attributes, context, recordTime);
      }
      /**
       * Collects the metrics from this storage.
       *
       * Note: This is a stateful operation and may reset any interval-related
       * state for the MetricCollector.
       */
      collect(collector, collectionTime) {
        let accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
      }
    };
    exports.SyncMetricStorage = SyncMetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/AttributesProcessor.js
var require_AttributesProcessor = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/AttributesProcessor.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.FilteringAttributesProcessor = exports.NoopAttributesProcessor = exports.AttributesProcessor = void 0;
    var AttributesProcessor = class {
      static Noop() {
        return NOOP;
      }
    };
    exports.AttributesProcessor = AttributesProcessor;
    var NoopAttributesProcessor = class extends AttributesProcessor {
      process(incoming, _context) {
        return incoming;
      }
    };
    exports.NoopAttributesProcessor = NoopAttributesProcessor;
    var FilteringAttributesProcessor = class extends AttributesProcessor {
      constructor(_allowedAttributeNames) {
        super(), this._allowedAttributeNames = _allowedAttributeNames;
      }
      process(incoming, _context) {
        let filteredAttributes = {};
        return Object.keys(incoming).filter((attributeName) => this._allowedAttributeNames.includes(attributeName)).forEach((attributeName) => filteredAttributes[attributeName] = incoming[attributeName]), filteredAttributes;
      }
    };
    exports.FilteringAttributesProcessor = FilteringAttributesProcessor;
    var NOOP = new NoopAttributesProcessor();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterSharedState.js
var require_MeterSharedState = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterSharedState.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MeterSharedState = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor(), Meter_1 = require_Meter(), utils_1 = require_utils3(), AsyncMetricStorage_1 = require_AsyncMetricStorage(), MetricStorageRegistry_1 = require_MetricStorageRegistry(), MultiWritableMetricStorage_1 = require_MultiWritableMetricStorage(), ObservableRegistry_1 = require_ObservableRegistry(), SyncMetricStorage_1 = require_SyncMetricStorage(), AttributesProcessor_1 = require_AttributesProcessor(), MeterSharedState = class {
      constructor(_meterProviderSharedState, _instrumentationScope) {
        this._meterProviderSharedState = _meterProviderSharedState, this._instrumentationScope = _instrumentationScope, this.metricStorageRegistry = new MetricStorageRegistry_1.MetricStorageRegistry(), this.observableRegistry = new ObservableRegistry_1.ObservableRegistry(), this.meter = new Meter_1.Meter(this);
      }
      registerMetricStorage(descriptor) {
        let storages = this._registerMetricStorage(descriptor, SyncMetricStorage_1.SyncMetricStorage);
        return storages.length === 1 ? storages[0] : new MultiWritableMetricStorage_1.MultiMetricStorage(storages);
      }
      registerAsyncMetricStorage(descriptor) {
        return this._registerMetricStorage(descriptor, AsyncMetricStorage_1.AsyncMetricStorage);
      }
      /**
       * @param collector opaque handle of {@link MetricCollector} which initiated the collection.
       * @param collectionTime the HrTime at which the collection was initiated.
       * @param options options for collection.
       * @returns the list of metric data collected.
       */
      async collect(collector, collectionTime, options) {
        let errors = await this.observableRegistry.observe(collectionTime, options?.timeoutMillis), storages = this.metricStorageRegistry.getStorages(collector);
        if (storages.length === 0)
          return null;
        let metricDataList = storages.map((metricStorage) => metricStorage.collect(collector, collectionTime)).filter(utils_1.isNotNullish);
        return metricDataList.length === 0 ? { errors } : {
          scopeMetrics: {
            scope: this._instrumentationScope,
            metrics: metricDataList
          },
          errors
        };
      }
      _registerMetricStorage(descriptor, MetricStorageType) {
        let storages = this._meterProviderSharedState.viewRegistry.findViews(descriptor, this._instrumentationScope).map((view) => {
          let viewDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptorWithView)(view, descriptor), compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleStorage(viewDescriptor);
          if (compatibleStorage != null)
            return compatibleStorage;
          let aggregator = view.aggregation.createAggregator(viewDescriptor), viewStorage = new MetricStorageType(viewDescriptor, aggregator, view.attributesProcessor, this._meterProviderSharedState.metricCollectors);
          return this.metricStorageRegistry.register(viewStorage), viewStorage;
        });
        if (storages.length === 0) {
          let collectorStorages = this._meterProviderSharedState.selectAggregations(descriptor.type).map(([collector, aggregation]) => {
            let compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage(collector, descriptor);
            if (compatibleStorage != null)
              return compatibleStorage;
            let aggregator = aggregation.createAggregator(descriptor), storage = new MetricStorageType(descriptor, aggregator, AttributesProcessor_1.AttributesProcessor.Noop(), [collector]);
            return this.metricStorageRegistry.registerForCollector(collector, storage), storage;
          });
          storages = storages.concat(collectorStorages);
        }
        return storages;
      }
    };
    exports.MeterSharedState = MeterSharedState;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterProviderSharedState.js
var require_MeterProviderSharedState = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterProviderSharedState.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MeterProviderSharedState = void 0;
    var utils_1 = require_utils3(), ViewRegistry_1 = require_ViewRegistry(), MeterSharedState_1 = require_MeterSharedState(), MeterProviderSharedState = class {
      constructor(resource) {
        this.resource = resource, this.viewRegistry = new ViewRegistry_1.ViewRegistry(), this.metricCollectors = [], this.meterSharedStates = /* @__PURE__ */ new Map();
      }
      getMeterSharedState(instrumentationScope2) {
        let id = (0, utils_1.instrumentationScopeId)(instrumentationScope2), meterSharedState = this.meterSharedStates.get(id);
        return meterSharedState == null && (meterSharedState = new MeterSharedState_1.MeterSharedState(this, instrumentationScope2), this.meterSharedStates.set(id, meterSharedState)), meterSharedState;
      }
      selectAggregations(instrumentType) {
        let result = [];
        for (let collector of this.metricCollectors)
          result.push([collector, collector.selectAggregation(instrumentType)]);
        return result;
      }
    };
    exports.MeterProviderSharedState = MeterProviderSharedState;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricCollector.js
var require_MetricCollector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricCollector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MetricCollector = void 0;
    var core_1 = require_src3(), MetricCollector = class {
      constructor(_sharedState, _metricReader) {
        this._sharedState = _sharedState, this._metricReader = _metricReader;
      }
      async collect(options) {
        let collectionTime = (0, core_1.millisToHrTime)(Date.now()), scopeMetrics = [], errors = [], meterCollectionPromises = Array.from(this._sharedState.meterSharedStates.values()).map(async (meterSharedState) => {
          let current = await meterSharedState.collect(this, collectionTime, options);
          current?.scopeMetrics != null && scopeMetrics.push(current.scopeMetrics), current?.errors != null && errors.push(...current.errors);
        });
        return await Promise.all(meterCollectionPromises), {
          resourceMetrics: {
            resource: this._sharedState.resource,
            scopeMetrics
          },
          errors
        };
      }
      /**
       * Delegates for MetricReader.forceFlush.
       */
      async forceFlush(options) {
        await this._metricReader.forceFlush(options);
      }
      /**
       * Delegates for MetricReader.shutdown.
       */
      async shutdown(options) {
        await this._metricReader.shutdown(options);
      }
      selectAggregationTemporality(instrumentType) {
        return this._metricReader.selectAggregationTemporality(instrumentType);
      }
      selectAggregation(instrumentType) {
        return this._metricReader.selectAggregation(instrumentType);
      }
    };
    exports.MetricCollector = MetricCollector;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/MeterProvider.js
var require_MeterProvider = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/MeterProvider.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MeterProvider = void 0;
    var api_1 = require_src(), resources_1 = require_src4(), MeterProviderSharedState_1 = require_MeterProviderSharedState(), MetricCollector_1 = require_MetricCollector(), MeterProvider2 = class {
      constructor(options) {
        var _a;
        this._shutdown = !1;
        let resource = resources_1.Resource.default().merge((_a = options?.resource) !== null && _a !== void 0 ? _a : resources_1.Resource.empty());
        if (this._sharedState = new MeterProviderSharedState_1.MeterProviderSharedState(resource), options?.views != null && options.views.length > 0)
          for (let view of options.views)
            this._sharedState.viewRegistry.addView(view);
      }
      /**
       * Get a meter with the configuration of the MeterProvider.
       */
      getMeter(name, version = "", options = {}) {
        return this._shutdown ? (api_1.diag.warn("A shutdown MeterProvider cannot provide a Meter"), (0, api_1.createNoopMeter)()) : this._sharedState.getMeterSharedState({
          name,
          version,
          schemaUrl: options.schemaUrl
        }).meter;
      }
      /**
       * Register a {@link MetricReader} to the meter provider. After the
       * registration, the MetricReader can start metrics collection.
       *
       * @param metricReader the metric reader to be registered.
       */
      addMetricReader(metricReader) {
        let collector = new MetricCollector_1.MetricCollector(this._sharedState, metricReader);
        metricReader.setMetricProducer(collector), this._sharedState.metricCollectors.push(collector);
      }
      /**
       * Flush all buffered data and shut down the MeterProvider and all registered
       * MetricReaders.
       *
       * Returns a promise which is resolved when all flushes are complete.
       */
      async shutdown(options) {
        if (this._shutdown) {
          api_1.diag.warn("shutdown may only be called once per MeterProvider");
          return;
        }
        this._shutdown = !0, await Promise.all(this._sharedState.metricCollectors.map((collector) => collector.shutdown(options)));
      }
      /**
       * Notifies all registered MetricReaders to flush any buffered data.
       *
       * Returns a promise which is resolved when all flushes are complete.
       */
      async forceFlush(options) {
        if (this._shutdown) {
          api_1.diag.warn("invalid attempt to force flush after MeterProvider shutdown");
          return;
        }
        await Promise.all(this._sharedState.metricCollectors.map((collector) => collector.forceFlush(options)));
      }
    };
    exports.MeterProvider = MeterProvider2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Predicate.js
var require_Predicate = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Predicate.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ExactPredicate = exports.PatternPredicate = void 0;
    var ESCAPE = /[\^$\\.+?()[\]{}|]/g, PatternPredicate = class _PatternPredicate {
      constructor(pattern) {
        pattern === "*" ? (this._matchAll = !0, this._regexp = /.*/) : (this._matchAll = !1, this._regexp = new RegExp(_PatternPredicate.escapePattern(pattern)));
      }
      match(str) {
        return this._matchAll ? !0 : this._regexp.test(str);
      }
      static escapePattern(pattern) {
        return `^${pattern.replace(ESCAPE, "\\$&").replace("*", ".*")}$`;
      }
      static hasWildcard(pattern) {
        return pattern.includes("*");
      }
    };
    exports.PatternPredicate = PatternPredicate;
    var ExactPredicate = class {
      constructor(pattern) {
        this._matchAll = pattern === void 0, this._pattern = pattern;
      }
      match(str) {
        return !!(this._matchAll || str === this._pattern);
      }
    };
    exports.ExactPredicate = ExactPredicate;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/InstrumentSelector.js
var require_InstrumentSelector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/InstrumentSelector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.InstrumentSelector = void 0;
    var Predicate_1 = require_Predicate(), InstrumentSelector = class {
      constructor(criteria) {
        var _a;
        this._nameFilter = new Predicate_1.PatternPredicate((_a = criteria?.name) !== null && _a !== void 0 ? _a : "*"), this._type = criteria?.type, this._unitFilter = new Predicate_1.ExactPredicate(criteria?.unit);
      }
      getType() {
        return this._type;
      }
      getNameFilter() {
        return this._nameFilter;
      }
      getUnitFilter() {
        return this._unitFilter;
      }
    };
    exports.InstrumentSelector = InstrumentSelector;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/MeterSelector.js
var require_MeterSelector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/MeterSelector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MeterSelector = void 0;
    var Predicate_1 = require_Predicate(), MeterSelector = class {
      constructor(criteria) {
        this._nameFilter = new Predicate_1.ExactPredicate(criteria?.name), this._versionFilter = new Predicate_1.ExactPredicate(criteria?.version), this._schemaUrlFilter = new Predicate_1.ExactPredicate(criteria?.schemaUrl);
      }
      getNameFilter() {
        return this._nameFilter;
      }
      /**
       * TODO: semver filter? no spec yet.
       */
      getVersionFilter() {
        return this._versionFilter;
      }
      getSchemaUrlFilter() {
        return this._schemaUrlFilter;
      }
    };
    exports.MeterSelector = MeterSelector;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/View.js
var require_View = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/View.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.View = void 0;
    var Predicate_1 = require_Predicate(), AttributesProcessor_1 = require_AttributesProcessor(), InstrumentSelector_1 = require_InstrumentSelector(), MeterSelector_1 = require_MeterSelector(), Aggregation_1 = require_Aggregation();
    function isSelectorNotProvided(options) {
      return options.instrumentName == null && options.instrumentType == null && options.instrumentUnit == null && options.meterName == null && options.meterVersion == null && options.meterSchemaUrl == null;
    }
    var View2 = class {
      /**
       * Create a new {@link View} instance.
       *
       * Parameters can be categorized as two types:
       *  Instrument selection criteria: Used to describe the instrument(s) this view will be applied to.
       *  Will be treated as additive (the Instrument has to meet all the provided criteria to be selected).
       *
       *  Metric stream altering: Alter the metric stream of instruments selected by instrument selection criteria.
       *
       * @param viewOptions {@link ViewOptions} for altering the metric stream and instrument selection.
       * @param viewOptions.name
       * Alters the metric stream:
       *  This will be used as the name of the metrics stream.
       *  If not provided, the original Instrument name will be used.
       * @param viewOptions.description
       * Alters the metric stream:
       *  This will be used as the description of the metrics stream.
       *  If not provided, the original Instrument description will be used by default.
       * @param viewOptions.attributeKeys
       * Alters the metric stream:
       *  If provided, the attributes that are not in the list will be ignored.
       *  If not provided, all attribute keys will be used by default.
       * @param viewOptions.aggregation
       * Alters the metric stream:
       *  Alters the {@link Aggregation} of the metric stream.
       * @param viewOptions.instrumentName
       * Instrument selection criteria:
       *  Original name of the Instrument(s) with wildcard support.
       * @param viewOptions.instrumentType
       * Instrument selection criteria:
       *  The original type of the Instrument(s).
       * @param viewOptions.instrumentUnit
       * Instrument selection criteria:
       *  The unit of the Instrument(s).
       * @param viewOptions.meterName
       * Instrument selection criteria:
       *  The name of the Meter. No wildcard support, name must match the meter exactly.
       * @param viewOptions.meterVersion
       * Instrument selection criteria:
       *  The version of the Meter. No wildcard support, version must match exactly.
       * @param viewOptions.meterSchemaUrl
       * Instrument selection criteria:
       *  The schema URL of the Meter. No wildcard support, schema URL must match exactly.
       *
       * @example
       * // Create a view that changes the Instrument 'my.instrument' to use to an
       * // ExplicitBucketHistogramAggregation with the boundaries [20, 30, 40]
       * new View({
       *   aggregation: new ExplicitBucketHistogramAggregation([20, 30, 40]),
       *   instrumentName: 'my.instrument'
       * })
       */
      constructor(viewOptions) {
        var _a;
        if (isSelectorNotProvided(viewOptions))
          throw new Error("Cannot create view with no selector arguments supplied");
        if (viewOptions.name != null && (viewOptions?.instrumentName == null || Predicate_1.PatternPredicate.hasWildcard(viewOptions.instrumentName)))
          throw new Error("Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.");
        viewOptions.attributeKeys != null ? this.attributesProcessor = new AttributesProcessor_1.FilteringAttributesProcessor(viewOptions.attributeKeys) : this.attributesProcessor = AttributesProcessor_1.AttributesProcessor.Noop(), this.name = viewOptions.name, this.description = viewOptions.description, this.aggregation = (_a = viewOptions.aggregation) !== null && _a !== void 0 ? _a : Aggregation_1.Aggregation.Default(), this.instrumentSelector = new InstrumentSelector_1.InstrumentSelector({
          name: viewOptions.instrumentName,
          type: viewOptions.instrumentType,
          unit: viewOptions.instrumentUnit
        }), this.meterSelector = new MeterSelector_1.MeterSelector({
          name: viewOptions.meterName,
          version: viewOptions.meterVersion,
          schemaUrl: viewOptions.meterSchemaUrl
        });
      }
    };
    exports.View = View2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/index.js
var require_src5 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.1_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TimeoutError = exports.View = exports.Aggregation = exports.SumAggregation = exports.LastValueAggregation = exports.HistogramAggregation = exports.DropAggregation = exports.ExponentialHistogramAggregation = exports.ExplicitBucketHistogramAggregation = exports.DefaultAggregation = exports.MeterProvider = exports.InstrumentType = exports.ConsoleMetricExporter = exports.InMemoryMetricExporter = exports.PeriodicExportingMetricReader = exports.MetricReader = exports.DataPointType = exports.AggregationTemporality = void 0;
    var AggregationTemporality_1 = require_AggregationTemporality();
    Object.defineProperty(exports, "AggregationTemporality", { enumerable: !0, get: function() {
      return AggregationTemporality_1.AggregationTemporality;
    } });
    var MetricData_1 = require_MetricData();
    Object.defineProperty(exports, "DataPointType", { enumerable: !0, get: function() {
      return MetricData_1.DataPointType;
    } });
    var MetricReader_1 = require_MetricReader();
    Object.defineProperty(exports, "MetricReader", { enumerable: !0, get: function() {
      return MetricReader_1.MetricReader;
    } });
    var PeriodicExportingMetricReader_1 = require_PeriodicExportingMetricReader();
    Object.defineProperty(exports, "PeriodicExportingMetricReader", { enumerable: !0, get: function() {
      return PeriodicExportingMetricReader_1.PeriodicExportingMetricReader;
    } });
    var InMemoryMetricExporter_1 = require_InMemoryMetricExporter();
    Object.defineProperty(exports, "InMemoryMetricExporter", { enumerable: !0, get: function() {
      return InMemoryMetricExporter_1.InMemoryMetricExporter;
    } });
    var ConsoleMetricExporter_1 = require_ConsoleMetricExporter();
    Object.defineProperty(exports, "ConsoleMetricExporter", { enumerable: !0, get: function() {
      return ConsoleMetricExporter_1.ConsoleMetricExporter;
    } });
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    Object.defineProperty(exports, "InstrumentType", { enumerable: !0, get: function() {
      return InstrumentDescriptor_1.InstrumentType;
    } });
    var MeterProvider_1 = require_MeterProvider();
    Object.defineProperty(exports, "MeterProvider", { enumerable: !0, get: function() {
      return MeterProvider_1.MeterProvider;
    } });
    var Aggregation_1 = require_Aggregation();
    Object.defineProperty(exports, "DefaultAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.DefaultAggregation;
    } });
    Object.defineProperty(exports, "ExplicitBucketHistogramAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.ExplicitBucketHistogramAggregation;
    } });
    Object.defineProperty(exports, "ExponentialHistogramAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.ExponentialHistogramAggregation;
    } });
    Object.defineProperty(exports, "DropAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.DropAggregation;
    } });
    Object.defineProperty(exports, "HistogramAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.HistogramAggregation;
    } });
    Object.defineProperty(exports, "LastValueAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.LastValueAggregation;
    } });
    Object.defineProperty(exports, "SumAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.SumAggregation;
    } });
    Object.defineProperty(exports, "Aggregation", { enumerable: !0, get: function() {
      return Aggregation_1.Aggregation;
    } });
    var View_1 = require_View();
    Object.defineProperty(exports, "View", { enumerable: !0, get: function() {
      return View_1.View;
    } });
    var utils_1 = require_utils3();
    Object.defineProperty(exports, "TimeoutError", { enumerable: !0, get: function() {
      return utils_1.TimeoutError;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = void 0;
    var api_1 = require_src(), SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context) {
      return context.setValue(SUPPRESS_TRACING_KEY, !0);
    }
    exports.suppressTracing = suppressTracing;
    function unsuppressTracing(context) {
      return context.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context) {
      return context.getValue(SUPPRESS_TRACING_KEY) === !0;
    }
    exports.isTracingSuppressed = isTracingSuppressed;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports.BAGGAGE_HEADER = "baggage";
    exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils7 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = void 0;
    var api_1 = require_src(), constants_1 = require_constants2();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        let value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        return value.metadata !== void 0 && (entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString()), entry;
      });
    }
    exports.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      let valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      let keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      let separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      let key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim()), value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim()), metadata;
      return valueProps.length > 0 && (metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR))), { key, value, metadata };
    }
    exports.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      return typeof value != "string" || value.length === 0 ? {} : value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => parsePairKeyValue(entry)).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => (headers[keyPair.key] = keyPair.value, headers), {});
    }
    exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.W3CBaggagePropagator = void 0;
    var api_1 = require_src(), suppress_tracing_1 = require_suppress_tracing2(), constants_1 = require_constants2(), utils_1 = require_utils7(), W3CBaggagePropagator = class {
      inject(context, carrier, setter) {
        let baggage = api_1.propagation.getBaggage(context);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context))
          return;
        let keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS), headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        headerValue.length > 0 && setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
      }
      extract(context, carrier, getter) {
        let headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER), baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context;
        let baggage = {};
        return baggageString.length === 0 || (baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).forEach((entry) => {
          let keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            let baggageEntry = { value: keyPair.value };
            keyPair.metadata && (baggageEntry.metadata = keyPair.metadata), baggage[keyPair.key] = baggageEntry;
          }
        }), Object.entries(baggage).length === 0) ? context : api_1.propagation.setBaggage(context, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock, this._epochMillis = systemClock.now(), this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        let delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports.AnchoredClock = AnchoredClock;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = void 0;
    var api_1 = require_src();
    function sanitizeAttributes(attributes) {
      let out = {};
      if (typeof attributes != "object" || attributes == null)
        return out;
      for (let [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        Array.isArray(val) ? out[key] = val.slice() : out[key] = val;
      }
      return out;
    }
    exports.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key == "string" && key.length > 0;
    }
    exports.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      return val == null ? !0 : Array.isArray(val) ? isHomogeneousAttributeValueArray(val) : isValidPrimitiveAttributeValue(val);
    }
    exports.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (let element of arr)
        if (element != null) {
          if (!type) {
            if (isValidPrimitiveAttributeValue(element)) {
              type = typeof element;
              continue;
            }
            return !1;
          }
          if (typeof element !== type)
            return !1;
        }
      return !0;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return !0;
      }
      return !1;
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.loggingErrorHandler = void 0;
    var api_1 = require_src();
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      return typeof ex == "string" ? ex : JSON.stringify(flattenException(ex));
    }
    function flattenException(ex) {
      let result = {}, current = ex;
      for (; current !== null; )
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result[propertyName])
            return;
          let value = current[propertyName];
          value && (result[propertyName] = String(value));
        }), current = Object.getPrototypeOf(current);
      return result;
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.globalErrorHandler = exports.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler2(), delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch {
      }
    }
    exports.globalErrorHandler = globalErrorHandler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2.AlwaysOff = "always_off", TracesSamplerValues2.AlwaysOn = "always_on", TracesSamplerValues2.ParentBasedAlwaysOff = "parentbased_always_off", TracesSamplerValues2.ParentBasedAlwaysOn = "parentbased_always_on", TracesSamplerValues2.ParentBasedTraceIdRatio = "parentbased_traceidratio", TracesSamplerValues2.TraceIdRatio = "traceidratio";
    })(TracesSamplerValues = exports.TracesSamplerValues || (exports.TracesSamplerValues = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/browser/globalThis.js
var require_globalThis4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/browser/globalThis.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof global == "object" ? global : {};
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getEnvWithoutDefaults = exports.parseEnvironment = exports.DEFAULT_ENVIRONMENT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = require_src(), sampling_1 = require_sampling2(), globalThis_1 = require_globalThis4(), DEFAULT_LIST_SEPARATOR = ",", ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1 / 0;
    exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: !1,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
    };
    function parseBoolean(key, environment, values) {
      if (typeof values[key] > "u")
        return;
      let value = String(values[key]);
      environment[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment, values, min = -1 / 0, max = 1 / 0) {
      if (typeof values[name] < "u") {
        let value = Number(values[name]);
        isNaN(value) || (value < min ? environment[name] = min : value > max ? environment[name] = max : environment[name] = value);
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      let givenValue = input[name];
      typeof givenValue == "string" && (output[name] = givenValue.split(separator).map((v) => v.trim()));
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment, values) {
      let value = values[key];
      if (typeof value == "string") {
        let theLevel = logLevelMap[value.toUpperCase()];
        theLevel != null && (environment[key] = theLevel);
      }
    }
    function parseEnvironment(values) {
      let environment = {};
      for (let env in exports.DEFAULT_ENVIRONMENT) {
        let key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment, values);
            break;
          default:
            if (isEnvVarABoolean(key))
              parseBoolean(key, environment, values);
            else if (isEnvVarANumber(key))
              parseNumber(key, environment, values);
            else if (isEnvVarAList(key))
              parseStringList(key, environment, values);
            else {
              let value = values[key];
              typeof value < "u" && value !== null && (environment[key] = String(value));
            }
        }
      }
      return environment;
    }
    exports.parseEnvironment = parseEnvironment;
    function getEnvWithoutDefaults() {
      return typeof process < "u" && process && process.env ? parseEnvironment(process.env) : parseEnvironment(globalThis_1._globalThis);
    }
    exports.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getEnv = void 0;
    var os = __require("os"), environment_1 = require_environment3();
    function getEnv() {
      let processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({
        HOSTNAME: os.hostname()
      }, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports.getEnv = getEnv;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis5 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis == "object" ? globalThis : global;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base642 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.hexToBase64 = void 0;
    function intValue(charCode) {
      return charCode >= 48 && charCode <= 57 ? charCode - 48 : charCode >= 97 && charCode <= 102 ? charCode - 87 : charCode - 55;
    }
    var buf8 = Buffer.alloc(8), buf16 = Buffer.alloc(16);
    function hexToBase64(hexStr) {
      let buf;
      hexStr.length === 16 ? buf = buf8 : hexStr.length === 32 ? buf = buf16 : buf = Buffer.alloc(hexStr.length / 2);
      let offset = 0;
      for (let i = 0; i < hexStr.length; i += 2) {
        let hi = intValue(hexStr.charCodeAt(i)), lo = intValue(hexStr.charCodeAt(i + 1));
        buf.writeUInt8(hi << 4 | lo, offset++);
      }
      return buf.toString("base64");
    }
    exports.hexToBase64 = hexToBase64;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8, TRACE_ID_BYTES = 16, RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES), this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function() {
        for (let i = 0; i < bytes / 4; i++)
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
        for (let i = 0; i < bytes && !(SHARED_BUFFER[i] > 0); i++)
          i === bytes - 1 && (SHARED_BUFFER[bytes - 1] = 1);
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.otperformance = void 0;
    var perf_hooks_1 = __require("perf_hooks");
    exports.otperformance = perf_hooks_1.performance;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/version.js
var require_version3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/version.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.VERSION = void 0;
    exports.VERSION = "1.17.0";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.0/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.0/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MessageTypeValues = exports.RpcGrpcStatusCodeValues = exports.MessagingOperationValues = exports.MessagingDestinationKindValues = exports.HttpFlavorValues = exports.NetHostConnectionSubtypeValues = exports.NetHostConnectionTypeValues = exports.NetTransportValues = exports.FaasInvokedProviderValues = exports.FaasDocumentOperationValues = exports.FaasTriggerValues = exports.DbCassandraConsistencyLevelValues = exports.DbSystemValues = exports.SemanticAttributes = void 0;
    exports.SemanticAttributes = {
      /**
       * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).
       *
       * Note: This may be different from `faas.id` if an alias is involved.
       */
      AWS_LAMBDA_INVOKED_ARN: "aws.lambda.invoked_arn",
      /**
       * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
       */
      DB_SYSTEM: "db.system",
      /**
       * The connection string used to connect to the database. It is recommended to remove embedded credentials.
       */
      DB_CONNECTION_STRING: "db.connection_string",
      /**
       * Username for accessing the database.
       */
      DB_USER: "db.user",
      /**
       * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.
       */
      DB_JDBC_DRIVER_CLASSNAME: "db.jdbc.driver_classname",
      /**
       * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).
       *
       * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.
       */
      DB_NAME: "db.name",
      /**
       * The database statement being executed.
       *
       * Note: The value may be sanitized to exclude sensitive information.
       */
      DB_STATEMENT: "db.statement",
      /**
       * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.
       *
       * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.
       */
      DB_OPERATION: "db.operation",
      /**
       * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.
       *
       * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).
       */
      DB_MSSQL_INSTANCE_NAME: "db.mssql.instance_name",
      /**
       * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.
       */
      DB_CASSANDRA_KEYSPACE: "db.cassandra.keyspace",
      /**
       * The fetch size used for paging, i.e. how many rows will be returned at once.
       */
      DB_CASSANDRA_PAGE_SIZE: "db.cassandra.page_size",
      /**
       * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
       */
      DB_CASSANDRA_CONSISTENCY_LEVEL: "db.cassandra.consistency_level",
      /**
       * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
       *
       * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
       */
      DB_CASSANDRA_TABLE: "db.cassandra.table",
      /**
       * Whether or not the query is idempotent.
       */
      DB_CASSANDRA_IDEMPOTENCE: "db.cassandra.idempotence",
      /**
       * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.
       */
      DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: "db.cassandra.speculative_execution_count",
      /**
       * The ID of the coordinating node for a query.
       */
      DB_CASSANDRA_COORDINATOR_ID: "db.cassandra.coordinator.id",
      /**
       * The data center of the coordinating node for a query.
       */
      DB_CASSANDRA_COORDINATOR_DC: "db.cassandra.coordinator.dc",
      /**
       * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.
       */
      DB_HBASE_NAMESPACE: "db.hbase.namespace",
      /**
       * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.
       */
      DB_REDIS_DATABASE_INDEX: "db.redis.database_index",
      /**
       * The collection being accessed within the database stated in `db.name`.
       */
      DB_MONGODB_COLLECTION: "db.mongodb.collection",
      /**
       * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
       *
       * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
       */
      DB_SQL_TABLE: "db.sql.table",
      /**
       * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
       */
      EXCEPTION_TYPE: "exception.type",
      /**
       * The exception message.
       */
      EXCEPTION_MESSAGE: "exception.message",
      /**
       * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
       */
      EXCEPTION_STACKTRACE: "exception.stacktrace",
      /**
        * SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.
        *
        * Note: An exception is considered to have escaped (or left) the scope of a span,
      if that span is ended while the exception is still logically &#34;in flight&#34;.
      This may be actually &#34;in flight&#34; in some languages (e.g. if the exception
      is passed to a Context manager&#39;s `__exit__` method in Python) but will
      usually be caught at the point of recording the exception in most languages.
      
      It is usually not possible to determine at the point where an exception is thrown
      whether it will escape the scope of a span.
      However, it is trivial to know that an exception
      will escape, if one checks for an active exception just before ending the span,
      as done in the [example above](#exception-end-example).
      
      It follows that an exception may still escape the scope of the span
      even if the `exception.escaped` attribute was not set or set to false,
      since the event might have been recorded at a time where it was not
      clear whether the exception will escape.
        */
      EXCEPTION_ESCAPED: "exception.escaped",
      /**
       * Type of the trigger on which the function is executed.
       */
      FAAS_TRIGGER: "faas.trigger",
      /**
       * The execution ID of the current function execution.
       */
      FAAS_EXECUTION: "faas.execution",
      /**
       * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.
       */
      FAAS_DOCUMENT_COLLECTION: "faas.document.collection",
      /**
       * Describes the type of the operation that was performed on the data.
       */
      FAAS_DOCUMENT_OPERATION: "faas.document.operation",
      /**
       * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
       */
      FAAS_DOCUMENT_TIME: "faas.document.time",
      /**
       * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.
       */
      FAAS_DOCUMENT_NAME: "faas.document.name",
      /**
       * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
       */
      FAAS_TIME: "faas.time",
      /**
       * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).
       */
      FAAS_CRON: "faas.cron",
      /**
       * A boolean that is true if the serverless function is executed for the first time (aka cold-start).
       */
      FAAS_COLDSTART: "faas.coldstart",
      /**
       * The name of the invoked function.
       *
       * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.
       */
      FAAS_INVOKED_NAME: "faas.invoked_name",
      /**
       * The cloud provider of the invoked function.
       *
       * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
       */
      FAAS_INVOKED_PROVIDER: "faas.invoked_provider",
      /**
       * The cloud region of the invoked function.
       *
       * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.
       */
      FAAS_INVOKED_REGION: "faas.invoked_region",
      /**
       * Transport protocol used. See note below.
       */
      NET_TRANSPORT: "net.transport",
      /**
       * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).
       */
      NET_PEER_IP: "net.peer.ip",
      /**
       * Remote port number.
       */
      NET_PEER_PORT: "net.peer.port",
      /**
       * Remote hostname or similar, see note below.
       */
      NET_PEER_NAME: "net.peer.name",
      /**
       * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.
       */
      NET_HOST_IP: "net.host.ip",
      /**
       * Like `net.peer.port` but for the host port.
       */
      NET_HOST_PORT: "net.host.port",
      /**
       * Local hostname or similar, see note below.
       */
      NET_HOST_NAME: "net.host.name",
      /**
       * The internet connection type currently being used by the host.
       */
      NET_HOST_CONNECTION_TYPE: "net.host.connection.type",
      /**
       * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
       */
      NET_HOST_CONNECTION_SUBTYPE: "net.host.connection.subtype",
      /**
       * The name of the mobile carrier.
       */
      NET_HOST_CARRIER_NAME: "net.host.carrier.name",
      /**
       * The mobile carrier country code.
       */
      NET_HOST_CARRIER_MCC: "net.host.carrier.mcc",
      /**
       * The mobile carrier network code.
       */
      NET_HOST_CARRIER_MNC: "net.host.carrier.mnc",
      /**
       * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.
       */
      NET_HOST_CARRIER_ICC: "net.host.carrier.icc",
      /**
       * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.
       */
      PEER_SERVICE: "peer.service",
      /**
       * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.
       */
      ENDUSER_ID: "enduser.id",
      /**
       * Actual/assumed role the client is making the request under extracted from token or application security context.
       */
      ENDUSER_ROLE: "enduser.role",
      /**
       * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).
       */
      ENDUSER_SCOPE: "enduser.scope",
      /**
       * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).
       */
      THREAD_ID: "thread.id",
      /**
       * Current thread name.
       */
      THREAD_NAME: "thread.name",
      /**
       * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).
       */
      CODE_FUNCTION: "code.function",
      /**
       * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.
       */
      CODE_NAMESPACE: "code.namespace",
      /**
       * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).
       */
      CODE_FILEPATH: "code.filepath",
      /**
       * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.
       */
      CODE_LINENO: "code.lineno",
      /**
       * HTTP request method.
       */
      HTTP_METHOD: "http.method",
      /**
       * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
       *
       * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
       */
      HTTP_URL: "http.url",
      /**
       * The full request target as passed in a HTTP request line or equivalent.
       */
      HTTP_TARGET: "http.target",
      /**
       * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
       *
       * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
       */
      HTTP_HOST: "http.host",
      /**
       * The URI scheme identifying the used protocol.
       */
      HTTP_SCHEME: "http.scheme",
      /**
       * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
       */
      HTTP_STATUS_CODE: "http.status_code",
      /**
       * Kind of HTTP protocol used.
       *
       * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
       */
      HTTP_FLAVOR: "http.flavor",
      /**
       * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
       */
      HTTP_USER_AGENT: "http.user_agent",
      /**
       * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
       */
      HTTP_REQUEST_CONTENT_LENGTH: "http.request_content_length",
      /**
       * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
       */
      HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: "http.request_content_length_uncompressed",
      /**
       * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
       */
      HTTP_RESPONSE_CONTENT_LENGTH: "http.response_content_length",
      /**
       * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
       */
      HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: "http.response_content_length_uncompressed",
      /**
       * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).
       *
       * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.
       */
      HTTP_SERVER_NAME: "http.server_name",
      /**
       * The matched route (path template).
       */
      HTTP_ROUTE: "http.route",
      /**
        * The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).
        *
        * Note: This is not necessarily the same as `net.peer.ip`, which would
      identify the network-level peer, which may be a proxy.
      
      This attribute should be set when a source of information different
      from the one used for `net.peer.ip`, is available even if that other
      source just confirms the same value as `net.peer.ip`.
      Rationale: For `net.peer.ip`, one typically does not know if it
      comes from a proxy, reverse proxy, or the actual client. Setting
      `http.client_ip` when it&#39;s the same as `net.peer.ip` means that
      one is at least somewhat confident that the address is not that of
      the closest proxy.
        */
      HTTP_CLIENT_IP: "http.client_ip",
      /**
       * The keys in the `RequestItems` object field.
       */
      AWS_DYNAMODB_TABLE_NAMES: "aws.dynamodb.table_names",
      /**
       * The JSON-serialized value of each item in the `ConsumedCapacity` response field.
       */
      AWS_DYNAMODB_CONSUMED_CAPACITY: "aws.dynamodb.consumed_capacity",
      /**
       * The JSON-serialized value of the `ItemCollectionMetrics` response field.
       */
      AWS_DYNAMODB_ITEM_COLLECTION_METRICS: "aws.dynamodb.item_collection_metrics",
      /**
       * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.
       */
      AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: "aws.dynamodb.provisioned_read_capacity",
      /**
       * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.
       */
      AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: "aws.dynamodb.provisioned_write_capacity",
      /**
       * The value of the `ConsistentRead` request parameter.
       */
      AWS_DYNAMODB_CONSISTENT_READ: "aws.dynamodb.consistent_read",
      /**
       * The value of the `ProjectionExpression` request parameter.
       */
      AWS_DYNAMODB_PROJECTION: "aws.dynamodb.projection",
      /**
       * The value of the `Limit` request parameter.
       */
      AWS_DYNAMODB_LIMIT: "aws.dynamodb.limit",
      /**
       * The value of the `AttributesToGet` request parameter.
       */
      AWS_DYNAMODB_ATTRIBUTES_TO_GET: "aws.dynamodb.attributes_to_get",
      /**
       * The value of the `IndexName` request parameter.
       */
      AWS_DYNAMODB_INDEX_NAME: "aws.dynamodb.index_name",
      /**
       * The value of the `Select` request parameter.
       */
      AWS_DYNAMODB_SELECT: "aws.dynamodb.select",
      /**
       * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.
       */
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: "aws.dynamodb.global_secondary_indexes",
      /**
       * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.
       */
      AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: "aws.dynamodb.local_secondary_indexes",
      /**
       * The value of the `ExclusiveStartTableName` request parameter.
       */
      AWS_DYNAMODB_EXCLUSIVE_START_TABLE: "aws.dynamodb.exclusive_start_table",
      /**
       * The the number of items in the `TableNames` response parameter.
       */
      AWS_DYNAMODB_TABLE_COUNT: "aws.dynamodb.table_count",
      /**
       * The value of the `ScanIndexForward` request parameter.
       */
      AWS_DYNAMODB_SCAN_FORWARD: "aws.dynamodb.scan_forward",
      /**
       * The value of the `Segment` request parameter.
       */
      AWS_DYNAMODB_SEGMENT: "aws.dynamodb.segment",
      /**
       * The value of the `TotalSegments` request parameter.
       */
      AWS_DYNAMODB_TOTAL_SEGMENTS: "aws.dynamodb.total_segments",
      /**
       * The value of the `Count` response parameter.
       */
      AWS_DYNAMODB_COUNT: "aws.dynamodb.count",
      /**
       * The value of the `ScannedCount` response parameter.
       */
      AWS_DYNAMODB_SCANNED_COUNT: "aws.dynamodb.scanned_count",
      /**
       * The JSON-serialized value of each item in the `AttributeDefinitions` request field.
       */
      AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: "aws.dynamodb.attribute_definitions",
      /**
       * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.
       */
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: "aws.dynamodb.global_secondary_index_updates",
      /**
       * A string identifying the messaging system.
       */
      MESSAGING_SYSTEM: "messaging.system",
      /**
       * The message destination name. This might be equal to the span name but is required nevertheless.
       */
      MESSAGING_DESTINATION: "messaging.destination",
      /**
       * The kind of message destination.
       */
      MESSAGING_DESTINATION_KIND: "messaging.destination_kind",
      /**
       * A boolean that is true if the message destination is temporary.
       */
      MESSAGING_TEMP_DESTINATION: "messaging.temp_destination",
      /**
       * The name of the transport protocol.
       */
      MESSAGING_PROTOCOL: "messaging.protocol",
      /**
       * The version of the transport protocol.
       */
      MESSAGING_PROTOCOL_VERSION: "messaging.protocol_version",
      /**
       * Connection string.
       */
      MESSAGING_URL: "messaging.url",
      /**
       * A value used by the messaging system as an identifier for the message, represented as a string.
       */
      MESSAGING_MESSAGE_ID: "messaging.message_id",
      /**
       * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.
       */
      MESSAGING_CONVERSATION_ID: "messaging.conversation_id",
      /**
       * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.
       */
      MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: "messaging.message_payload_size_bytes",
      /**
       * The compressed size of the message payload in bytes.
       */
      MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: "messaging.message_payload_compressed_size_bytes",
      /**
       * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
       */
      MESSAGING_OPERATION: "messaging.operation",
      /**
       * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.
       */
      MESSAGING_CONSUMER_ID: "messaging.consumer_id",
      /**
       * RabbitMQ message routing key.
       */
      MESSAGING_RABBITMQ_ROUTING_KEY: "messaging.rabbitmq.routing_key",
      /**
       * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.
       *
       * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.
       */
      MESSAGING_KAFKA_MESSAGE_KEY: "messaging.kafka.message_key",
      /**
       * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
       */
      MESSAGING_KAFKA_CONSUMER_GROUP: "messaging.kafka.consumer_group",
      /**
       * Client Id for the Consumer or Producer that is handling the message.
       */
      MESSAGING_KAFKA_CLIENT_ID: "messaging.kafka.client_id",
      /**
       * Partition the message is sent to.
       */
      MESSAGING_KAFKA_PARTITION: "messaging.kafka.partition",
      /**
       * A boolean that is true if the message is a tombstone.
       */
      MESSAGING_KAFKA_TOMBSTONE: "messaging.kafka.tombstone",
      /**
       * A string identifying the remoting system.
       */
      RPC_SYSTEM: "rpc.system",
      /**
       * The full (logical) name of the service being called, including its package name, if applicable.
       *
       * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).
       */
      RPC_SERVICE: "rpc.service",
      /**
       * The name of the (logical) method being called, must be equal to the $method part in the span name.
       *
       * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).
       */
      RPC_METHOD: "rpc.method",
      /**
       * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
       */
      RPC_GRPC_STATUS_CODE: "rpc.grpc.status_code",
      /**
       * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.
       */
      RPC_JSONRPC_VERSION: "rpc.jsonrpc.version",
      /**
       * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.
       */
      RPC_JSONRPC_REQUEST_ID: "rpc.jsonrpc.request_id",
      /**
       * `error.code` property of response if it is an error response.
       */
      RPC_JSONRPC_ERROR_CODE: "rpc.jsonrpc.error_code",
      /**
       * `error.message` property of response if it is an error response.
       */
      RPC_JSONRPC_ERROR_MESSAGE: "rpc.jsonrpc.error_message",
      /**
       * Whether this is a received or sent message.
       */
      MESSAGE_TYPE: "message.type",
      /**
       * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.
       *
       * Note: This way we guarantee that the values will be consistent between different implementations.
       */
      MESSAGE_ID: "message.id",
      /**
       * Compressed size of the message in bytes.
       */
      MESSAGE_COMPRESSED_SIZE: "message.compressed_size",
      /**
       * Uncompressed size of the message in bytes.
       */
      MESSAGE_UNCOMPRESSED_SIZE: "message.uncompressed_size"
    };
    exports.DbSystemValues = {
      /** Some other SQL database. Fallback only. See notes. */
      OTHER_SQL: "other_sql",
      /** Microsoft SQL Server. */
      MSSQL: "mssql",
      /** MySQL. */
      MYSQL: "mysql",
      /** Oracle Database. */
      ORACLE: "oracle",
      /** IBM Db2. */
      DB2: "db2",
      /** PostgreSQL. */
      POSTGRESQL: "postgresql",
      /** Amazon Redshift. */
      REDSHIFT: "redshift",
      /** Apache Hive. */
      HIVE: "hive",
      /** Cloudscape. */
      CLOUDSCAPE: "cloudscape",
      /** HyperSQL DataBase. */
      HSQLDB: "hsqldb",
      /** Progress Database. */
      PROGRESS: "progress",
      /** SAP MaxDB. */
      MAXDB: "maxdb",
      /** SAP HANA. */
      HANADB: "hanadb",
      /** Ingres. */
      INGRES: "ingres",
      /** FirstSQL. */
      FIRSTSQL: "firstsql",
      /** EnterpriseDB. */
      EDB: "edb",
      /** InterSystems Cach. */
      CACHE: "cache",
      /** Adabas (Adaptable Database System). */
      ADABAS: "adabas",
      /** Firebird. */
      FIREBIRD: "firebird",
      /** Apache Derby. */
      DERBY: "derby",
      /** FileMaker. */
      FILEMAKER: "filemaker",
      /** Informix. */
      INFORMIX: "informix",
      /** InstantDB. */
      INSTANTDB: "instantdb",
      /** InterBase. */
      INTERBASE: "interbase",
      /** MariaDB. */
      MARIADB: "mariadb",
      /** Netezza. */
      NETEZZA: "netezza",
      /** Pervasive PSQL. */
      PERVASIVE: "pervasive",
      /** PointBase. */
      POINTBASE: "pointbase",
      /** SQLite. */
      SQLITE: "sqlite",
      /** Sybase. */
      SYBASE: "sybase",
      /** Teradata. */
      TERADATA: "teradata",
      /** Vertica. */
      VERTICA: "vertica",
      /** H2. */
      H2: "h2",
      /** ColdFusion IMQ. */
      COLDFUSION: "coldfusion",
      /** Apache Cassandra. */
      CASSANDRA: "cassandra",
      /** Apache HBase. */
      HBASE: "hbase",
      /** MongoDB. */
      MONGODB: "mongodb",
      /** Redis. */
      REDIS: "redis",
      /** Couchbase. */
      COUCHBASE: "couchbase",
      /** CouchDB. */
      COUCHDB: "couchdb",
      /** Microsoft Azure Cosmos DB. */
      COSMOSDB: "cosmosdb",
      /** Amazon DynamoDB. */
      DYNAMODB: "dynamodb",
      /** Neo4j. */
      NEO4J: "neo4j",
      /** Apache Geode. */
      GEODE: "geode",
      /** Elasticsearch. */
      ELASTICSEARCH: "elasticsearch",
      /** Memcached. */
      MEMCACHED: "memcached",
      /** CockroachDB. */
      COCKROACHDB: "cockroachdb"
    };
    exports.DbCassandraConsistencyLevelValues = {
      /** all. */
      ALL: "all",
      /** each_quorum. */
      EACH_QUORUM: "each_quorum",
      /** quorum. */
      QUORUM: "quorum",
      /** local_quorum. */
      LOCAL_QUORUM: "local_quorum",
      /** one. */
      ONE: "one",
      /** two. */
      TWO: "two",
      /** three. */
      THREE: "three",
      /** local_one. */
      LOCAL_ONE: "local_one",
      /** any. */
      ANY: "any",
      /** serial. */
      SERIAL: "serial",
      /** local_serial. */
      LOCAL_SERIAL: "local_serial"
    };
    exports.FaasTriggerValues = {
      /** A response to some data source operation such as a database or filesystem read/write. */
      DATASOURCE: "datasource",
      /** To provide an answer to an inbound HTTP request. */
      HTTP: "http",
      /** A function is set to be executed when messages are sent to a messaging system. */
      PUBSUB: "pubsub",
      /** A function is scheduled to be executed regularly. */
      TIMER: "timer",
      /** If none of the others apply. */
      OTHER: "other"
    };
    exports.FaasDocumentOperationValues = {
      /** When a new object is created. */
      INSERT: "insert",
      /** When an object is modified. */
      EDIT: "edit",
      /** When an object is deleted. */
      DELETE: "delete"
    };
    exports.FaasInvokedProviderValues = {
      /** Alibaba Cloud. */
      ALIBABA_CLOUD: "alibaba_cloud",
      /** Amazon Web Services. */
      AWS: "aws",
      /** Microsoft Azure. */
      AZURE: "azure",
      /** Google Cloud Platform. */
      GCP: "gcp"
    };
    exports.NetTransportValues = {
      /** ip_tcp. */
      IP_TCP: "ip_tcp",
      /** ip_udp. */
      IP_UDP: "ip_udp",
      /** Another IP-based protocol. */
      IP: "ip",
      /** Unix Domain socket. See below. */
      UNIX: "unix",
      /** Named or anonymous pipe. See note below. */
      PIPE: "pipe",
      /** In-process communication. */
      INPROC: "inproc",
      /** Something else (non IP-based). */
      OTHER: "other"
    };
    exports.NetHostConnectionTypeValues = {
      /** wifi. */
      WIFI: "wifi",
      /** wired. */
      WIRED: "wired",
      /** cell. */
      CELL: "cell",
      /** unavailable. */
      UNAVAILABLE: "unavailable",
      /** unknown. */
      UNKNOWN: "unknown"
    };
    exports.NetHostConnectionSubtypeValues = {
      /** GPRS. */
      GPRS: "gprs",
      /** EDGE. */
      EDGE: "edge",
      /** UMTS. */
      UMTS: "umts",
      /** CDMA. */
      CDMA: "cdma",
      /** EVDO Rel. 0. */
      EVDO_0: "evdo_0",
      /** EVDO Rev. A. */
      EVDO_A: "evdo_a",
      /** CDMA2000 1XRTT. */
      CDMA2000_1XRTT: "cdma2000_1xrtt",
      /** HSDPA. */
      HSDPA: "hsdpa",
      /** HSUPA. */
      HSUPA: "hsupa",
      /** HSPA. */
      HSPA: "hspa",
      /** IDEN. */
      IDEN: "iden",
      /** EVDO Rev. B. */
      EVDO_B: "evdo_b",
      /** LTE. */
      LTE: "lte",
      /** EHRPD. */
      EHRPD: "ehrpd",
      /** HSPAP. */
      HSPAP: "hspap",
      /** GSM. */
      GSM: "gsm",
      /** TD-SCDMA. */
      TD_SCDMA: "td_scdma",
      /** IWLAN. */
      IWLAN: "iwlan",
      /** 5G NR (New Radio). */
      NR: "nr",
      /** 5G NRNSA (New Radio Non-Standalone). */
      NRNSA: "nrnsa",
      /** LTE CA. */
      LTE_CA: "lte_ca"
    };
    exports.HttpFlavorValues = {
      /** HTTP 1.0. */
      HTTP_1_0: "1.0",
      /** HTTP 1.1. */
      HTTP_1_1: "1.1",
      /** HTTP 2. */
      HTTP_2_0: "2.0",
      /** SPDY protocol. */
      SPDY: "SPDY",
      /** QUIC protocol. */
      QUIC: "QUIC"
    };
    exports.MessagingDestinationKindValues = {
      /** A message sent to a queue. */
      QUEUE: "queue",
      /** A message sent to a topic. */
      TOPIC: "topic"
    };
    exports.MessagingOperationValues = {
      /** receive. */
      RECEIVE: "receive",
      /** process. */
      PROCESS: "process"
    };
    exports.RpcGrpcStatusCodeValues = {
      /** OK. */
      OK: 0,
      /** CANCELLED. */
      CANCELLED: 1,
      /** UNKNOWN. */
      UNKNOWN: 2,
      /** INVALID_ARGUMENT. */
      INVALID_ARGUMENT: 3,
      /** DEADLINE_EXCEEDED. */
      DEADLINE_EXCEEDED: 4,
      /** NOT_FOUND. */
      NOT_FOUND: 5,
      /** ALREADY_EXISTS. */
      ALREADY_EXISTS: 6,
      /** PERMISSION_DENIED. */
      PERMISSION_DENIED: 7,
      /** RESOURCE_EXHAUSTED. */
      RESOURCE_EXHAUSTED: 8,
      /** FAILED_PRECONDITION. */
      FAILED_PRECONDITION: 9,
      /** ABORTED. */
      ABORTED: 10,
      /** OUT_OF_RANGE. */
      OUT_OF_RANGE: 11,
      /** UNIMPLEMENTED. */
      UNIMPLEMENTED: 12,
      /** INTERNAL. */
      INTERNAL: 13,
      /** UNAVAILABLE. */
      UNAVAILABLE: 14,
      /** DATA_LOSS. */
      DATA_LOSS: 15,
      /** UNAUTHENTICATED. */
      UNAUTHENTICATED: 16
    };
    exports.MessageTypeValues = {
      /** sent. */
      SENT: "SENT",
      /** received. */
      RECEIVED: "RECEIVED"
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.0/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.0/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_SemanticAttributes2(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.0/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.0/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TelemetrySdkLanguageValues = exports.OsTypeValues = exports.HostArchValues = exports.AwsEcsLaunchtypeValues = exports.CloudPlatformValues = exports.CloudProviderValues = exports.SemanticResourceAttributes = void 0;
    exports.SemanticResourceAttributes = {
      /**
       * Name of the cloud provider.
       */
      CLOUD_PROVIDER: "cloud.provider",
      /**
       * The cloud account ID the resource is assigned to.
       */
      CLOUD_ACCOUNT_ID: "cloud.account.id",
      /**
       * The geographical region the resource is running. Refer to your provider&#39;s docs to see the available regions, for example [Alibaba Cloud regions](https://www.alibabacloud.com/help/doc-detail/40654.htm), [AWS regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/), [Azure regions](https://azure.microsoft.com/en-us/global-infrastructure/geographies/), or [Google Cloud regions](https://cloud.google.com/about/locations).
       */
      CLOUD_REGION: "cloud.region",
      /**
       * Cloud regions often have multiple, isolated locations known as zones to increase availability. Availability zone represents the zone where the resource is running.
       *
       * Note: Availability zones are called &#34;zones&#34; on Alibaba Cloud and Google Cloud.
       */
      CLOUD_AVAILABILITY_ZONE: "cloud.availability_zone",
      /**
       * The cloud platform in use.
       *
       * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
       */
      CLOUD_PLATFORM: "cloud.platform",
      /**
       * The Amazon Resource Name (ARN) of an [ECS container instance](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html).
       */
      AWS_ECS_CONTAINER_ARN: "aws.ecs.container.arn",
      /**
       * The ARN of an [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html).
       */
      AWS_ECS_CLUSTER_ARN: "aws.ecs.cluster.arn",
      /**
       * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
       */
      AWS_ECS_LAUNCHTYPE: "aws.ecs.launchtype",
      /**
       * The ARN of an [ECS task definition](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html).
       */
      AWS_ECS_TASK_ARN: "aws.ecs.task.arn",
      /**
       * The task definition family this task definition is a member of.
       */
      AWS_ECS_TASK_FAMILY: "aws.ecs.task.family",
      /**
       * The revision for this task definition.
       */
      AWS_ECS_TASK_REVISION: "aws.ecs.task.revision",
      /**
       * The ARN of an EKS cluster.
       */
      AWS_EKS_CLUSTER_ARN: "aws.eks.cluster.arn",
      /**
       * The name(s) of the AWS log group(s) an application is writing to.
       *
       * Note: Multiple log groups must be supported for cases like multi-container applications, where a single application has sidecar containers, and each write to their own log group.
       */
      AWS_LOG_GROUP_NAMES: "aws.log.group.names",
      /**
       * The Amazon Resource Name(s) (ARN) of the AWS log group(s).
       *
       * Note: See the [log group ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format).
       */
      AWS_LOG_GROUP_ARNS: "aws.log.group.arns",
      /**
       * The name(s) of the AWS log stream(s) an application is writing to.
       */
      AWS_LOG_STREAM_NAMES: "aws.log.stream.names",
      /**
       * The ARN(s) of the AWS log stream(s).
       *
       * Note: See the [log stream ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format). One log group can contain several log streams, so these ARNs necessarily identify both a log group and a log stream.
       */
      AWS_LOG_STREAM_ARNS: "aws.log.stream.arns",
      /**
       * Container name.
       */
      CONTAINER_NAME: "container.name",
      /**
       * Container ID. Usually a UUID, as for example used to [identify Docker containers](https://docs.docker.com/engine/reference/run/#container-identification). The UUID might be abbreviated.
       */
      CONTAINER_ID: "container.id",
      /**
       * The container runtime managing this container.
       */
      CONTAINER_RUNTIME: "container.runtime",
      /**
       * Name of the image the container was built on.
       */
      CONTAINER_IMAGE_NAME: "container.image.name",
      /**
       * Container image tag.
       */
      CONTAINER_IMAGE_TAG: "container.image.tag",
      /**
       * Name of the [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
       */
      DEPLOYMENT_ENVIRONMENT: "deployment.environment",
      /**
       * A unique identifier representing the device.
       *
       * Note: The device identifier MUST only be defined using the values outlined below. This value is not an advertising identifier and MUST NOT be used as such. On iOS (Swift or Objective-C), this value MUST be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor). On Android (Java or Kotlin), this value MUST be equal to the Firebase Installation ID or a globally unique UUID which is persisted across sessions in your application. More information can be found [here](https://developer.android.com/training/articles/user-data-ids) on best practices and exact implementation details. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply, ensure you do your own due diligence.
       */
      DEVICE_ID: "device.id",
      /**
       * The model identifier for the device.
       *
       * Note: It&#39;s recommended this value represents a machine readable version of the model identifier rather than the market or consumer-friendly name of the device.
       */
      DEVICE_MODEL_IDENTIFIER: "device.model.identifier",
      /**
       * The marketing name for the device model.
       *
       * Note: It&#39;s recommended this value represents a human readable version of the device model rather than a machine readable alternative.
       */
      DEVICE_MODEL_NAME: "device.model.name",
      /**
       * The name of the single function that this runtime instance executes.
       *
       * Note: This is the name of the function as configured/deployed on the FaaS platform and is usually different from the name of the callback function (which may be stored in the [`code.namespace`/`code.function`](../../trace/semantic_conventions/span-general.md#source-code-attributes) span attributes).
       */
      FAAS_NAME: "faas.name",
      /**
        * The unique ID of the single function that this runtime instance executes.
        *
        * Note: Depending on the cloud provider, use:
      
      * **AWS Lambda:** The function [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
      Take care not to use the &#34;invoked ARN&#34; directly but replace any
      [alias suffix](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html) with the resolved function version, as the same runtime instance may be invokable with multiple
      different aliases.
      * **GCP:** The [URI of the resource](https://cloud.google.com/iam/docs/full-resource-names)
      * **Azure:** The [Fully Qualified Resource ID](https://docs.microsoft.com/en-us/rest/api/resources/resources/get-by-id).
      
      On some providers, it may not be possible to determine the full ID at startup,
      which is why this field cannot be made required. For example, on AWS the account ID
      part of the ARN is not available without calling another AWS API
      which may be deemed too slow for a short-running lambda function.
      As an alternative, consider setting `faas.id` as a span attribute instead.
        */
      FAAS_ID: "faas.id",
      /**
        * The immutable version of the function being executed.
        *
        * Note: Depending on the cloud provider and platform, use:
      
      * **AWS Lambda:** The [function version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
        (an integer represented as a decimal string).
      * **Google Cloud Run:** The [revision](https://cloud.google.com/run/docs/managing/revisions)
        (i.e., the function name plus the revision suffix).
      * **Google Cloud Functions:** The value of the
        [`K_REVISION` environment variable](https://cloud.google.com/functions/docs/env-var#runtime_environment_variables_set_automatically).
      * **Azure Functions:** Not applicable. Do not set this attribute.
        */
      FAAS_VERSION: "faas.version",
      /**
       * The execution environment ID as a string, that will be potentially reused for other invocations to the same function/function version.
       *
       * Note: * **AWS Lambda:** Use the (full) log stream name.
       */
      FAAS_INSTANCE: "faas.instance",
      /**
       * The amount of memory available to the serverless function in MiB.
       *
       * Note: It&#39;s recommended to set this attribute since e.g. too little memory can easily stop a Java AWS Lambda function from working correctly. On AWS Lambda, the environment variable `AWS_LAMBDA_FUNCTION_MEMORY_SIZE` provides this information.
       */
      FAAS_MAX_MEMORY: "faas.max_memory",
      /**
       * Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider.
       */
      HOST_ID: "host.id",
      /**
       * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
       */
      HOST_NAME: "host.name",
      /**
       * Type of host. For Cloud, this must be the machine type.
       */
      HOST_TYPE: "host.type",
      /**
       * The CPU architecture the host system is running on.
       */
      HOST_ARCH: "host.arch",
      /**
       * Name of the VM image or OS install the host was instantiated from.
       */
      HOST_IMAGE_NAME: "host.image.name",
      /**
       * VM image ID. For Cloud, this value is from the provider.
       */
      HOST_IMAGE_ID: "host.image.id",
      /**
       * The version string of the VM image as defined in [Version SpanAttributes](README.md#version-attributes).
       */
      HOST_IMAGE_VERSION: "host.image.version",
      /**
       * The name of the cluster.
       */
      K8S_CLUSTER_NAME: "k8s.cluster.name",
      /**
       * The name of the Node.
       */
      K8S_NODE_NAME: "k8s.node.name",
      /**
       * The UID of the Node.
       */
      K8S_NODE_UID: "k8s.node.uid",
      /**
       * The name of the namespace that the pod is running in.
       */
      K8S_NAMESPACE_NAME: "k8s.namespace.name",
      /**
       * The UID of the Pod.
       */
      K8S_POD_UID: "k8s.pod.uid",
      /**
       * The name of the Pod.
       */
      K8S_POD_NAME: "k8s.pod.name",
      /**
       * The name of the Container in a Pod template.
       */
      K8S_CONTAINER_NAME: "k8s.container.name",
      /**
       * The UID of the ReplicaSet.
       */
      K8S_REPLICASET_UID: "k8s.replicaset.uid",
      /**
       * The name of the ReplicaSet.
       */
      K8S_REPLICASET_NAME: "k8s.replicaset.name",
      /**
       * The UID of the Deployment.
       */
      K8S_DEPLOYMENT_UID: "k8s.deployment.uid",
      /**
       * The name of the Deployment.
       */
      K8S_DEPLOYMENT_NAME: "k8s.deployment.name",
      /**
       * The UID of the StatefulSet.
       */
      K8S_STATEFULSET_UID: "k8s.statefulset.uid",
      /**
       * The name of the StatefulSet.
       */
      K8S_STATEFULSET_NAME: "k8s.statefulset.name",
      /**
       * The UID of the DaemonSet.
       */
      K8S_DAEMONSET_UID: "k8s.daemonset.uid",
      /**
       * The name of the DaemonSet.
       */
      K8S_DAEMONSET_NAME: "k8s.daemonset.name",
      /**
       * The UID of the Job.
       */
      K8S_JOB_UID: "k8s.job.uid",
      /**
       * The name of the Job.
       */
      K8S_JOB_NAME: "k8s.job.name",
      /**
       * The UID of the CronJob.
       */
      K8S_CRONJOB_UID: "k8s.cronjob.uid",
      /**
       * The name of the CronJob.
       */
      K8S_CRONJOB_NAME: "k8s.cronjob.name",
      /**
       * The operating system type.
       */
      OS_TYPE: "os.type",
      /**
       * Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands.
       */
      OS_DESCRIPTION: "os.description",
      /**
       * Human readable operating system name.
       */
      OS_NAME: "os.name",
      /**
       * The version string of the operating system as defined in [Version SpanAttributes](../../resource/semantic_conventions/README.md#version-attributes).
       */
      OS_VERSION: "os.version",
      /**
       * Process identifier (PID).
       */
      PROCESS_PID: "process.pid",
      /**
       * The name of the process executable. On Linux based systems, can be set to the `Name` in `proc/[pid]/status`. On Windows, can be set to the base name of `GetProcessImageFileNameW`.
       */
      PROCESS_EXECUTABLE_NAME: "process.executable.name",
      /**
       * The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`.
       */
      PROCESS_EXECUTABLE_PATH: "process.executable.path",
      /**
       * The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`.
       */
      PROCESS_COMMAND: "process.command",
      /**
       * The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead.
       */
      PROCESS_COMMAND_LINE: "process.command_line",
      /**
       * All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`.
       */
      PROCESS_COMMAND_ARGS: "process.command_args",
      /**
       * The username of the user that owns the process.
       */
      PROCESS_OWNER: "process.owner",
      /**
       * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
       */
      PROCESS_RUNTIME_NAME: "process.runtime.name",
      /**
       * The version of the runtime of this process, as returned by the runtime without modification.
       */
      PROCESS_RUNTIME_VERSION: "process.runtime.version",
      /**
       * An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment.
       */
      PROCESS_RUNTIME_DESCRIPTION: "process.runtime.description",
      /**
       * Logical name of the service.
       *
       * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
       */
      SERVICE_NAME: "service.name",
      /**
       * A namespace for `service.name`.
       *
       * Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
       */
      SERVICE_NAMESPACE: "service.namespace",
      /**
       * The string ID of the service instance.
       *
       * Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled service). It is preferable for the ID to be persistent and stay the same for the lifetime of the service instance, however it is acceptable that the ID is ephemeral and changes during important lifetime events for the service (e.g. service restarts). If the service has no inherent unique ID that can be used as the value of this attribute it is recommended to generate a random Version 1 or Version 4 RFC 4122 UUID (services aiming for reproducible UUIDs may also use Version 5, see RFC 4122 for more recommendations).
       */
      SERVICE_INSTANCE_ID: "service.instance.id",
      /**
       * The version string of the service API or implementation.
       */
      SERVICE_VERSION: "service.version",
      /**
       * The name of the telemetry SDK as defined above.
       */
      TELEMETRY_SDK_NAME: "telemetry.sdk.name",
      /**
       * The language of the telemetry SDK.
       */
      TELEMETRY_SDK_LANGUAGE: "telemetry.sdk.language",
      /**
       * The version string of the telemetry SDK.
       */
      TELEMETRY_SDK_VERSION: "telemetry.sdk.version",
      /**
       * The version string of the auto instrumentation agent, if used.
       */
      TELEMETRY_AUTO_VERSION: "telemetry.auto.version",
      /**
       * The name of the web engine.
       */
      WEBENGINE_NAME: "webengine.name",
      /**
       * The version of the web engine.
       */
      WEBENGINE_VERSION: "webengine.version",
      /**
       * Additional description of the web engine (e.g. detailed version and edition information).
       */
      WEBENGINE_DESCRIPTION: "webengine.description"
    };
    exports.CloudProviderValues = {
      /** Alibaba Cloud. */
      ALIBABA_CLOUD: "alibaba_cloud",
      /** Amazon Web Services. */
      AWS: "aws",
      /** Microsoft Azure. */
      AZURE: "azure",
      /** Google Cloud Platform. */
      GCP: "gcp"
    };
    exports.CloudPlatformValues = {
      /** Alibaba Cloud Elastic Compute Service. */
      ALIBABA_CLOUD_ECS: "alibaba_cloud_ecs",
      /** Alibaba Cloud Function Compute. */
      ALIBABA_CLOUD_FC: "alibaba_cloud_fc",
      /** AWS Elastic Compute Cloud. */
      AWS_EC2: "aws_ec2",
      /** AWS Elastic Container Service. */
      AWS_ECS: "aws_ecs",
      /** AWS Elastic Kubernetes Service. */
      AWS_EKS: "aws_eks",
      /** AWS Lambda. */
      AWS_LAMBDA: "aws_lambda",
      /** AWS Elastic Beanstalk. */
      AWS_ELASTIC_BEANSTALK: "aws_elastic_beanstalk",
      /** Azure Virtual Machines. */
      AZURE_VM: "azure_vm",
      /** Azure Container Instances. */
      AZURE_CONTAINER_INSTANCES: "azure_container_instances",
      /** Azure Kubernetes Service. */
      AZURE_AKS: "azure_aks",
      /** Azure Functions. */
      AZURE_FUNCTIONS: "azure_functions",
      /** Azure App Service. */
      AZURE_APP_SERVICE: "azure_app_service",
      /** Google Cloud Compute Engine (GCE). */
      GCP_COMPUTE_ENGINE: "gcp_compute_engine",
      /** Google Cloud Run. */
      GCP_CLOUD_RUN: "gcp_cloud_run",
      /** Google Cloud Kubernetes Engine (GKE). */
      GCP_KUBERNETES_ENGINE: "gcp_kubernetes_engine",
      /** Google Cloud Functions (GCF). */
      GCP_CLOUD_FUNCTIONS: "gcp_cloud_functions",
      /** Google Cloud App Engine (GAE). */
      GCP_APP_ENGINE: "gcp_app_engine"
    };
    exports.AwsEcsLaunchtypeValues = {
      /** ec2. */
      EC2: "ec2",
      /** fargate. */
      FARGATE: "fargate"
    };
    exports.HostArchValues = {
      /** AMD64. */
      AMD64: "amd64",
      /** ARM32. */
      ARM32: "arm32",
      /** ARM64. */
      ARM64: "arm64",
      /** Itanium. */
      IA64: "ia64",
      /** 32-bit PowerPC. */
      PPC32: "ppc32",
      /** 64-bit PowerPC. */
      PPC64: "ppc64",
      /** 32-bit x86. */
      X86: "x86"
    };
    exports.OsTypeValues = {
      /** Microsoft Windows. */
      WINDOWS: "windows",
      /** Linux. */
      LINUX: "linux",
      /** Apple Darwin. */
      DARWIN: "darwin",
      /** FreeBSD. */
      FREEBSD: "freebsd",
      /** NetBSD. */
      NETBSD: "netbsd",
      /** OpenBSD. */
      OPENBSD: "openbsd",
      /** DragonFly BSD. */
      DRAGONFLYBSD: "dragonflybsd",
      /** HP-UX (Hewlett Packard Unix). */
      HPUX: "hpux",
      /** AIX (Advanced Interactive eXecutive). */
      AIX: "aix",
      /** Oracle Solaris. */
      SOLARIS: "solaris",
      /** IBM z/OS. */
      Z_OS: "z_os"
    };
    exports.TelemetrySdkLanguageValues = {
      /** cpp. */
      CPP: "cpp",
      /** dotnet. */
      DOTNET: "dotnet",
      /** erlang. */
      ERLANG: "erlang",
      /** go. */
      GO: "go",
      /** java. */
      JAVA: "java",
      /** nodejs. */
      NODEJS: "nodejs",
      /** php. */
      PHP: "php",
      /** python. */
      PYTHON: "python",
      /** ruby. */
      RUBY: "ruby",
      /** webjs. */
      WEBJS: "webjs"
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.0/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.0/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_SemanticResourceAttributes2(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.0/node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src6 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.17.0/node_modules/@opentelemetry/semantic-conventions/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_trace3(), exports);
    __exportStar(require_resource2(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.SDK_INFO = void 0;
    var version_1 = require_version3(), semantic_conventions_1 = require_src6();
    exports.SDK_INFO = {
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TelemetrySdkLanguageValues.NODEJS,
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports.unrefTimer = unrefTimer;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_environment4(), exports);
    __exportStar(require_globalThis5(), exports);
    __exportStar(require_hex_to_base642(), exports);
    __exportStar(require_RandomIdGenerator2(), exports);
    __exportStar(require_performance2(), exports);
    __exportStar(require_sdk_info2(), exports);
    __exportStar(require_timer_util2(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/platform/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_node4(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/time.js
var require_time2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/time.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = void 0;
    var platform_1 = require_platform4(), NANOSECOND_DIGITS = 9, NANOSECOND_DIGITS_IN_MILLIS = 6, MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS), SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      let epochSeconds = epochMillis / 1e3, seconds = Math.trunc(epochSeconds), nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin != "number") {
        let perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      let timeOrigin = millisToHrTime(getTimeOrigin()), now = millisToHrTime(typeof performanceNow == "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time))
        return time;
      if (typeof time == "number")
        return time < getTimeOrigin() ? hrTime(time) : millisToHrTime(time);
      if (time instanceof Date)
        return millisToHrTime(time.getTime());
      throw TypeError("Invalid input type");
    }
    exports.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0], nanos = endTime[1] - startTime[1];
      return nanos < 0 && (seconds -= 1, nanos += SECOND_TO_NANOSECONDS), [seconds, nanos];
    }
    exports.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      let precision = NANOSECOND_DIGITS, tmp = `${"0".repeat(precision)}${time[1]}Z`, nanoString = tmp.substr(tmp.length - precision - 1);
      return new Date(time[0] * 1e3).toISOString().replace("000Z", nanoString);
    }
    exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] == "number" && typeof value[1] == "number";
    }
    exports.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value == "number" || value instanceof Date;
    }
    exports.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      let out = [time1[0] + time2[0], time1[1] + time2[1]];
      return out[1] >= SECOND_TO_NANOSECONDS && (out[1] -= SECOND_TO_NANOSECONDS, out[0] += 1), out;
    }
    exports.addHrTimes = addHrTimes;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/types.js
var require_types6 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/common/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ExportResultCode = void 0;
    var ExportResultCode2;
    (function(ExportResultCode3) {
      ExportResultCode3[ExportResultCode3.SUCCESS = 0] = "SUCCESS", ExportResultCode3[ExportResultCode3.FAILED = 1] = "FAILED";
    })(ExportResultCode2 = exports.ExportResultCode || (exports.ExportResultCode = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.CompositePropagator = void 0;
    var api_1 = require_src(), CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [], this._fields = Array.from(new Set(this._propagators.map((p) => typeof p.fields == "function" ? p.fields() : []).reduce((x, y) => x.concat(y), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context, carrier, setter) {
        for (let propagator of this._propagators)
          try {
            propagator.inject(context, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports.CompositePropagator = CompositePropagator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]", VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`, VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`, VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`), VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/, INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    exports.validateKey = validateKey;
    function validateValue(value) {
      return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
    }
    exports.validateValue = validateValue;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TraceState = void 0;
    var validators_1 = require_validators2(), MAX_TRACE_STATE_ITEMS = 32, MAX_TRACE_STATE_LEN = 512, LIST_MEMBERS_SEPARATOR = ",", LIST_MEMBER_KEY_VALUE_SPLITTER = "=", TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map(), rawTraceState && this._parse(rawTraceState);
      }
      set(key, value) {
        let traceState = this._clone();
        return traceState._internalState.has(key) && traceState._internalState.delete(key), traceState._internalState.set(key, value), traceState;
      }
      unset(key) {
        let traceState = this._clone();
        return traceState._internalState.delete(key), traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => (agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key)), agg), []).join(LIST_MEMBERS_SEPARATOR);
      }
      _parse(rawTraceState) {
        rawTraceState.length > MAX_TRACE_STATE_LEN || (this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
          let listMember = part.trim(), i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            let key = listMember.slice(0, i), value = listMember.slice(i + 1, part.length);
            (0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value) && agg.set(key, value);
          }
          return agg;
        }, /* @__PURE__ */ new Map()), this._internalState.size > MAX_TRACE_STATE_ITEMS && (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS))));
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        let traceState = new _TraceState();
        return traceState._internalState = new Map(this._internalState), traceState;
      }
    };
    exports.TraceState = TraceState;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = void 0;
    var api_1 = require_src(), suppress_tracing_1 = require_suppress_tracing2(), TraceState_1 = require_TraceState2();
    exports.TRACE_PARENT_HEADER = "traceparent";
    exports.TRACE_STATE_HEADER = "tracestate";
    var VERSION = "00", VERSION_PART = "(?!ff)[\\da-f]{2}", TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}", PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}", FLAGS_PART = "[\\da-f]{2}", TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      let match = TRACE_PARENT_REGEX.exec(traceParent);
      return !match || match[1] === "00" && match[5] ? null : {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    exports.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context, carrier, setter) {
        let spanContext = api_1.trace.getSpanContext(context);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        let traceParent = `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent), spanContext.traceState && setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
      }
      extract(context, carrier, getter) {
        let traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context;
        let traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent != "string")
          return context;
        let spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context;
        spanContext.isRemote = !0;
        let traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          let state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state == "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context, spanContext);
      }
      fields() {
        return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
      }
    };
    exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js
var require_IdGenerator2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = void 0;
    var api_1 = require_src(), RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA"), RPCType;
    (function(RPCType2) {
      RPCType2.HTTP = "http";
    })(RPCType = exports.RPCType || (exports.RPCType = {}));
    function setRPCMetadata(context, meta) {
      return context.setValue(RPC_METADATA_KEY, meta);
    }
    exports.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context) {
      return context.deleteValue(RPC_METADATA_KEY);
    }
    exports.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context) {
      return context.getValue(RPC_METADATA_KEY);
    }
    exports.getRPCMetadata = getRPCMetadata;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AlwaysOffSampler = void 0;
    var api_1 = require_src(), AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AlwaysOnSampler = void 0;
    var api_1 = require_src(), AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ParentBasedSampler = void 0;
    var api_1 = require_src(), global_error_handler_1 = require_global_error_handler2(), AlwaysOffSampler_1 = require_AlwaysOffSampler2(), AlwaysOnSampler_1 = require_AlwaysOnSampler2(), ParentBasedSampler = class {
      constructor(config) {
        var _a, _b, _c, _d;
        this._root = config.root, this._root || ((0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured")), this._root = new AlwaysOnSampler_1.AlwaysOnSampler()), this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler(), this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler(), this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler(), this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        let parentContext = api_1.trace.getSpanContext(context);
        return !parentContext || !(0, api_1.isSpanContextValid)(parentContext) ? this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links) : parentContext.isRemote ? parentContext.traceFlags & api_1.TraceFlags.SAMPLED ? this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : parentContext.traceFlags & api_1.TraceFlags.SAMPLED ? this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports.ParentBasedSampler = ParentBasedSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TraceIdRatioBasedSampler = void 0;
    var api_1 = require_src(), TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio, this._ratio = this._normalize(_ratio), this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        return typeof ratio != "number" || isNaN(ratio) ? 0 : ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
          let pos = i * 8, part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isPlainObject = void 0;
    var objectTag = "[object Object]", nullTag = "[object Null]", undefinedTag = "[object Undefined]", funcProto = Function.prototype, funcToString = funcProto.toString, objectCtorString = funcToString.call(Object), getPrototype = overArg(Object.getPrototypeOf, Object), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, symToStringTag = Symbol ? Symbol.toStringTag : void 0, nativeObjectToString = objectProto.toString;
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag)
        return !1;
      let proto = getPrototype(value);
      if (proto === null)
        return !0;
      let Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      return value == null ? value === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      let isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag], unmasked = !1;
      try {
        value[symToStringTag] = void 0, unmasked = !0;
      } catch {
      }
      let result = nativeObjectToString.call(value);
      return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.merge = void 0;
    var lodash_merge_1 = require_lodash_merge2(), MAX_LEVEL = 20;
    function merge(...args) {
      let result = args.shift(), objects = /* @__PURE__ */ new WeakMap();
      for (; args.length > 0; )
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      return result;
    }
    exports.merge = merge;
    function takeValue(value) {
      return isArray(value) ? value.slice() : value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result;
      if (!(level > MAX_LEVEL)) {
        if (level++, isPrimitive(one) || isPrimitive(two) || isFunction(two))
          result = takeValue(two);
        else if (isArray(one)) {
          if (result = one.slice(), isArray(two))
            for (let i = 0, j = two.length; i < j; i++)
              result.push(takeValue(two[i]));
          else if (isObject(two)) {
            let keys = Object.keys(two);
            for (let i = 0, j = keys.length; i < j; i++) {
              let key = keys[i];
              result[key] = takeValue(two[key]);
            }
          }
        } else if (isObject(one))
          if (isObject(two)) {
            if (!shouldMerge(one, two))
              return two;
            result = Object.assign({}, one);
            let keys = Object.keys(two);
            for (let i = 0, j = keys.length; i < j; i++) {
              let key = keys[i], twoValue = two[key];
              if (isPrimitive(twoValue))
                typeof twoValue > "u" ? delete result[key] : result[key] = twoValue;
              else {
                let obj1 = result[key], obj2 = twoValue;
                if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects))
                  delete result[key];
                else {
                  if (isObject(obj1) && isObject(obj2)) {
                    let arr1 = objects.get(obj1) || [], arr2 = objects.get(obj2) || [];
                    arr1.push({ obj: one, key }), arr2.push({ obj: two, key }), objects.set(obj1, arr1), objects.set(obj2, arr2);
                  }
                  result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
                }
              }
            }
          } else
            result = two;
        return result;
      }
    }
    function wasObjectReferenced(obj, key, objects) {
      let arr = objects.get(obj[key]) || [];
      for (let i = 0, j = arr.length; i < j; i++) {
        let info = arr[i];
        if (info.key === key && info.obj === obj)
          return !0;
      }
      return !1;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value == "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value == "object";
    }
    function isPrimitive(value) {
      return typeof value == "string" || typeof value == "number" || typeof value == "boolean" || typeof value > "u" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      return !(!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two));
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.callWithTimeout = exports.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message), Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout) {
      let timeoutHandle, timeoutPromise = new Promise(function(_resolve, reject) {
        timeoutHandle = setTimeout(function() {
          reject(new TimeoutError("Operation timed out."));
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => (clearTimeout(timeoutHandle), result), (reason) => {
        throw clearTimeout(timeoutHandle), reason;
      });
    }
    exports.callWithTimeout = callWithTimeout;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/url.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isUrlIgnored = exports.urlMatches = void 0;
    function urlMatches(url2, urlToMatch) {
      return typeof urlToMatch == "string" ? url2 === urlToMatch : !!url2.match(urlToMatch);
    }
    exports.urlMatches = urlMatches;
    function isUrlIgnored(url2, ignoredUrls) {
      if (!ignoredUrls)
        return !1;
      for (let ignoreUrl of ignoredUrls)
        if (urlMatches(url2, ignoreUrl))
          return !0;
      return !1;
    }
    exports.isUrlIgnored = isUrlIgnored;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isWrapped = void 0;
    function isWrapped(func) {
      return typeof func == "function" && typeof func.__original == "function" && typeof func.__unwrap == "function" && func.__wrapped === !0;
    }
    exports.isWrapped = isWrapped;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve, this._reject = reject;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports.Deferred = Deferred;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.BindOnceFuture = void 0;
    var promise_1 = require_promise2(), BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback, this._that = _that, this._isCalled = !1, this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = !0;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports.BindOnceFuture = BindOnceFuture;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports._export = void 0;
    var api_1 = require_src(), suppress_tracing_1 = require_suppress_tracing2();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result) => {
            resolve(result);
          });
        });
      });
    }
    exports._export = _export;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/index.js
var require_src7 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/core/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.internal = exports.baggageUtils = void 0;
    __exportStar(require_W3CBaggagePropagator2(), exports);
    __exportStar(require_anchored_clock2(), exports);
    __exportStar(require_attributes2(), exports);
    __exportStar(require_global_error_handler2(), exports);
    __exportStar(require_logging_error_handler2(), exports);
    __exportStar(require_time2(), exports);
    __exportStar(require_types6(), exports);
    __exportStar(require_ExportResult2(), exports);
    __exportStar(require_version3(), exports);
    exports.baggageUtils = require_utils7();
    __exportStar(require_platform4(), exports);
    __exportStar(require_composite2(), exports);
    __exportStar(require_W3CTraceContextPropagator2(), exports);
    __exportStar(require_IdGenerator2(), exports);
    __exportStar(require_rpc_metadata2(), exports);
    __exportStar(require_AlwaysOffSampler2(), exports);
    __exportStar(require_AlwaysOnSampler2(), exports);
    __exportStar(require_ParentBasedSampler2(), exports);
    __exportStar(require_TraceIdRatioBasedSampler2(), exports);
    __exportStar(require_suppress_tracing2(), exports);
    __exportStar(require_TraceState2(), exports);
    __exportStar(require_environment3(), exports);
    __exportStar(require_merge2(), exports);
    __exportStar(require_sampling2(), exports);
    __exportStar(require_timeout2(), exports);
    __exportStar(require_url2(), exports);
    __exportStar(require_wrap2(), exports);
    __exportStar(require_callback2(), exports);
    __exportStar(require_version3(), exports);
    var exporter_1 = require_exporter2();
    exports.internal = {
      _export: exporter_1._export
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationTemporality.js
var require_AggregationTemporality2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationTemporality.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AggregationTemporality = void 0;
    var AggregationTemporality2;
    (function(AggregationTemporality3) {
      AggregationTemporality3[AggregationTemporality3.DELTA = 0] = "DELTA", AggregationTemporality3[AggregationTemporality3.CUMULATIVE = 1] = "CUMULATIVE";
    })(AggregationTemporality2 = exports.AggregationTemporality || (exports.AggregationTemporality = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricData.js
var require_MetricData2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricData.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DataPointType = void 0;
    var DataPointType;
    (function(DataPointType2) {
      DataPointType2[DataPointType2.HISTOGRAM = 0] = "HISTOGRAM", DataPointType2[DataPointType2.EXPONENTIAL_HISTOGRAM = 1] = "EXPONENTIAL_HISTOGRAM", DataPointType2[DataPointType2.GAUGE = 2] = "GAUGE", DataPointType2[DataPointType2.SUM = 3] = "SUM";
    })(DataPointType = exports.DataPointType || (exports.DataPointType = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/utils.js
var require_utils8 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.equalsCaseInsensitive = exports.binarySearchLB = exports.setEquals = exports.FlatMap = exports.isPromiseAllSettledRejectionResult = exports.PromiseAllSettled = exports.callWithTimeout = exports.TimeoutError = exports.instrumentationScopeId = exports.hashAttributes = exports.isNotNullish = void 0;
    function isNotNullish(item) {
      return item != null;
    }
    exports.isNotNullish = isNotNullish;
    function hashAttributes(attributes) {
      let keys = Object.keys(attributes);
      return keys.length === 0 ? "" : (keys = keys.sort(), JSON.stringify(keys.map((key) => [key, attributes[key]])));
    }
    exports.hashAttributes = hashAttributes;
    function instrumentationScopeId(instrumentationScope2) {
      var _a, _b;
      return `${instrumentationScope2.name}:${(_a = instrumentationScope2.version) !== null && _a !== void 0 ? _a : ""}:${(_b = instrumentationScope2.schemaUrl) !== null && _b !== void 0 ? _b : ""}`;
    }
    exports.instrumentationScopeId = instrumentationScopeId;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message), Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout) {
      let timeoutHandle, timeoutPromise = new Promise(function(_resolve, reject) {
        timeoutHandle = setTimeout(function() {
          reject(new TimeoutError("Operation timed out."));
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => (clearTimeout(timeoutHandle), result), (reason) => {
        throw clearTimeout(timeoutHandle), reason;
      });
    }
    exports.callWithTimeout = callWithTimeout;
    async function PromiseAllSettled(promises) {
      return Promise.all(promises.map(async (p) => {
        try {
          return {
            status: "fulfilled",
            value: await p
          };
        } catch (e) {
          return {
            status: "rejected",
            reason: e
          };
        }
      }));
    }
    exports.PromiseAllSettled = PromiseAllSettled;
    function isPromiseAllSettledRejectionResult(it) {
      return it.status === "rejected";
    }
    exports.isPromiseAllSettledRejectionResult = isPromiseAllSettledRejectionResult;
    function FlatMap(arr, fn) {
      let result = [];
      return arr.forEach((it) => {
        result.push(...fn(it));
      }), result;
    }
    exports.FlatMap = FlatMap;
    function setEquals(lhs, rhs) {
      if (lhs.size !== rhs.size)
        return !1;
      for (let item of lhs)
        if (!rhs.has(item))
          return !1;
      return !0;
    }
    exports.setEquals = setEquals;
    function binarySearchLB(arr, value) {
      let lo = 0, hi = arr.length - 1;
      for (; hi - lo > 1; ) {
        let mid = Math.trunc((hi + lo) / 2);
        arr[mid] <= value ? lo = mid : hi = mid - 1;
      }
      return arr[hi] <= value ? hi : arr[lo] <= value ? lo : -1;
    }
    exports.binarySearchLB = binarySearchLB;
    function equalsCaseInsensitive(lhs, rhs) {
      return lhs.toLowerCase() === rhs.toLowerCase();
    }
    exports.equalsCaseInsensitive = equalsCaseInsensitive;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/types.js
var require_types7 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AggregatorKind = void 0;
    var AggregatorKind;
    (function(AggregatorKind2) {
      AggregatorKind2[AggregatorKind2.DROP = 0] = "DROP", AggregatorKind2[AggregatorKind2.SUM = 1] = "SUM", AggregatorKind2[AggregatorKind2.LAST_VALUE = 2] = "LAST_VALUE", AggregatorKind2[AggregatorKind2.HISTOGRAM = 3] = "HISTOGRAM", AggregatorKind2[AggregatorKind2.EXPONENTIAL_HISTOGRAM = 4] = "EXPONENTIAL_HISTOGRAM";
    })(AggregatorKind = exports.AggregatorKind || (exports.AggregatorKind = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Drop.js
var require_Drop2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Drop.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DropAggregator = void 0;
    var types_1 = require_types7(), DropAggregator = class {
      constructor() {
        this.kind = types_1.AggregatorKind.DROP;
      }
      createAccumulation() {
      }
      merge(_previous, _delta) {
      }
      diff(_previous, _current) {
      }
      toMetricData(_descriptor, _aggregationTemporality, _accumulationByAttributes, _endTime) {
      }
    };
    exports.DropAggregator = DropAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js
var require_InstrumentDescriptor2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isValidName = exports.isDescriptorCompatibleWith = exports.createInstrumentDescriptorWithView = exports.createInstrumentDescriptor = exports.InstrumentType = void 0;
    var api_1 = require_src(), utils_1 = require_utils8(), InstrumentType;
    (function(InstrumentType2) {
      InstrumentType2.COUNTER = "COUNTER", InstrumentType2.HISTOGRAM = "HISTOGRAM", InstrumentType2.UP_DOWN_COUNTER = "UP_DOWN_COUNTER", InstrumentType2.OBSERVABLE_COUNTER = "OBSERVABLE_COUNTER", InstrumentType2.OBSERVABLE_GAUGE = "OBSERVABLE_GAUGE", InstrumentType2.OBSERVABLE_UP_DOWN_COUNTER = "OBSERVABLE_UP_DOWN_COUNTER";
    })(InstrumentType = exports.InstrumentType || (exports.InstrumentType = {}));
    function createInstrumentDescriptor(name, type, options) {
      var _a, _b, _c;
      return isValidName(name) || api_1.diag.warn(`Invalid metric name: "${name}". The metric name should be a ASCII string with a length no greater than 255 characters.`), {
        name,
        type,
        description: (_a = options?.description) !== null && _a !== void 0 ? _a : "",
        unit: (_b = options?.unit) !== null && _b !== void 0 ? _b : "",
        valueType: (_c = options?.valueType) !== null && _c !== void 0 ? _c : api_1.ValueType.DOUBLE
      };
    }
    exports.createInstrumentDescriptor = createInstrumentDescriptor;
    function createInstrumentDescriptorWithView(view, instrument) {
      var _a, _b;
      return {
        name: (_a = view.name) !== null && _a !== void 0 ? _a : instrument.name,
        description: (_b = view.description) !== null && _b !== void 0 ? _b : instrument.description,
        type: instrument.type,
        unit: instrument.unit,
        valueType: instrument.valueType
      };
    }
    exports.createInstrumentDescriptorWithView = createInstrumentDescriptorWithView;
    function isDescriptorCompatibleWith(descriptor, otherDescriptor) {
      return (0, utils_1.equalsCaseInsensitive)(descriptor.name, otherDescriptor.name) && descriptor.unit === otherDescriptor.unit && descriptor.type === otherDescriptor.type && descriptor.valueType === otherDescriptor.valueType;
    }
    exports.isDescriptorCompatibleWith = isDescriptorCompatibleWith;
    var NAME_REGEXP = /^[a-z][a-z0-9_.-]{0,254}$/i;
    function isValidName(name) {
      return name.match(NAME_REGEXP) != null;
    }
    exports.isValidName = isValidName;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Histogram.js
var require_Histogram2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Histogram.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.HistogramAggregator = exports.HistogramAccumulation = void 0;
    var types_1 = require_types7(), MetricData_1 = require_MetricData2(), InstrumentDescriptor_1 = require_InstrumentDescriptor2(), utils_1 = require_utils8();
    function createNewEmptyCheckpoint(boundaries) {
      let counts = boundaries.map(() => 0);
      return counts.push(0), {
        buckets: {
          boundaries,
          counts
        },
        sum: 0,
        count: 0,
        hasMinMax: !1,
        min: 1 / 0,
        max: -1 / 0
      };
    }
    var HistogramAccumulation = class {
      constructor(startTime, _boundaries, _recordMinMax = !0, _current = createNewEmptyCheckpoint(_boundaries)) {
        this.startTime = startTime, this._boundaries = _boundaries, this._recordMinMax = _recordMinMax, this._current = _current;
      }
      record(value) {
        this._current.count += 1, this._current.sum += value, this._recordMinMax && (this._current.min = Math.min(value, this._current.min), this._current.max = Math.max(value, this._current.max), this._current.hasMinMax = !0);
        let idx = (0, utils_1.binarySearchLB)(this._boundaries, value);
        this._current.buckets.counts[idx + 1] += 1;
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports.HistogramAccumulation = HistogramAccumulation;
    var HistogramAggregator = class {
      /**
       * @param _boundaries sorted upper bounds of recorded values.
       * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
       */
      constructor(_boundaries, _recordMinMax) {
        this._boundaries = _boundaries, this._recordMinMax = _recordMinMax, this.kind = types_1.AggregatorKind.HISTOGRAM;
      }
      createAccumulation(startTime) {
        return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);
      }
      /**
       * Return the result of the merge of two histogram accumulations. As long as one Aggregator
       * instance produces all Accumulations with constant boundaries we don't need to worry about
       * merging accumulations with different boundaries.
       */
      merge(previous, delta) {
        let previousValue = previous.toPointValue(), deltaValue = delta.toPointValue(), previousCounts = previousValue.buckets.counts, deltaCounts = deltaValue.buckets.counts, mergedCounts = new Array(previousCounts.length);
        for (let idx = 0; idx < previousCounts.length; idx++)
          mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];
        let min = 1 / 0, max = -1 / 0;
        return this._recordMinMax && (previousValue.hasMinMax && deltaValue.hasMinMax ? (min = Math.min(previousValue.min, deltaValue.min), max = Math.max(previousValue.max, deltaValue.max)) : previousValue.hasMinMax ? (min = previousValue.min, max = previousValue.max) : deltaValue.hasMinMax && (min = deltaValue.min, max = deltaValue.max)), new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
          buckets: {
            boundaries: previousValue.buckets.boundaries,
            counts: mergedCounts
          },
          count: previousValue.count + deltaValue.count,
          sum: previousValue.sum + deltaValue.sum,
          hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),
          min,
          max
        });
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        let previousValue = previous.toPointValue(), currentValue = current.toPointValue(), previousCounts = previousValue.buckets.counts, currentCounts = currentValue.buckets.counts, diffedCounts = new Array(previousCounts.length);
        for (let idx = 0; idx < previousCounts.length; idx++)
          diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];
        return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
          buckets: {
            boundaries: previousValue.buckets.boundaries,
            counts: diffedCounts
          },
          count: currentValue.count - previousValue.count,
          sum: currentValue.sum - previousValue.sum,
          hasMinMax: !1,
          min: 1 / 0,
          max: -1 / 0
        });
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.HISTOGRAM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            let pointValue = accumulation.toPointValue(), allowsNegativeValues = descriptor.type === InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: {
                min: pointValue.hasMinMax ? pointValue.min : void 0,
                max: pointValue.hasMinMax ? pointValue.max : void 0,
                sum: allowsNegativeValues ? void 0 : pointValue.sum,
                buckets: pointValue.buckets,
                count: pointValue.count
              }
            };
          })
        };
      }
    };
    exports.HistogramAggregator = HistogramAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/Buckets.js
var require_Buckets2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/Buckets.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Buckets = void 0;
    var Buckets = class _Buckets {
      /**
       * The term index refers to the number of the exponential histogram bucket
       * used to determine its boundaries. The lower boundary of a bucket is
       * determined by base ** index and the upper boundary of a bucket is
       * determined by base ** (index + 1). index values are signed to account
       * for values less than or equal to 1.
       *
       * indexBase is the index of the 0th position in the
       * backing array, i.e., backing[0] is the count
       * in the bucket with index `indexBase`.
       *
       * indexStart is the smallest index value represented
       * in the backing array.
       *
       * indexEnd is the largest index value represented in
       * the backing array.
       */
      constructor(backing = new BucketsBacking(), indexBase = 0, indexStart = 0, indexEnd = 0) {
        this.backing = backing, this.indexBase = indexBase, this.indexStart = indexStart, this.indexEnd = indexEnd;
      }
      /**
       * Offset is the bucket index of the smallest entry in the counts array
       * @returns {number}
       */
      get offset() {
        return this.indexStart;
      }
      /**
       * Buckets is a view into the backing array.
       * @returns {number}
       */
      get length() {
        return this.backing.length === 0 || this.indexEnd === this.indexStart && this.at(0) === 0 ? 0 : this.indexEnd - this.indexStart + 1;
      }
      /**
       * An array of counts, where count[i] carries the count
       * of the bucket at index (offset+i).  count[i] is the count of
       * values greater than base^(offset+i) and less than or equal to
       * base^(offset+i+1).
       * @returns {number} The logical counts based on the backing array
       */
      counts() {
        return Array.from({ length: this.length }, (_, i) => this.at(i));
      }
      /**
       * At returns the count of the bucket at a position in the logical
       * array of counts.
       * @param position
       * @returns {number}
       */
      at(position) {
        let bias = this.indexBase - this.indexStart;
        return position < bias && (position += this.backing.length), position -= bias, this.backing.countAt(position);
      }
      /**
       * incrementBucket increments the backing array index by `increment`
       * @param bucketIndex
       * @param increment
       */
      incrementBucket(bucketIndex, increment) {
        this.backing.increment(bucketIndex, increment);
      }
      /**
       * decrementBucket decrements the backing array index by `decrement`
       * if decrement is greater than the current value, it's set to 0.
       * @param bucketIndex
       * @param decrement
       */
      decrementBucket(bucketIndex, decrement) {
        this.backing.decrement(bucketIndex, decrement);
      }
      /**
       * trim removes leading and / or trailing zero buckets (which can occur
       * after diffing two histos) and rotates the backing array so that the
       * smallest non-zero index is in the 0th position of the backing array
       */
      trim() {
        for (let i = 0; i < this.length; i++)
          if (this.at(i) !== 0) {
            this.indexStart += i;
            break;
          } else if (i === this.length - 1) {
            this.indexStart = this.indexEnd = this.indexBase = 0;
            return;
          }
        for (let i = this.length - 1; i >= 0; i--)
          if (this.at(i) !== 0) {
            this.indexEnd -= this.length - i - 1;
            break;
          }
        this._rotate();
      }
      /**
       * downscale first rotates, then collapses 2**`by`-to-1 buckets.
       * @param by
       */
      downscale(by) {
        this._rotate();
        let size = 1 + this.indexEnd - this.indexStart, each = 1 << by, inpos = 0, outpos = 0;
        for (let pos = this.indexStart; pos <= this.indexEnd; ) {
          let mod = pos % each;
          mod < 0 && (mod += each);
          for (let i = mod; i < each && inpos < size; i++)
            this._relocateBucket(outpos, inpos), inpos++, pos++;
          outpos++;
        }
        this.indexStart >>= by, this.indexEnd >>= by, this.indexBase = this.indexStart;
      }
      /**
       * Clone returns a deep copy of Buckets
       * @returns {Buckets}
       */
      clone() {
        return new _Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);
      }
      /**
       * _rotate shifts the backing array contents so that indexStart ==
       * indexBase to simplify the downscale logic.
       */
      _rotate() {
        let bias = this.indexBase - this.indexStart;
        bias !== 0 && (bias > 0 ? (this.backing.reverse(0, this.backing.length), this.backing.reverse(0, bias), this.backing.reverse(bias, this.backing.length)) : (this.backing.reverse(0, this.backing.length), this.backing.reverse(0, this.backing.length + bias)), this.indexBase = this.indexStart);
      }
      /**
       * _relocateBucket adds the count in counts[src] to counts[dest] and
       * resets count[src] to zero.
       */
      _relocateBucket(dest, src) {
        dest !== src && this.incrementBucket(dest, this.backing.emptyBucket(src));
      }
    };
    exports.Buckets = Buckets;
    var BucketsBacking = class _BucketsBacking {
      constructor(_counts = [0]) {
        this._counts = _counts;
      }
      /**
       * length returns the physical size of the backing array, which
       * is >= buckets.length()
       */
      get length() {
        return this._counts.length;
      }
      /**
       * countAt returns the count in a specific bucket
       */
      countAt(pos) {
        return this._counts[pos];
      }
      /**
       * growTo grows a backing array and copies old entries
       * into their correct new positions.
       */
      growTo(newSize, oldPositiveLimit, newPositiveLimit) {
        let tmp = new Array(newSize).fill(0);
        tmp.splice(newPositiveLimit, this._counts.length - oldPositiveLimit, ...this._counts.slice(oldPositiveLimit)), tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit)), this._counts = tmp;
      }
      /**
       * reverse the items in the backing array in the range [from, limit).
       */
      reverse(from, limit) {
        let num = Math.floor((from + limit) / 2) - from;
        for (let i = 0; i < num; i++) {
          let tmp = this._counts[from + i];
          this._counts[from + i] = this._counts[limit - i - 1], this._counts[limit - i - 1] = tmp;
        }
      }
      /**
       * emptyBucket empties the count from a bucket, for
       * moving into another.
       */
      emptyBucket(src) {
        let tmp = this._counts[src];
        return this._counts[src] = 0, tmp;
      }
      /**
       * increments a bucket by `increment`
       */
      increment(bucketIndex, increment) {
        this._counts[bucketIndex] += increment;
      }
      /**
       * decrements a bucket by `decrement`
       */
      decrement(bucketIndex, decrement) {
        this._counts[bucketIndex] >= decrement ? this._counts[bucketIndex] -= decrement : this._counts[bucketIndex] = 0;
      }
      /**
       * clone returns a deep copy of BucketsBacking
       */
      clone() {
        return new _BucketsBacking([...this._counts]);
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ieee754.js
var require_ieee7542 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ieee754.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getSignificand = exports.getNormalBase2 = exports.MIN_VALUE = exports.MAX_NORMAL_EXPONENT = exports.MIN_NORMAL_EXPONENT = exports.SIGNIFICAND_WIDTH = void 0;
    exports.SIGNIFICAND_WIDTH = 52;
    var EXPONENT_MASK = 2146435072, SIGNIFICAND_MASK = 1048575, EXPONENT_BIAS = 1023;
    exports.MIN_NORMAL_EXPONENT = -EXPONENT_BIAS + 1;
    exports.MAX_NORMAL_EXPONENT = EXPONENT_BIAS;
    exports.MIN_VALUE = Math.pow(2, -1022);
    function getNormalBase2(value) {
      let dv = new DataView(new ArrayBuffer(8));
      return dv.setFloat64(0, value), ((dv.getUint32(0) & EXPONENT_MASK) >> 20) - EXPONENT_BIAS;
    }
    exports.getNormalBase2 = getNormalBase2;
    function getSignificand(value) {
      let dv = new DataView(new ArrayBuffer(8));
      dv.setFloat64(0, value);
      let hiBits = dv.getUint32(0), loBits = dv.getUint32(4);
      return (hiBits & SIGNIFICAND_MASK) * Math.pow(2, 32) + loBits;
    }
    exports.getSignificand = getSignificand;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/util.js
var require_util2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/util.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.nextGreaterSquare = exports.ldexp = void 0;
    function ldexp(frac, exp) {
      return frac === 0 || frac === Number.POSITIVE_INFINITY || frac === Number.NEGATIVE_INFINITY || Number.isNaN(frac) ? frac : frac * Math.pow(2, exp);
    }
    exports.ldexp = ldexp;
    function nextGreaterSquare(v) {
      return v--, v |= v >> 1, v |= v >> 2, v |= v >> 4, v |= v >> 8, v |= v >> 16, v++, v;
    }
    exports.nextGreaterSquare = nextGreaterSquare;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/types.js
var require_types8 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MappingError = void 0;
    var MappingError = class extends Error {
    };
    exports.MappingError = MappingError;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ExponentMapping.js
var require_ExponentMapping2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ExponentMapping.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ExponentMapping = void 0;
    var ieee754 = require_ieee7542(), util = require_util2(), types_1 = require_types8(), ExponentMapping = class {
      constructor(scale) {
        this._shift = -scale;
      }
      /**
       * Maps positive floating point values to indexes corresponding to scale
       * @param value
       * @returns {number} index for provided value at the current scale
       */
      mapToIndex(value) {
        if (value < ieee754.MIN_VALUE)
          return this._minNormalLowerBoundaryIndex();
        let exp = ieee754.getNormalBase2(value), correction = this._rightShift(ieee754.getSignificand(value) - 1, ieee754.SIGNIFICAND_WIDTH);
        return exp + correction >> this._shift;
      }
      /**
       * Returns the lower bucket boundary for the given index for scale
       *
       * @param index
       * @returns {number}
       */
      lowerBoundary(index) {
        let minIndex = this._minNormalLowerBoundaryIndex();
        if (index < minIndex)
          throw new types_1.MappingError(`underflow: ${index} is < minimum lower boundary: ${minIndex}`);
        let maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index > maxIndex)
          throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
        return util.ldexp(1, index << this._shift);
      }
      /**
       * The scale used by this mapping
       * @returns {number}
       */
      get scale() {
        return this._shift === 0 ? 0 : -this._shift;
      }
      _minNormalLowerBoundaryIndex() {
        let index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;
        return this._shift < 2 && index--, index;
      }
      _maxNormalLowerBoundaryIndex() {
        return ieee754.MAX_NORMAL_EXPONENT >> this._shift;
      }
      _rightShift(value, shift) {
        return Math.floor(value * Math.pow(2, -shift));
      }
    };
    exports.ExponentMapping = ExponentMapping;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/LogarithmMapping.js
var require_LogarithmMapping2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/LogarithmMapping.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.LogarithmMapping = void 0;
    var ieee754 = require_ieee7542(), util = require_util2(), types_1 = require_types8(), LogarithmMapping = class {
      constructor(scale) {
        this._scale = scale, this._scaleFactor = util.ldexp(Math.LOG2E, scale), this._inverseFactor = util.ldexp(Math.LN2, -scale);
      }
      /**
       * Maps positive floating point values to indexes corresponding to scale
       * @param value
       * @returns {number} index for provided value at the current scale
       */
      mapToIndex(value) {
        if (value <= ieee754.MIN_VALUE)
          return this._minNormalLowerBoundaryIndex() - 1;
        if (ieee754.getSignificand(value) === 0)
          return (ieee754.getNormalBase2(value) << this._scale) - 1;
        let index = Math.floor(Math.log(value) * this._scaleFactor), maxIndex = this._maxNormalLowerBoundaryIndex();
        return index >= maxIndex ? maxIndex : index;
      }
      /**
       * Returns the lower bucket boundary for the given index for scale
       *
       * @param index
       * @returns {number}
       */
      lowerBoundary(index) {
        let maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index >= maxIndex) {
          if (index === maxIndex)
            return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);
          throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
        }
        let minIndex = this._minNormalLowerBoundaryIndex();
        if (index <= minIndex) {
          if (index === minIndex)
            return ieee754.MIN_VALUE;
          if (index === minIndex - 1)
            return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;
          throw new types_1.MappingError(`overflow: ${index} is < minimum lower boundary: ${minIndex}`);
        }
        return Math.exp(index * this._inverseFactor);
      }
      /**
       * The scale used by this mapping
       * @returns {number}
       */
      get scale() {
        return this._scale;
      }
      _minNormalLowerBoundaryIndex() {
        return ieee754.MIN_NORMAL_EXPONENT << this._scale;
      }
      _maxNormalLowerBoundaryIndex() {
        return (ieee754.MAX_NORMAL_EXPONENT + 1 << this._scale) - 1;
      }
    };
    exports.LogarithmMapping = LogarithmMapping;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/getMapping.js
var require_getMapping2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/getMapping.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMapping = void 0;
    var ExponentMapping_1 = require_ExponentMapping2(), LogarithmMapping_1 = require_LogarithmMapping2(), types_1 = require_types8(), MIN_SCALE = -10, MAX_SCALE = 20, PREBUILT_MAPPINGS = Array.from({ length: 31 }, (_, i) => i > 10 ? new LogarithmMapping_1.LogarithmMapping(i - 10) : new ExponentMapping_1.ExponentMapping(i - 10));
    function getMapping(scale) {
      if (scale > MAX_SCALE || scale < MIN_SCALE)
        throw new types_1.MappingError(`expected scale >= ${MIN_SCALE} && <= ${MAX_SCALE}, got: ${scale}`);
      return PREBUILT_MAPPINGS[scale + 10];
    }
    exports.getMapping = getMapping;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/ExponentialHistogram.js
var require_ExponentialHistogram2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/ExponentialHistogram.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ExponentialHistogramAggregator = exports.ExponentialHistogramAccumulation = void 0;
    var types_1 = require_types7(), MetricData_1 = require_MetricData2(), api_1 = require_src(), InstrumentDescriptor_1 = require_InstrumentDescriptor2(), Buckets_1 = require_Buckets2(), getMapping_1 = require_getMapping2(), util_1 = require_util2(), HighLow = class _HighLow {
      constructor(low, high) {
        this.low = low, this.high = high;
      }
      static combine(h1, h2) {
        return new _HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));
      }
    }, MAX_SCALE = 20, DEFAULT_MAX_SIZE = 160, MIN_MAX_SIZE = 2, ExponentialHistogramAccumulation = class _ExponentialHistogramAccumulation {
      constructor(startTime = startTime, _maxSize = DEFAULT_MAX_SIZE, _recordMinMax = !0, _sum = 0, _count = 0, _zeroCount = 0, _min = Number.POSITIVE_INFINITY, _max = Number.NEGATIVE_INFINITY, _positive = new Buckets_1.Buckets(), _negative = new Buckets_1.Buckets(), _mapping = (0, getMapping_1.getMapping)(MAX_SCALE)) {
        this.startTime = startTime, this._maxSize = _maxSize, this._recordMinMax = _recordMinMax, this._sum = _sum, this._count = _count, this._zeroCount = _zeroCount, this._min = _min, this._max = _max, this._positive = _positive, this._negative = _negative, this._mapping = _mapping, this._maxSize < MIN_MAX_SIZE && (api_1.diag.warn(`Exponential Histogram Max Size set to ${this._maxSize},                 changing to the minimum size of: ${MIN_MAX_SIZE}`), this._maxSize = MIN_MAX_SIZE);
      }
      /**
       * record updates a histogram with a single count
       * @param {Number} value
       */
      record(value) {
        this.updateByIncrement(value, 1);
      }
      /**
       * Sets the start time for this accumulation
       * @param {HrTime} startTime
       */
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      /**
       * Returns the datapoint representation of this accumulation
       * @param {HrTime} startTime
       */
      toPointValue() {
        return {
          hasMinMax: this._recordMinMax,
          min: this.min,
          max: this.max,
          sum: this.sum,
          positive: {
            offset: this.positive.offset,
            bucketCounts: this.positive.counts()
          },
          negative: {
            offset: this.negative.offset,
            bucketCounts: this.negative.counts()
          },
          count: this.count,
          scale: this.scale,
          zeroCount: this.zeroCount
        };
      }
      /**
       * @returns {Number} The sum of values recorded by this accumulation
       */
      get sum() {
        return this._sum;
      }
      /**
       * @returns {Number} The minimum value recorded by this accumulation
       */
      get min() {
        return this._min;
      }
      /**
       * @returns {Number} The maximum value recorded by this accumulation
       */
      get max() {
        return this._max;
      }
      /**
       * @returns {Number} The count of values recorded by this accumulation
       */
      get count() {
        return this._count;
      }
      /**
       * @returns {Number} The number of 0 values recorded by this accumulation
       */
      get zeroCount() {
        return this._zeroCount;
      }
      /**
       * @returns {Number} The scale used by thie accumulation
       */
      get scale() {
        return this._count === this._zeroCount ? 0 : this._mapping.scale;
      }
      /**
       * positive holds the postive values
       * @returns {Buckets}
       */
      get positive() {
        return this._positive;
      }
      /**
       * negative holds the negative values by their absolute value
       * @returns {Buckets}
       */
      get negative() {
        return this._negative;
      }
      /**
       * uppdateByIncr supports updating a histogram with a non-negative
       * increment.
       * @param value
       * @param increment
       */
      updateByIncrement(value, increment) {
        if (value > this._max && (this._max = value), value < this._min && (this._min = value), this._count += increment, value === 0) {
          this._zeroCount += increment;
          return;
        }
        this._sum += value * increment, value > 0 ? this._updateBuckets(this._positive, value, increment) : this._updateBuckets(this._negative, -value, increment);
      }
      /**
       * merge combines data from previous value into self
       * @param {ExponentialHistogramAccumulation} previous
       */
      merge(previous) {
        this._count === 0 ? (this._min = previous.min, this._max = previous.max) : previous.count !== 0 && (previous.min < this.min && (this._min = previous.min), previous.max > this.max && (this._max = previous.max)), this.startTime = previous.startTime, this._sum += previous.sum, this._count += previous.count, this._zeroCount += previous.zeroCount;
        let minScale = this._minScale(previous);
        this._downscale(this.scale - minScale), this._mergeBuckets(this.positive, previous, previous.positive, minScale), this._mergeBuckets(this.negative, previous, previous.negative, minScale);
      }
      /**
       * diff substracts other from self
       * @param {ExponentialHistogramAccumulation} other
       */
      diff(other) {
        this._min = 1 / 0, this._max = -1 / 0, this._sum -= other.sum, this._count -= other.count, this._zeroCount -= other.zeroCount;
        let minScale = this._minScale(other);
        this._downscale(this.scale - minScale), this._diffBuckets(this.positive, other, other.positive, minScale), this._diffBuckets(this.negative, other, other.negative, minScale);
      }
      /**
       * clone returns a deep copy of self
       * @returns {ExponentialHistogramAccumulation}
       */
      clone() {
        return new _ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);
      }
      /**
       * _updateBuckets maps the incoming value to a bucket index for the current
       * scale. If the bucket index is outside of the range of the backing array,
       * it will rescale the backing array and update the mapping for the new scale.
       */
      _updateBuckets(buckets, value, increment) {
        let index = this._mapping.mapToIndex(value), rescalingNeeded = !1, high = 0, low = 0;
        if (buckets.length === 0 ? (buckets.indexStart = index, buckets.indexEnd = buckets.indexStart, buckets.indexBase = buckets.indexStart) : index < buckets.indexStart && buckets.indexEnd - index >= this._maxSize ? (rescalingNeeded = !0, low = index, high = buckets.indexEnd) : index > buckets.indexEnd && index - buckets.indexStart >= this._maxSize && (rescalingNeeded = !0, low = buckets.indexStart, high = index), rescalingNeeded) {
          let change = this._changeScale(high, low);
          this._downscale(change), index = this._mapping.mapToIndex(value);
        }
        this._incrementIndexBy(buckets, index, increment);
      }
      /**
       * _incrementIndexBy increments the count of the bucket specified by `index`.
       * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]
       * the boundaries of the backing array will be adjusted and more buckets will
       * be added if needed.
       */
      _incrementIndexBy(buckets, index, increment) {
        if (increment === 0)
          return;
        if (index < buckets.indexStart) {
          let span = buckets.indexEnd - index;
          span >= buckets.backing.length && this._grow(buckets, span + 1), buckets.indexStart = index;
        } else if (index > buckets.indexEnd) {
          let span = index - buckets.indexStart;
          span >= buckets.backing.length && this._grow(buckets, span + 1), buckets.indexEnd = index;
        }
        let bucketIndex = index - buckets.indexBase;
        bucketIndex < 0 && (bucketIndex += buckets.backing.length), buckets.incrementBucket(bucketIndex, increment);
      }
      /**
       * grow resizes the backing array by doubling in size up to maxSize.
       * This extends the array with a bunch of zeros and copies the
       * existing counts to the same position.
       */
      _grow(buckets, needed) {
        let size = buckets.backing.length, bias = buckets.indexBase - buckets.indexStart, oldPositiveLimit = size - bias, newSize = (0, util_1.nextGreaterSquare)(needed);
        newSize > this._maxSize && (newSize = this._maxSize);
        let newPositiveLimit = newSize - bias;
        buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);
      }
      /**
       * _changeScale computes how much downscaling is needed by shifting the
       * high and low values until they are separated by no more than size.
       */
      _changeScale(high, low) {
        let change = 0;
        for (; high - low >= this._maxSize; )
          high >>= 1, low >>= 1, change++;
        return change;
      }
      /**
       * _downscale subtracts `change` from the current mapping scale.
       */
      _downscale(change) {
        if (change === 0)
          return;
        if (change < 0)
          throw new Error(`impossible change of scale: ${this.scale}`);
        let newScale = this._mapping.scale - change;
        this._positive.downscale(change), this._negative.downscale(change), this._mapping = (0, getMapping_1.getMapping)(newScale);
      }
      /**
       * _minScale is used by diff and merge to compute an ideal combined scale
       */
      _minScale(other) {
        let minScale = Math.min(this.scale, other.scale), highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale)), highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));
        return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));
      }
      /**
       * _highLowAtScale is used by diff and merge to compute an ideal combined scale.
       */
      _highLowAtScale(buckets, currentScale, newScale) {
        if (buckets.length === 0)
          return new HighLow(0, -1);
        let shift = currentScale - newScale;
        return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);
      }
      /**
       * _mergeBuckets translates index values from another histogram and
       * adds the values into the corresponding buckets of this histogram.
       */
      _mergeBuckets(ours, other, theirs, scale) {
        let theirOffset = theirs.offset, theirChange = other.scale - scale;
        for (let i = 0; i < theirs.length; i++)
          this._incrementIndexBy(ours, theirOffset + i >> theirChange, theirs.at(i));
      }
      /**
       * _diffBuckets translates index values from another histogram and
       * subtracts the values in the corresponding buckets of this histogram.
       */
      _diffBuckets(ours, other, theirs, scale) {
        let theirOffset = theirs.offset, theirChange = other.scale - scale;
        for (let i = 0; i < theirs.length; i++) {
          let bucketIndex = (theirOffset + i >> theirChange) - ours.indexBase;
          bucketIndex < 0 && (bucketIndex += ours.backing.length), ours.decrementBucket(bucketIndex, theirs.at(i));
        }
        ours.trim();
      }
    };
    exports.ExponentialHistogramAccumulation = ExponentialHistogramAccumulation;
    var ExponentialHistogramAggregator = class {
      /**
       * @param _maxSize Maximum number of buckets for each of the positive
       *    and negative ranges, exclusive of the zero-bucket.
       * @param _recordMinMax If set to true, min and max will be recorded.
       *    Otherwise, min and max will not be recorded.
       */
      constructor(_maxSize, _recordMinMax) {
        this._maxSize = _maxSize, this._recordMinMax = _recordMinMax, this.kind = types_1.AggregatorKind.EXPONENTIAL_HISTOGRAM;
      }
      createAccumulation(startTime) {
        return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);
      }
      /**
       * Return the result of the merge of two exponential histogram accumulations.
       */
      merge(previous, delta) {
        let result = delta.clone();
        return result.merge(previous), result;
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        let result = current.clone();
        return result.diff(previous), result;
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.EXPONENTIAL_HISTOGRAM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            let pointValue = accumulation.toPointValue(), allowsNegativeValues = descriptor.type === InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: {
                min: pointValue.hasMinMax ? pointValue.min : void 0,
                max: pointValue.hasMinMax ? pointValue.max : void 0,
                sum: allowsNegativeValues ? void 0 : pointValue.sum,
                positive: {
                  offset: pointValue.positive.offset,
                  bucketCounts: pointValue.positive.bucketCounts
                },
                negative: {
                  offset: pointValue.negative.offset,
                  bucketCounts: pointValue.negative.bucketCounts
                },
                count: pointValue.count,
                scale: pointValue.scale,
                zeroCount: pointValue.zeroCount
              }
            };
          })
        };
      }
    };
    exports.ExponentialHistogramAggregator = ExponentialHistogramAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/LastValue.js
var require_LastValue2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/LastValue.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.LastValueAggregator = exports.LastValueAccumulation = void 0;
    var types_1 = require_types7(), core_1 = require_src7(), MetricData_1 = require_MetricData2(), LastValueAccumulation = class {
      constructor(startTime, _current = 0, sampleTime = [0, 0]) {
        this.startTime = startTime, this._current = _current, this.sampleTime = sampleTime;
      }
      record(value) {
        this._current = value, this.sampleTime = (0, core_1.millisToHrTime)(Date.now());
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports.LastValueAccumulation = LastValueAccumulation;
    var LastValueAggregator = class {
      constructor() {
        this.kind = types_1.AggregatorKind.LAST_VALUE;
      }
      createAccumulation(startTime) {
        return new LastValueAccumulation(startTime);
      }
      /**
       * Returns the result of the merge of the given accumulations.
       *
       * Return the newly captured (delta) accumulation for LastValueAggregator.
       */
      merge(previous, delta) {
        let latestAccumulation = (0, core_1.hrTimeToMicroseconds)(delta.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? delta : previous;
        return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       *
       * A delta aggregation is not meaningful to LastValueAggregator, just return
       * the newly captured (delta) accumulation for LastValueAggregator.
       */
      diff(previous, current) {
        let latestAccumulation = (0, core_1.hrTimeToMicroseconds)(current.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? current : previous;
        return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.GAUGE,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => ({
            attributes,
            startTime: accumulation.startTime,
            endTime,
            value: accumulation.toPointValue()
          }))
        };
      }
    };
    exports.LastValueAggregator = LastValueAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Sum.js
var require_Sum2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Sum.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.SumAggregator = exports.SumAccumulation = void 0;
    var types_1 = require_types7(), MetricData_1 = require_MetricData2(), SumAccumulation = class {
      constructor(startTime, monotonic, _current = 0, reset = !1) {
        this.startTime = startTime, this.monotonic = monotonic, this._current = _current, this.reset = reset;
      }
      record(value) {
        this.monotonic && value < 0 || (this._current += value);
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports.SumAccumulation = SumAccumulation;
    var SumAggregator = class {
      constructor(monotonic) {
        this.monotonic = monotonic, this.kind = types_1.AggregatorKind.SUM;
      }
      createAccumulation(startTime) {
        return new SumAccumulation(startTime, this.monotonic);
      }
      /**
       * Returns the result of the merge of the given accumulations.
       */
      merge(previous, delta) {
        let prevPv = previous.toPointValue(), deltaPv = delta.toPointValue();
        return delta.reset ? new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset) : new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        let prevPv = previous.toPointValue(), currPv = current.toPointValue();
        return this.monotonic && prevPv > currPv ? new SumAccumulation(current.startTime, this.monotonic, currPv, !0) : new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.SUM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => ({
            attributes,
            startTime: accumulation.startTime,
            endTime,
            value: accumulation.toPointValue()
          })),
          isMonotonic: this.monotonic
        };
      }
    };
    exports.SumAggregator = SumAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/index.js
var require_aggregator2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_Drop2(), exports);
    __exportStar(require_Histogram2(), exports);
    __exportStar(require_ExponentialHistogram2(), exports);
    __exportStar(require_LastValue2(), exports);
    __exportStar(require_Sum2(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Aggregation.js
var require_Aggregation2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Aggregation.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DefaultAggregation = exports.ExponentialHistogramAggregation = exports.ExplicitBucketHistogramAggregation = exports.HistogramAggregation = exports.LastValueAggregation = exports.SumAggregation = exports.DropAggregation = exports.Aggregation = void 0;
    var api = require_src(), aggregator_1 = require_aggregator2(), InstrumentDescriptor_1 = require_InstrumentDescriptor2(), Aggregation = class {
      static Drop() {
        return DROP_AGGREGATION;
      }
      static Sum() {
        return SUM_AGGREGATION;
      }
      static LastValue() {
        return LAST_VALUE_AGGREGATION;
      }
      static Histogram() {
        return HISTOGRAM_AGGREGATION;
      }
      static ExponentialHistogram() {
        return EXPONENTIAL_HISTOGRAM_AGGREGATION;
      }
      static Default() {
        return DEFAULT_AGGREGATION;
      }
    };
    exports.Aggregation = Aggregation;
    var DropAggregation = class _DropAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _DropAggregation.DEFAULT_INSTANCE;
      }
    };
    exports.DropAggregation = DropAggregation;
    DropAggregation.DEFAULT_INSTANCE = new aggregator_1.DropAggregator();
    var SumAggregation = class _SumAggregation extends Aggregation {
      createAggregator(instrument) {
        switch (instrument.type) {
          case InstrumentDescriptor_1.InstrumentType.COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.HISTOGRAM:
            return _SumAggregation.MONOTONIC_INSTANCE;
          default:
            return _SumAggregation.NON_MONOTONIC_INSTANCE;
        }
      }
    };
    exports.SumAggregation = SumAggregation;
    SumAggregation.MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(!0);
    SumAggregation.NON_MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(!1);
    var LastValueAggregation = class _LastValueAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _LastValueAggregation.DEFAULT_INSTANCE;
      }
    };
    exports.LastValueAggregation = LastValueAggregation;
    LastValueAggregation.DEFAULT_INSTANCE = new aggregator_1.LastValueAggregator();
    var HistogramAggregation = class _HistogramAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _HistogramAggregation.DEFAULT_INSTANCE;
      }
    };
    exports.HistogramAggregation = HistogramAggregation;
    HistogramAggregation.DEFAULT_INSTANCE = new aggregator_1.HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1e3, 2500, 5e3, 7500, 1e4], !0);
    var ExplicitBucketHistogramAggregation2 = class extends Aggregation {
      /**
       * @param boundaries the bucket boundaries of the histogram aggregation
       * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
       */
      constructor(boundaries, _recordMinMax = !0) {
        if (super(), this._recordMinMax = _recordMinMax, boundaries === void 0 || boundaries.length === 0)
          throw new Error("HistogramAggregator should be created with boundaries.");
        boundaries = boundaries.concat(), boundaries = boundaries.sort((a, b) => a - b);
        let minusInfinityIndex = boundaries.lastIndexOf(-1 / 0), infinityIndex = boundaries.indexOf(1 / 0);
        infinityIndex === -1 && (infinityIndex = void 0), this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);
      }
      createAggregator(_instrument) {
        return new aggregator_1.HistogramAggregator(this._boundaries, this._recordMinMax);
      }
    };
    exports.ExplicitBucketHistogramAggregation = ExplicitBucketHistogramAggregation2;
    var ExponentialHistogramAggregation = class extends Aggregation {
      constructor(_maxSize = 160, _recordMinMax = !0) {
        super(), this._maxSize = _maxSize, this._recordMinMax = _recordMinMax;
      }
      createAggregator(_instrument) {
        return new aggregator_1.ExponentialHistogramAggregator(this._maxSize, this._recordMinMax);
      }
    };
    exports.ExponentialHistogramAggregation = ExponentialHistogramAggregation;
    var DefaultAggregation = class extends Aggregation {
      _resolve(instrument) {
        switch (instrument.type) {
          case InstrumentDescriptor_1.InstrumentType.COUNTER:
          case InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
            return SUM_AGGREGATION;
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE:
            return LAST_VALUE_AGGREGATION;
          case InstrumentDescriptor_1.InstrumentType.HISTOGRAM:
            return HISTOGRAM_AGGREGATION;
        }
        return api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`), DROP_AGGREGATION;
      }
      createAggregator(instrument) {
        return this._resolve(instrument).createAggregator(instrument);
      }
    };
    exports.DefaultAggregation = DefaultAggregation;
    var DROP_AGGREGATION = new DropAggregation(), SUM_AGGREGATION = new SumAggregation(), LAST_VALUE_AGGREGATION = new LastValueAggregation(), HISTOGRAM_AGGREGATION = new HistogramAggregation(), EXPONENTIAL_HISTOGRAM_AGGREGATION = new ExponentialHistogramAggregation(), DEFAULT_AGGREGATION = new DefaultAggregation();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationSelector.js
var require_AggregationSelector2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationSelector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = exports.DEFAULT_AGGREGATION_SELECTOR = void 0;
    var Aggregation_1 = require_Aggregation2(), AggregationTemporality_1 = require_AggregationTemporality2(), DEFAULT_AGGREGATION_SELECTOR = (_instrumentType) => Aggregation_1.Aggregation.Default();
    exports.DEFAULT_AGGREGATION_SELECTOR = DEFAULT_AGGREGATION_SELECTOR;
    var DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = (_instrumentType) => AggregationTemporality_1.AggregationTemporality.CUMULATIVE;
    exports.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricReader.js
var require_MetricReader2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricReader.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MetricReader = void 0;
    var api = require_src(), utils_1 = require_utils8(), AggregationSelector_1 = require_AggregationSelector2(), MetricReader2 = class {
      constructor(options) {
        var _a, _b, _c;
        this._shutdown = !1, this._aggregationSelector = (_a = options?.aggregationSelector) !== null && _a !== void 0 ? _a : AggregationSelector_1.DEFAULT_AGGREGATION_SELECTOR, this._aggregationTemporalitySelector = (_b = options?.aggregationTemporalitySelector) !== null && _b !== void 0 ? _b : AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR, this._metricProducers = (_c = options?.metricProducers) !== null && _c !== void 0 ? _c : [];
      }
      /**
       * Set the {@link MetricProducer} used by this instance. **This should only be called by the
       * SDK and should be considered internal.**
       *
       * To add additional {@link MetricProducer}s to a {@link MetricReader}, pass them to the
       * constructor as {@link MetricReaderOptions.metricProducers}.
       *
       * @internal
       * @param metricProducer
       */
      setMetricProducer(metricProducer) {
        if (this._sdkMetricProducer)
          throw new Error("MetricReader can not be bound to a MeterProvider again.");
        this._sdkMetricProducer = metricProducer, this.onInitialized();
      }
      /**
       * Select the {@link Aggregation} for the given {@link InstrumentType} for this
       * reader.
       */
      selectAggregation(instrumentType) {
        return this._aggregationSelector(instrumentType);
      }
      /**
       * Select the {@link AggregationTemporality} for the given
       * {@link InstrumentType} for this reader.
       */
      selectAggregationTemporality(instrumentType) {
        return this._aggregationTemporalitySelector(instrumentType);
      }
      /**
       * Handle once the SDK has initialized this {@link MetricReader}
       * Overriding this method is optional.
       */
      onInitialized() {
      }
      /**
       * Collect all metrics from the associated {@link MetricProducer}
       */
      async collect(options) {
        if (this._sdkMetricProducer === void 0)
          throw new Error("MetricReader is not bound to a MetricProducer");
        if (this._shutdown)
          throw new Error("MetricReader is shutdown");
        let [sdkCollectionResults, ...additionalCollectionResults] = await Promise.all([
          this._sdkMetricProducer.collect({
            timeoutMillis: options?.timeoutMillis
          }),
          ...this._metricProducers.map((producer) => producer.collect({
            timeoutMillis: options?.timeoutMillis
          }))
        ]), errors = sdkCollectionResults.errors.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result) => result.errors)), resource = sdkCollectionResults.resourceMetrics.resource, scopeMetrics = sdkCollectionResults.resourceMetrics.scopeMetrics.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result) => result.resourceMetrics.scopeMetrics));
        return {
          resourceMetrics: {
            resource,
            scopeMetrics
          },
          errors
        };
      }
      /**
       * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.
       *
       * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
       * @param options options with timeout.
       */
      async shutdown(options) {
        if (this._shutdown) {
          api.diag.error("Cannot call shutdown twice.");
          return;
        }
        options?.timeoutMillis == null ? await this.onShutdown() : await (0, utils_1.callWithTimeout)(this.onShutdown(), options.timeoutMillis), this._shutdown = !0;
      }
      /**
       * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.
       *
       * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
       * @param options options with timeout.
       */
      async forceFlush(options) {
        if (this._shutdown) {
          api.diag.warn("Cannot forceFlush on already shutdown MetricReader.");
          return;
        }
        if (options?.timeoutMillis == null) {
          await this.onForceFlush();
          return;
        }
        await (0, utils_1.callWithTimeout)(this.onForceFlush(), options.timeoutMillis);
      }
    };
    exports.MetricReader = MetricReader2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/PeriodicExportingMetricReader.js
var require_PeriodicExportingMetricReader2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/PeriodicExportingMetricReader.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.PeriodicExportingMetricReader = void 0;
    var api = require_src(), core_1 = require_src7(), MetricReader_1 = require_MetricReader2(), utils_1 = require_utils8(), api_1 = require_src(), PeriodicExportingMetricReader = class extends MetricReader_1.MetricReader {
      constructor(options) {
        var _a, _b, _c, _d;
        if (super({
          aggregationSelector: (_a = options.exporter.selectAggregation) === null || _a === void 0 ? void 0 : _a.bind(options.exporter),
          aggregationTemporalitySelector: (_b = options.exporter.selectAggregationTemporality) === null || _b === void 0 ? void 0 : _b.bind(options.exporter),
          metricProducers: options.metricProducers
        }), options.exportIntervalMillis !== void 0 && options.exportIntervalMillis <= 0)
          throw Error("exportIntervalMillis must be greater than 0");
        if (options.exportTimeoutMillis !== void 0 && options.exportTimeoutMillis <= 0)
          throw Error("exportTimeoutMillis must be greater than 0");
        if (options.exportTimeoutMillis !== void 0 && options.exportIntervalMillis !== void 0 && options.exportIntervalMillis < options.exportTimeoutMillis)
          throw Error("exportIntervalMillis must be greater than or equal to exportTimeoutMillis");
        this._exportInterval = (_c = options.exportIntervalMillis) !== null && _c !== void 0 ? _c : 6e4, this._exportTimeout = (_d = options.exportTimeoutMillis) !== null && _d !== void 0 ? _d : 3e4, this._exporter = options.exporter;
      }
      async _runOnce() {
        try {
          await (0, utils_1.callWithTimeout)(this._doRun(), this._exportTimeout);
        } catch (err) {
          if (err instanceof utils_1.TimeoutError) {
            api.diag.error("Export took longer than %s milliseconds and timed out.", this._exportTimeout);
            return;
          }
          (0, core_1.globalErrorHandler)(err);
        }
      }
      async _doRun() {
        var _a, _b;
        let { resourceMetrics, errors } = await this.collect({
          timeoutMillis: this._exportTimeout
        });
        errors.length > 0 && api.diag.error("PeriodicExportingMetricReader: metrics collection errors", ...errors);
        let doExport = async () => {
          let result = await core_1.internal._export(this._exporter, resourceMetrics);
          if (result.code !== core_1.ExportResultCode.SUCCESS)
            throw new Error(`PeriodicExportingMetricReader: metrics export failed (error ${result.error})`);
        };
        resourceMetrics.resource.asyncAttributesPending ? (_b = (_a = resourceMetrics.resource).waitForAsyncAttributes) === null || _b === void 0 || _b.call(_a).then(doExport, (err) => api_1.diag.debug("Error while resolving async portion of resource: ", err)) : await doExport();
      }
      onInitialized() {
        this._interval = setInterval(() => {
          this._runOnce();
        }, this._exportInterval), (0, core_1.unrefTimer)(this._interval);
      }
      async onForceFlush() {
        await this._runOnce(), await this._exporter.forceFlush();
      }
      async onShutdown() {
        this._interval && clearInterval(this._interval), await this._exporter.shutdown();
      }
    };
    exports.PeriodicExportingMetricReader = PeriodicExportingMetricReader;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/InMemoryMetricExporter.js
var require_InMemoryMetricExporter2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/InMemoryMetricExporter.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.InMemoryMetricExporter = void 0;
    var core_1 = require_src7(), InMemoryMetricExporter = class {
      constructor(aggregationTemporality) {
        this._shutdown = !1, this._metrics = [], this._aggregationTemporality = aggregationTemporality;
      }
      /**
       * @inheritedDoc
       */
      export(metrics, resultCallback) {
        if (this._shutdown) {
          setTimeout(() => resultCallback({ code: core_1.ExportResultCode.FAILED }), 0);
          return;
        }
        this._metrics.push(metrics), setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
      }
      /**
       * Returns all the collected resource metrics
       * @returns ResourceMetrics[]
       */
      getMetrics() {
        return this._metrics;
      }
      forceFlush() {
        return Promise.resolve();
      }
      reset() {
        this._metrics = [];
      }
      selectAggregationTemporality(_instrumentType) {
        return this._aggregationTemporality;
      }
      shutdown() {
        return this._shutdown = !0, Promise.resolve();
      }
    };
    exports.InMemoryMetricExporter = InMemoryMetricExporter;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/ConsoleMetricExporter.js
var require_ConsoleMetricExporter2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/ConsoleMetricExporter.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ConsoleMetricExporter = void 0;
    var core_1 = require_src7(), AggregationSelector_1 = require_AggregationSelector2(), ConsoleMetricExporter2 = class _ConsoleMetricExporter {
      constructor(options) {
        var _a;
        this._shutdown = !1, this._temporalitySelector = (_a = options?.temporalitySelector) !== null && _a !== void 0 ? _a : AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
      }
      export(metrics, resultCallback) {
        if (this._shutdown) {
          setImmediate(resultCallback, { code: core_1.ExportResultCode.FAILED });
          return;
        }
        return _ConsoleMetricExporter._sendMetrics(metrics, resultCallback);
      }
      forceFlush() {
        return Promise.resolve();
      }
      selectAggregationTemporality(_instrumentType) {
        return this._temporalitySelector(_instrumentType);
      }
      shutdown() {
        return this._shutdown = !0, Promise.resolve();
      }
      static _sendMetrics(metrics, done) {
        for (let scopeMetrics of metrics.scopeMetrics)
          for (let metric of scopeMetrics.metrics)
            console.dir({
              descriptor: metric.descriptor,
              dataPointType: metric.dataPointType,
              dataPoints: metric.dataPoints
            });
        done({ code: core_1.ExportResultCode.SUCCESS });
      }
    };
    exports.ConsoleMetricExporter = ConsoleMetricExporter2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js
var require_default_service_name2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.defaultServiceName = void 0;
    function defaultServiceName() {
      return `unknown_service:${process.argv0}`;
    }
    exports.defaultServiceName = defaultServiceName;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/utils.js
var require_utils9 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.normalizeType = exports.normalizeArch = void 0;
    var normalizeArch = (nodeArchString) => {
      switch (nodeArchString) {
        case "arm":
          return "arm32";
        case "ppc":
          return "ppc32";
        case "x64":
          return "amd64";
        default:
          return nodeArchString;
      }
    };
    exports.normalizeArch = normalizeArch;
    var normalizeType = (nodePlatform) => {
      switch (nodePlatform) {
        case "sunos":
          return "solaris";
        case "win32":
          return "windows";
        default:
          return nodePlatform;
      }
    };
    exports.normalizeType = normalizeType;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/execAsync.js
var require_execAsync2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/execAsync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.execAsync = void 0;
    var child_process = __require("child_process"), util = __require("util");
    exports.execAsync = util.promisify(child_process.exec);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-darwin.js
var require_getMachineId_darwin2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-darwin.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var execAsync_1 = require_execAsync2(), api_1 = require_src();
    async function getMachineId() {
      try {
        let idLine = (await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"')).stdout.split(`
`).find((line) => line.includes("IOPlatformUUID"));
        if (!idLine)
          return "";
        let parts = idLine.split('" = "');
        if (parts.length === 2)
          return parts[1].slice(0, -1);
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-linux.js
var require_getMachineId_linux2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-linux.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var fs_1 = __require("fs"), api_1 = require_src();
    async function getMachineId() {
      let paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
      for (let path of paths)
        try {
          return (await fs_1.promises.readFile(path, { encoding: "utf8" })).trim();
        } catch (e) {
          api_1.diag.debug(`error reading machine id: ${e}`);
        }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-bsd.js
var require_getMachineId_bsd2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-bsd.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var fs_1 = __require("fs"), execAsync_1 = require_execAsync2(), api_1 = require_src();
    async function getMachineId() {
      try {
        return (await fs_1.promises.readFile("/etc/hostid", { encoding: "utf8" })).trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      try {
        return (await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid")).stdout.trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-win.js
var require_getMachineId_win2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-win.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var process2 = __require("process"), execAsync_1 = require_execAsync2(), api_1 = require_src();
    async function getMachineId() {
      let args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid", command = "%windir%\\System32\\REG.exe";
      process2.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process2.env && (command = "%windir%\\sysnative\\cmd.exe /c " + command);
      try {
        let parts = (await (0, execAsync_1.execAsync)(`${command} ${args}`)).stdout.split("REG_SZ");
        if (parts.length === 2)
          return parts[1].trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-unsupported.js
var require_getMachineId_unsupported2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-unsupported.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var api_1 = require_src();
    async function getMachineId() {
      return api_1.diag.debug("could not read machine-id: unsupported platform"), "";
    }
    exports.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId.js
var require_getMachineId2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getMachineId = void 0;
    var process2 = __require("process"), getMachineId;
    exports.getMachineId = getMachineId;
    switch (process2.platform) {
      case "darwin":
        exports.getMachineId = getMachineId = require_getMachineId_darwin2().getMachineId;
        break;
      case "linux":
        exports.getMachineId = getMachineId = require_getMachineId_linux2().getMachineId;
        break;
      case "freebsd":
        exports.getMachineId = getMachineId = require_getMachineId_bsd2().getMachineId;
        break;
      case "win32":
        exports.getMachineId = getMachineId = require_getMachineId_win2().getMachineId;
        break;
      default:
        exports.getMachineId = getMachineId = require_getMachineId_unsupported2().getMachineId;
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/HostDetectorSync.js
var require_HostDetectorSync2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/HostDetectorSync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.hostDetectorSync = void 0;
    var semantic_conventions_1 = require_src6(), Resource_1 = require_Resource2(), os_1 = __require("os"), utils_1 = require_utils9(), getMachineId_1 = require_getMachineId2(), HostDetectorSync = class {
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.HOST_NAME]: (0, os_1.hostname)(),
          [semantic_conventions_1.SemanticResourceAttributes.HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)())
        };
        return new Resource_1.Resource(attributes, this._getAsyncAttributes());
      }
      _getAsyncAttributes() {
        return (0, getMachineId_1.getMachineId)().then((machineId) => {
          let attributes = {};
          return machineId && (attributes[semantic_conventions_1.SemanticResourceAttributes.HOST_ID] = machineId), attributes;
        });
      }
    };
    exports.hostDetectorSync = new HostDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/HostDetector.js
var require_HostDetector2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/HostDetector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.hostDetector = void 0;
    var HostDetectorSync_1 = require_HostDetectorSync2(), HostDetector = class {
      detect(_config) {
        return Promise.resolve(HostDetectorSync_1.hostDetectorSync.detect(_config));
      }
    };
    exports.hostDetector = new HostDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/OSDetectorSync.js
var require_OSDetectorSync2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/OSDetectorSync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.osDetectorSync = void 0;
    var semantic_conventions_1 = require_src6(), Resource_1 = require_Resource2(), os_1 = __require("os"), utils_1 = require_utils9(), OSDetectorSync = class {
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
          [semantic_conventions_1.SemanticResourceAttributes.OS_VERSION]: (0, os_1.release)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports.osDetectorSync = new OSDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/OSDetector.js
var require_OSDetector2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/OSDetector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.osDetector = void 0;
    var OSDetectorSync_1 = require_OSDetectorSync2(), OSDetector = class {
      detect(_config) {
        return Promise.resolve(OSDetectorSync_1.osDetectorSync.detect(_config));
      }
    };
    exports.osDetector = new OSDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetectorSync.js
var require_ProcessDetectorSync2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetectorSync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.processDetectorSync = void 0;
    var api_1 = require_src(), semantic_conventions_1 = require_src6(), Resource_1 = require_Resource2(), os = __require("os"), ProcessDetectorSync = class {
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_PID]: process.pid,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME]: process.title,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH]: process.execPath,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_COMMAND_ARGS]: [
            process.argv[0],
            ...process.execArgv,
            ...process.argv.slice(1)
          ],
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION]: process.versions.node,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "nodejs",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
        };
        process.argv.length > 1 && (attributes[semantic_conventions_1.SemanticResourceAttributes.PROCESS_COMMAND] = process.argv[1]);
        try {
          let userInfo = os.userInfo();
          attributes[semantic_conventions_1.SemanticResourceAttributes.PROCESS_OWNER] = userInfo.username;
        } catch (e) {
          api_1.diag.debug(`error obtaining process owner: ${e}`);
        }
        return new Resource_1.Resource(attributes);
      }
    };
    exports.processDetectorSync = new ProcessDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetector.js
var require_ProcessDetector2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.processDetector = void 0;
    var ProcessDetectorSync_1 = require_ProcessDetectorSync2(), ProcessDetector = class {
      detect(config) {
        return Promise.resolve(ProcessDetectorSync_1.processDetectorSync.detect(config));
      }
    };
    exports.processDetector = new ProcessDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/index.js
var require_node5 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/node/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_default_service_name2(), exports);
    __exportStar(require_HostDetector2(), exports);
    __exportStar(require_OSDetector2(), exports);
    __exportStar(require_HostDetectorSync2(), exports);
    __exportStar(require_OSDetectorSync2(), exports);
    __exportStar(require_ProcessDetector2(), exports);
    __exportStar(require_ProcessDetectorSync2(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/index.js
var require_platform5 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/platform/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_node5(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/Resource.js
var require_Resource2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/Resource.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Resource = void 0;
    var api_1 = require_src(), semantic_conventions_1 = require_src6(), core_1 = require_src7(), platform_1 = require_platform5(), Resource2 = class _Resource {
      constructor(attributes, asyncAttributesPromise) {
        var _a;
        this._attributes = attributes, this.asyncAttributesPending = asyncAttributesPromise != null, this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {}, this._asyncAttributesPromise = asyncAttributesPromise?.then((asyncAttributes) => (this._attributes = Object.assign({}, this._attributes, asyncAttributes), this.asyncAttributesPending = !1, asyncAttributes), (err) => (api_1.diag.debug("a resource's async attributes promise rejected: %s", err), this.asyncAttributesPending = !1, {}));
      }
      /**
       * Returns an empty Resource
       */
      static empty() {
        return _Resource.EMPTY;
      }
      /**
       * Returns a Resource that identifies the SDK in use.
       */
      static default() {
        return new _Resource({
          [semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE],
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME],
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]
        });
      }
      get attributes() {
        var _a;
        return this.asyncAttributesPending && api_1.diag.error("Accessing resource attributes before async attributes settled"), (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
      }
      /**
       * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
       * this Resource's attributes. This is useful in exporters to block until resource detection
       * has finished.
       */
      async waitForAsyncAttributes() {
        this.asyncAttributesPending && await this._asyncAttributesPromise;
      }
      /**
       * Returns a new, merged {@link Resource} by merging the current Resource
       * with the other Resource. In case of a collision, other Resource takes
       * precedence.
       *
       * @param other the Resource that will be merged with this.
       * @returns the newly merged Resource.
       */
      merge(other) {
        var _a;
        if (!other)
          return this;
        let mergedSyncAttributes = Object.assign(Object.assign({}, this._syncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise)
          return new _Resource(mergedSyncAttributes);
        let mergedAttributesPromise = Promise.all([
          this._asyncAttributesPromise,
          other._asyncAttributesPromise
        ]).then(([thisAsyncAttributes, otherAsyncAttributes]) => {
          var _a2;
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this._syncAttributes), thisAsyncAttributes), (_a2 = other._syncAttributes) !== null && _a2 !== void 0 ? _a2 : other.attributes), otherAsyncAttributes);
        });
        return new _Resource(mergedSyncAttributes, mergedAttributesPromise);
      }
    };
    exports.Resource = Resource2;
    Resource2.EMPTY = new Resource2({});
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/IResource.js
var require_IResource2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/IResource.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/types.js
var require_types9 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/config.js
var require_config2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/config.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js
var require_BrowserDetector2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.browserDetector = void 0;
    var __1 = require_src8(), BrowserDetector = class {
      detect(config) {
        return Promise.resolve(__1.browserDetectorSync.detect(config));
      }
    };
    exports.browserDetector = new BrowserDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js
var require_EnvDetectorSync2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.envDetectorSync = void 0;
    var api_1 = require_src(), core_1 = require_src7(), semantic_conventions_1 = require_src6(), Resource_1 = require_Resource2(), EnvDetectorSync = class {
      constructor() {
        this._MAX_LENGTH = 255, this._COMMA_SEPARATOR = ",", this._LABEL_KEY_VALUE_SPLITTER = "=", this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.", this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
      }
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(_config) {
        let attributes = {}, env = (0, core_1.getEnv)(), rawAttributes = env.OTEL_RESOURCE_ATTRIBUTES, serviceName = env.OTEL_SERVICE_NAME;
        if (rawAttributes)
          try {
            let parsedAttributes = this._parseResourceAttributes(rawAttributes);
            Object.assign(attributes, parsedAttributes);
          } catch (e) {
            api_1.diag.debug(`EnvDetector failed: ${e.message}`);
          }
        return serviceName && (attributes[semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME] = serviceName), new Resource_1.Resource(attributes);
      }
      /**
       * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment
       * variable.
       *
       * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing
       * the source in more detail, e.g. key1=val1,key2=val2. Domain names and
       * paths are accepted as attribute keys. Values may be quoted or unquoted in
       * general. If a value contains whitespaces, =, or " characters, it must
       * always be quoted.
       *
       * @param rawEnvAttributes The resource attributes as a comma-seperated list
       * of key/value pairs.
       * @returns The sanitized resource attributes.
       */
      _parseResourceAttributes(rawEnvAttributes) {
        if (!rawEnvAttributes)
          return {};
        let attributes = {}, rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        for (let rawAttribute of rawAttributes) {
          let keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
          if (keyValuePair.length !== 2)
            continue;
          let [key, value] = keyValuePair;
          if (key = key.trim(), value = value.trim().split(/^"|"$/).join(""), !this._isValidAndNotEmpty(key))
            throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
          if (!this._isValid(value))
            throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
          attributes[key] = decodeURIComponent(value);
        }
        return attributes;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid.
       */
      _isValid(name) {
        return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);
      }
      // https://www.w3.org/TR/baggage/#definition
      _isBaggageOctetString(str) {
        for (let i = 0; i < str.length; i++) {
          let ch = str.charCodeAt(i);
          if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126)
            return !1;
        }
        return !0;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length greater than 0 and not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid and not empty.
       */
      _isValidAndNotEmpty(str) {
        return str.length > 0 && this._isValid(str);
      }
    };
    exports.envDetectorSync = new EnvDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js
var require_EnvDetector2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.envDetector = void 0;
    var EnvDetectorSync_1 = require_EnvDetectorSync2(), EnvDetector = class {
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(config) {
        return Promise.resolve(EnvDetectorSync_1.envDetectorSync.detect(config));
      }
    };
    exports.envDetector = new EnvDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js
var require_BrowserDetectorSync2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.browserDetectorSync = void 0;
    var semantic_conventions_1 = require_src6(), __1 = require_src8(), api_1 = require_src(), BrowserDetectorSync = class {
      detect(config) {
        if (!(typeof navigator < "u"))
          return __1.Resource.empty();
        let browserResource = {
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "browser",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION]: "Web Browser",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION]: navigator.userAgent
        };
        return this._getResourceAttributes(browserResource, config);
      }
      /**
       * Validates process resource attribute map from process variables
       *
       * @param browserResource The un-sanitized resource attributes from process as key/value pairs.
       * @param config: Config
       * @returns The sanitized resource attributes.
       */
      _getResourceAttributes(browserResource, _config) {
        return browserResource[semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === "" ? (api_1.diag.debug("BrowserDetector failed: Unable to find required browser resources. "), __1.Resource.empty()) : new __1.Resource(Object.assign({}, browserResource));
      }
    };
    exports.browserDetectorSync = new BrowserDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/index.js
var require_detectors2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detectors/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_BrowserDetector2(), exports);
    __exportStar(require_EnvDetector2(), exports);
    __exportStar(require_BrowserDetectorSync2(), exports);
    __exportStar(require_EnvDetectorSync2(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/utils.js
var require_utils10 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isPromiseLike = void 0;
    var isPromiseLike = (val) => val !== null && typeof val == "object" && typeof val.then == "function";
    exports.isPromiseLike = isPromiseLike;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detect-resources.js
var require_detect_resources2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/detect-resources.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.detectResourcesSync = exports.detectResources = void 0;
    var Resource_1 = require_Resource2(), api_1 = require_src(), utils_1 = require_utils10(), detectResources = async (config = {}) => {
      let resources = await Promise.all((config.detectors || []).map(async (d) => {
        try {
          let resource = await d.detect(config);
          return api_1.diag.debug(`${d.constructor.name} found resource.`, resource), resource;
        } catch (e) {
          return api_1.diag.debug(`${d.constructor.name} failed: ${e.message}`), Resource_1.Resource.empty();
        }
      }));
      return logResources(resources), resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
    };
    exports.detectResources = detectResources;
    var detectResourcesSync = (config = {}) => {
      var _a;
      let resources = ((_a = config.detectors) !== null && _a !== void 0 ? _a : []).map((d) => {
        try {
          let resourceOrPromise = d.detect(config), resource;
          if ((0, utils_1.isPromiseLike)(resourceOrPromise)) {
            let createPromise = async () => (await resourceOrPromise).attributes;
            resource = new Resource_1.Resource({}, createPromise());
          } else
            resource = resourceOrPromise;
          return resource.waitForAsyncAttributes ? resource.waitForAsyncAttributes().then(() => api_1.diag.debug(`${d.constructor.name} found resource.`, resource)) : api_1.diag.debug(`${d.constructor.name} found resource.`, resource), resource;
        } catch (e) {
          return api_1.diag.error(`${d.constructor.name} failed: ${e.message}`), Resource_1.Resource.empty();
        }
      }), mergedResources = resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
      return mergedResources.waitForAsyncAttributes && mergedResources.waitForAsyncAttributes().then(() => {
        logResources(resources);
      }), mergedResources;
    };
    exports.detectResourcesSync = detectResourcesSync;
    var logResources = (resources) => {
      resources.forEach((resource) => {
        if (Object.keys(resource.attributes).length > 0) {
          let resourceDebugString = JSON.stringify(resource.attributes, null, 4);
          api_1.diag.verbose(resourceDebugString);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/index.js
var require_src8 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/resources/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_Resource2(), exports);
    __exportStar(require_IResource2(), exports);
    __exportStar(require_platform5(), exports);
    __exportStar(require_types9(), exports);
    __exportStar(require_config2(), exports);
    __exportStar(require_detectors2(), exports);
    __exportStar(require_detect_resources2(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/ViewRegistry.js
var require_ViewRegistry2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/ViewRegistry.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ViewRegistry = void 0;
    var ViewRegistry = class {
      constructor() {
        this._registeredViews = [];
      }
      addView(view) {
        this._registeredViews.push(view);
      }
      findViews(instrument, meter) {
        return this._registeredViews.filter((registeredView) => this._matchInstrument(registeredView.instrumentSelector, instrument) && this._matchMeter(registeredView.meterSelector, meter));
      }
      _matchInstrument(selector, instrument) {
        return (selector.getType() === void 0 || instrument.type === selector.getType()) && selector.getNameFilter().match(instrument.name) && selector.getUnitFilter().match(instrument.unit);
      }
      _matchMeter(selector, meter) {
        return selector.getNameFilter().match(meter.name) && (meter.version === void 0 || selector.getVersionFilter().match(meter.version)) && (meter.schemaUrl === void 0 || selector.getSchemaUrlFilter().match(meter.schemaUrl));
      }
    };
    exports.ViewRegistry = ViewRegistry;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/Instruments.js
var require_Instruments2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/Instruments.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isObservableInstrument = exports.ObservableUpDownCounterInstrument = exports.ObservableGaugeInstrument = exports.ObservableCounterInstrument = exports.ObservableInstrument = exports.HistogramInstrument = exports.CounterInstrument = exports.UpDownCounterInstrument = exports.SyncInstrument = void 0;
    var api_1 = require_src(), core_1 = require_src7(), SyncInstrument = class {
      constructor(_writableMetricStorage, _descriptor) {
        this._writableMetricStorage = _writableMetricStorage, this._descriptor = _descriptor;
      }
      _record(value, attributes = {}, context = api_1.context.active()) {
        if (typeof value != "number") {
          api_1.diag.warn(`non-number value provided to metric ${this._descriptor.name}: ${value}`);
          return;
        }
        this._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value) && (api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`), value = Math.trunc(value), !Number.isInteger(value)) || this._writableMetricStorage.record(value, attributes, context, (0, core_1.millisToHrTime)(Date.now()));
      }
    };
    exports.SyncInstrument = SyncInstrument;
    var UpDownCounterInstrument = class extends SyncInstrument {
      /**
       * Increment value of counter by the input. Inputs may be negative.
       */
      add(value, attributes, ctx) {
        this._record(value, attributes, ctx);
      }
    };
    exports.UpDownCounterInstrument = UpDownCounterInstrument;
    var CounterInstrument = class extends SyncInstrument {
      /**
       * Increment value of counter by the input. Inputs may not be negative.
       */
      add(value, attributes, ctx) {
        if (value < 0) {
          api_1.diag.warn(`negative value provided to counter ${this._descriptor.name}: ${value}`);
          return;
        }
        this._record(value, attributes, ctx);
      }
    };
    exports.CounterInstrument = CounterInstrument;
    var HistogramInstrument = class extends SyncInstrument {
      /**
       * Records a measurement. Value of the measurement must not be negative.
       */
      record(value, attributes, ctx) {
        if (value < 0) {
          api_1.diag.warn(`negative value provided to histogram ${this._descriptor.name}: ${value}`);
          return;
        }
        this._record(value, attributes, ctx);
      }
    };
    exports.HistogramInstrument = HistogramInstrument;
    var ObservableInstrument = class {
      constructor(descriptor, metricStorages, _observableRegistry) {
        this._observableRegistry = _observableRegistry, this._descriptor = descriptor, this._metricStorages = metricStorages;
      }
      /**
       * @see {Observable.addCallback}
       */
      addCallback(callback) {
        this._observableRegistry.addCallback(callback, this);
      }
      /**
       * @see {Observable.removeCallback}
       */
      removeCallback(callback) {
        this._observableRegistry.removeCallback(callback, this);
      }
    };
    exports.ObservableInstrument = ObservableInstrument;
    var ObservableCounterInstrument = class extends ObservableInstrument {
    };
    exports.ObservableCounterInstrument = ObservableCounterInstrument;
    var ObservableGaugeInstrument = class extends ObservableInstrument {
    };
    exports.ObservableGaugeInstrument = ObservableGaugeInstrument;
    var ObservableUpDownCounterInstrument = class extends ObservableInstrument {
    };
    exports.ObservableUpDownCounterInstrument = ObservableUpDownCounterInstrument;
    function isObservableInstrument(it) {
      return it instanceof ObservableInstrument;
    }
    exports.isObservableInstrument = isObservableInstrument;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/Meter.js
var require_Meter2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/Meter.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Meter = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor2(), Instruments_1 = require_Instruments2(), Meter = class {
      constructor(_meterSharedState) {
        this._meterSharedState = _meterSharedState;
      }
      /**
       * Create a {@link Histogram} instrument.
       */
      createHistogram(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.HISTOGRAM, options), storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.HistogramInstrument(storage, descriptor);
      }
      /**
       * Create a {@link Counter} instrument.
       */
      createCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.COUNTER, options), storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.CounterInstrument(storage, descriptor);
      }
      /**
       * Create a {@link UpDownCounter} instrument.
       */
      createUpDownCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER, options), storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.UpDownCounterInstrument(storage, descriptor);
      }
      /**
       * Create a {@link ObservableGauge} instrument.
       */
      createObservableGauge(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE, options), storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableGaugeInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * Create a {@link ObservableCounter} instrument.
       */
      createObservableCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER, options), storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * Create a {@link ObservableUpDownCounter} instrument.
       */
      createObservableUpDownCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER, options), storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableUpDownCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(callback, observables) {
        this._meterSharedState.observableRegistry.addBatchCallback(callback, observables);
      }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(callback, observables) {
        this._meterSharedState.observableRegistry.removeBatchCallback(callback, observables);
      }
    };
    exports.Meter = Meter;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorage.js
var require_MetricStorage2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorage.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MetricStorage = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor2(), MetricStorage = class {
      constructor(_instrumentDescriptor) {
        this._instrumentDescriptor = _instrumentDescriptor;
      }
      getInstrumentDescriptor() {
        return this._instrumentDescriptor;
      }
      updateDescription(description) {
        this._instrumentDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(this._instrumentDescriptor.name, this._instrumentDescriptor.type, {
          description,
          valueType: this._instrumentDescriptor.valueType,
          unit: this._instrumentDescriptor.unit
        });
      }
    };
    exports.MetricStorage = MetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/HashMap.js
var require_HashMap2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/HashMap.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AttributeHashMap = exports.HashMap = void 0;
    var utils_1 = require_utils8(), HashMap = class {
      constructor(_hash) {
        this._hash = _hash, this._valueMap = /* @__PURE__ */ new Map(), this._keyMap = /* @__PURE__ */ new Map();
      }
      get(key, hashCode) {
        return hashCode ?? (hashCode = this._hash(key)), this._valueMap.get(hashCode);
      }
      getOrDefault(key, defaultFactory) {
        let hash = this._hash(key);
        if (this._valueMap.has(hash))
          return this._valueMap.get(hash);
        let val = defaultFactory();
        return this._keyMap.has(hash) || this._keyMap.set(hash, key), this._valueMap.set(hash, val), val;
      }
      set(key, value, hashCode) {
        hashCode ?? (hashCode = this._hash(key)), this._keyMap.has(hashCode) || this._keyMap.set(hashCode, key), this._valueMap.set(hashCode, value);
      }
      has(key, hashCode) {
        return hashCode ?? (hashCode = this._hash(key)), this._valueMap.has(hashCode);
      }
      *keys() {
        let keyIterator = this._keyMap.entries(), next = keyIterator.next();
        for (; next.done !== !0; )
          yield [next.value[1], next.value[0]], next = keyIterator.next();
      }
      *entries() {
        let valueIterator = this._valueMap.entries(), next = valueIterator.next();
        for (; next.done !== !0; )
          yield [this._keyMap.get(next.value[0]), next.value[1], next.value[0]], next = valueIterator.next();
      }
      get size() {
        return this._valueMap.size;
      }
    };
    exports.HashMap = HashMap;
    var AttributeHashMap = class extends HashMap {
      constructor() {
        super(utils_1.hashAttributes);
      }
    };
    exports.AttributeHashMap = AttributeHashMap;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/DeltaMetricProcessor.js
var require_DeltaMetricProcessor2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/DeltaMetricProcessor.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DeltaMetricProcessor = void 0;
    var HashMap_1 = require_HashMap2(), DeltaMetricProcessor = class {
      constructor(_aggregator) {
        this._aggregator = _aggregator, this._activeCollectionStorage = new HashMap_1.AttributeHashMap(), this._cumulativeMemoStorage = new HashMap_1.AttributeHashMap();
      }
      record(value, attributes, _context, collectionTime) {
        let accumulation = this._activeCollectionStorage.getOrDefault(attributes, () => this._aggregator.createAccumulation(collectionTime));
        accumulation?.record(value);
      }
      batchCumulate(measurements, collectionTime) {
        Array.from(measurements.entries()).forEach(([attributes, value, hashCode]) => {
          let accumulation = this._aggregator.createAccumulation(collectionTime);
          accumulation?.record(value);
          let delta = accumulation;
          if (this._cumulativeMemoStorage.has(attributes, hashCode)) {
            let previous = this._cumulativeMemoStorage.get(attributes, hashCode);
            delta = this._aggregator.diff(previous, accumulation);
          }
          if (this._activeCollectionStorage.has(attributes, hashCode)) {
            let active = this._activeCollectionStorage.get(attributes, hashCode);
            delta = this._aggregator.merge(active, delta);
          }
          this._cumulativeMemoStorage.set(attributes, accumulation, hashCode), this._activeCollectionStorage.set(attributes, delta, hashCode);
        });
      }
      /**
       * Returns a collection of delta metrics. Start time is the when first
       * time event collected.
       */
      collect() {
        let unreportedDelta = this._activeCollectionStorage;
        return this._activeCollectionStorage = new HashMap_1.AttributeHashMap(), unreportedDelta;
      }
    };
    exports.DeltaMetricProcessor = DeltaMetricProcessor;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/TemporalMetricProcessor.js
var require_TemporalMetricProcessor2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/TemporalMetricProcessor.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TemporalMetricProcessor = void 0;
    var AggregationTemporality_1 = require_AggregationTemporality2(), HashMap_1 = require_HashMap2(), TemporalMetricProcessor = class _TemporalMetricProcessor {
      constructor(_aggregator) {
        this._aggregator = _aggregator, this._unreportedAccumulations = /* @__PURE__ */ new Map(), this._reportHistory = /* @__PURE__ */ new Map();
      }
      /**
       * Builds the {@link MetricData} streams to report against a specific MetricCollector.
       * @param collector The information of the MetricCollector.
       * @param collectors The registered collectors.
       * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.
       * @param currentAccumulations The current accumulation of metric data from instruments.
       * @param collectionTime The current collection timestamp.
       * @returns The {@link MetricData} points or `null`.
       */
      buildMetrics(collector, collectors, instrumentDescriptor, currentAccumulations, collectionTime) {
        this._stashAccumulations(collectors, currentAccumulations);
        let unreportedAccumulations = this._getMergedUnreportedAccumulations(collector), result = unreportedAccumulations, aggregationTemporality;
        if (this._reportHistory.has(collector)) {
          let last = this._reportHistory.get(collector), lastCollectionTime = last.collectionTime;
          aggregationTemporality = last.aggregationTemporality, aggregationTemporality === AggregationTemporality_1.AggregationTemporality.CUMULATIVE ? result = _TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator) : result = _TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);
        } else
          aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);
        return this._reportHistory.set(collector, {
          accumulations: result,
          collectionTime,
          aggregationTemporality
        }), this._aggregator.toMetricData(
          instrumentDescriptor,
          aggregationTemporality,
          AttributesMapToAccumulationRecords(result),
          /* endTime */
          collectionTime
        );
      }
      _stashAccumulations(collectors, currentAccumulation) {
        collectors.forEach((it) => {
          let stash = this._unreportedAccumulations.get(it);
          stash === void 0 && (stash = [], this._unreportedAccumulations.set(it, stash)), stash.push(currentAccumulation);
        });
      }
      _getMergedUnreportedAccumulations(collector) {
        let result = new HashMap_1.AttributeHashMap(), unreportedList = this._unreportedAccumulations.get(collector);
        if (this._unreportedAccumulations.set(collector, []), unreportedList === void 0)
          return result;
        for (let it of unreportedList)
          result = _TemporalMetricProcessor.merge(result, it, this._aggregator);
        return result;
      }
      static merge(last, current, aggregator) {
        let result = last, iterator = current.entries(), next = iterator.next();
        for (; next.done !== !0; ) {
          let [key, record, hash] = next.value;
          if (last.has(key, hash)) {
            let lastAccumulation = last.get(key, hash), accumulation = aggregator.merge(lastAccumulation, record);
            result.set(key, accumulation, hash);
          } else
            result.set(key, record, hash);
          next = iterator.next();
        }
        return result;
      }
      /**
       * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves
       * the new stream to be the initial observation time unchanged.
       */
      static calibrateStartTime(last, current, lastCollectionTime) {
        for (let [key, hash] of last.keys()) {
          let currentAccumulation = current.get(key, hash);
          currentAccumulation?.setStartTime(lastCollectionTime);
        }
        return current;
      }
    };
    exports.TemporalMetricProcessor = TemporalMetricProcessor;
    function AttributesMapToAccumulationRecords(map) {
      return Array.from(map.entries());
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/AsyncMetricStorage.js
var require_AsyncMetricStorage2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/AsyncMetricStorage.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AsyncMetricStorage = void 0;
    var MetricStorage_1 = require_MetricStorage2(), DeltaMetricProcessor_1 = require_DeltaMetricProcessor2(), TemporalMetricProcessor_1 = require_TemporalMetricProcessor2(), HashMap_1 = require_HashMap2(), AsyncMetricStorage = class extends MetricStorage_1.MetricStorage {
      constructor(_instrumentDescriptor, aggregator, _attributesProcessor) {
        super(_instrumentDescriptor), this._attributesProcessor = _attributesProcessor, this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator), this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator);
      }
      record(measurements, observationTime) {
        let processed = new HashMap_1.AttributeHashMap();
        Array.from(measurements.entries()).forEach(([attributes, value]) => {
          processed.set(this._attributesProcessor.process(attributes), value);
        }), this._deltaMetricStorage.batchCumulate(processed, observationTime);
      }
      /**
       * Collects the metrics from this storage. The ObservableCallback is invoked
       * during the collection.
       *
       * Note: This is a stateful operation and may reset any interval-related
       * state for the MetricCollector.
       */
      collect(collector, collectors, collectionTime) {
        let accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, collectors, this._instrumentDescriptor, accumulations, collectionTime);
      }
    };
    exports.AsyncMetricStorage = AsyncMetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/RegistrationConflicts.js
var require_RegistrationConflicts2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/RegistrationConflicts.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getConflictResolutionRecipe = exports.getDescriptionResolutionRecipe = exports.getTypeConflictResolutionRecipe = exports.getUnitConflictResolutionRecipe = exports.getValueTypeConflictResolutionRecipe = exports.getIncompatibilityDetails = void 0;
    function getIncompatibilityDetails(existing, otherDescriptor) {
      let incompatibility = "";
      return existing.unit !== otherDescriptor.unit && (incompatibility += `	- Unit '${existing.unit}' does not match '${otherDescriptor.unit}'
`), existing.type !== otherDescriptor.type && (incompatibility += `	- Type '${existing.type}' does not match '${otherDescriptor.type}'
`), existing.valueType !== otherDescriptor.valueType && (incompatibility += `	- Value Type '${existing.valueType}' does not match '${otherDescriptor.valueType}'
`), existing.description !== otherDescriptor.description && (incompatibility += `	- Description '${existing.description}' does not match '${otherDescriptor.description}'
`), incompatibility;
    }
    exports.getIncompatibilityDetails = getIncompatibilityDetails;
    function getValueTypeConflictResolutionRecipe(existing, otherDescriptor) {
      return `	- use valueType '${existing.valueType}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
    }
    exports.getValueTypeConflictResolutionRecipe = getValueTypeConflictResolutionRecipe;
    function getUnitConflictResolutionRecipe(existing, otherDescriptor) {
      return `	- use unit '${existing.unit}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
    }
    exports.getUnitConflictResolutionRecipe = getUnitConflictResolutionRecipe;
    function getTypeConflictResolutionRecipe(existing, otherDescriptor) {
      let selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
      }, selectorString = JSON.stringify(selector);
      return `	- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'`;
    }
    exports.getTypeConflictResolutionRecipe = getTypeConflictResolutionRecipe;
    function getDescriptionResolutionRecipe(existing, otherDescriptor) {
      let selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
      }, selectorString = JSON.stringify(selector);
      return `	- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'
    	- OR - create a new view with the name ${existing.name} and description '${existing.description}' and InstrumentSelector ${selectorString}
    	- OR - create a new view with the name ${otherDescriptor.name} and description '${existing.description}' and InstrumentSelector ${selectorString}`;
    }
    exports.getDescriptionResolutionRecipe = getDescriptionResolutionRecipe;
    function getConflictResolutionRecipe(existing, otherDescriptor) {
      return existing.valueType !== otherDescriptor.valueType ? getValueTypeConflictResolutionRecipe(existing, otherDescriptor) : existing.unit !== otherDescriptor.unit ? getUnitConflictResolutionRecipe(existing, otherDescriptor) : existing.type !== otherDescriptor.type ? getTypeConflictResolutionRecipe(existing, otherDescriptor) : existing.description !== otherDescriptor.description ? getDescriptionResolutionRecipe(existing, otherDescriptor) : "";
    }
    exports.getConflictResolutionRecipe = getConflictResolutionRecipe;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorageRegistry.js
var require_MetricStorageRegistry2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorageRegistry.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MetricStorageRegistry = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor2(), api = require_src(), RegistrationConflicts_1 = require_RegistrationConflicts2(), MetricStorageRegistry = class _MetricStorageRegistry {
      constructor() {
        this._sharedRegistry = /* @__PURE__ */ new Map(), this._perCollectorRegistry = /* @__PURE__ */ new Map();
      }
      static create() {
        return new _MetricStorageRegistry();
      }
      getStorages(collector) {
        let storages = [];
        for (let metricStorages of this._sharedRegistry.values())
          storages = storages.concat(metricStorages);
        let perCollectorStorages = this._perCollectorRegistry.get(collector);
        if (perCollectorStorages != null)
          for (let metricStorages of perCollectorStorages.values())
            storages = storages.concat(metricStorages);
        return storages;
      }
      register(storage) {
        this._registerStorage(storage, this._sharedRegistry);
      }
      registerForCollector(collector, storage) {
        let storageMap = this._perCollectorRegistry.get(collector);
        storageMap == null && (storageMap = /* @__PURE__ */ new Map(), this._perCollectorRegistry.set(collector, storageMap)), this._registerStorage(storage, storageMap);
      }
      findOrUpdateCompatibleStorage(expectedDescriptor) {
        let storages = this._sharedRegistry.get(expectedDescriptor.name);
        return storages === void 0 ? null : this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
      }
      findOrUpdateCompatibleCollectorStorage(collector, expectedDescriptor) {
        let storageMap = this._perCollectorRegistry.get(collector);
        if (storageMap === void 0)
          return null;
        let storages = storageMap.get(expectedDescriptor.name);
        return storages === void 0 ? null : this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
      }
      _registerStorage(storage, storageMap) {
        let descriptor = storage.getInstrumentDescriptor(), storages = storageMap.get(descriptor.name);
        if (storages === void 0) {
          storageMap.set(descriptor.name, [storage]);
          return;
        }
        storages.push(storage);
      }
      _findOrUpdateCompatibleStorage(expectedDescriptor, existingStorages) {
        let compatibleStorage = null;
        for (let existingStorage of existingStorages) {
          let existingDescriptor = existingStorage.getInstrumentDescriptor();
          (0, InstrumentDescriptor_1.isDescriptorCompatibleWith)(existingDescriptor, expectedDescriptor) ? (existingDescriptor.description !== expectedDescriptor.description && (expectedDescriptor.description.length > existingDescriptor.description.length && existingStorage.updateDescription(expectedDescriptor.description), api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, ` has already been registered, but has a different description and is incompatible with another registered view.
`, `Details:
`, (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), `The longer description will be used.
To resolve the conflict:`, (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor))), compatibleStorage = existingStorage) : api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, ` has already been registered and is incompatible with another registered view.
`, `Details:
`, (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), `To resolve the conflict:
`, (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor));
        }
        return compatibleStorage;
      }
    };
    exports.MetricStorageRegistry = MetricStorageRegistry;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MultiWritableMetricStorage.js
var require_MultiWritableMetricStorage2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MultiWritableMetricStorage.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MultiMetricStorage = void 0;
    var MultiMetricStorage = class {
      constructor(_backingStorages) {
        this._backingStorages = _backingStorages;
      }
      record(value, attributes, context, recordTime) {
        this._backingStorages.forEach((it) => {
          it.record(value, attributes, context, recordTime);
        });
      }
    };
    exports.MultiMetricStorage = MultiMetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/ObservableResult.js
var require_ObservableResult2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/ObservableResult.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.BatchObservableResultImpl = exports.ObservableResultImpl = void 0;
    var api_1 = require_src(), HashMap_1 = require_HashMap2(), Instruments_1 = require_Instruments2(), ObservableResultImpl = class {
      constructor(_descriptor) {
        this._descriptor = _descriptor, this._buffer = new HashMap_1.AttributeHashMap();
      }
      /**
       * Observe a measurement of the value associated with the given attributes.
       */
      observe(value, attributes = {}) {
        if (typeof value != "number") {
          api_1.diag.warn(`non-number value provided to metric ${this._descriptor.name}: ${value}`);
          return;
        }
        this._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value) && (api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`), value = Math.trunc(value), !Number.isInteger(value)) || this._buffer.set(attributes, value);
      }
    };
    exports.ObservableResultImpl = ObservableResultImpl;
    var BatchObservableResultImpl = class {
      constructor() {
        this._buffer = /* @__PURE__ */ new Map();
      }
      /**
       * Observe a measurement of the value associated with the given attributes.
       */
      observe(metric, value, attributes = {}) {
        if (!(0, Instruments_1.isObservableInstrument)(metric))
          return;
        let map = this._buffer.get(metric);
        if (map == null && (map = new HashMap_1.AttributeHashMap(), this._buffer.set(metric, map)), typeof value != "number") {
          api_1.diag.warn(`non-number value provided to metric ${metric._descriptor.name}: ${value}`);
          return;
        }
        metric._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value) && (api_1.diag.warn(`INT value type cannot accept a floating-point value for ${metric._descriptor.name}, ignoring the fractional digits.`), value = Math.trunc(value), !Number.isInteger(value)) || map.set(attributes, value);
      }
    };
    exports.BatchObservableResultImpl = BatchObservableResultImpl;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/ObservableRegistry.js
var require_ObservableRegistry2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/ObservableRegistry.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ObservableRegistry = void 0;
    var api_1 = require_src(), Instruments_1 = require_Instruments2(), ObservableResult_1 = require_ObservableResult2(), utils_1 = require_utils8(), ObservableRegistry = class {
      constructor() {
        this._callbacks = [], this._batchCallbacks = [];
      }
      addCallback(callback, instrument) {
        this._findCallback(callback, instrument) >= 0 || this._callbacks.push({ callback, instrument });
      }
      removeCallback(callback, instrument) {
        let idx = this._findCallback(callback, instrument);
        idx < 0 || this._callbacks.splice(idx, 1);
      }
      addBatchCallback(callback, instruments) {
        let observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument));
        if (observableInstruments.size === 0) {
          api_1.diag.error("BatchObservableCallback is not associated with valid instruments", instruments);
          return;
        }
        this._findBatchCallback(callback, observableInstruments) >= 0 || this._batchCallbacks.push({ callback, instruments: observableInstruments });
      }
      removeBatchCallback(callback, instruments) {
        let observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument)), idx = this._findBatchCallback(callback, observableInstruments);
        idx < 0 || this._batchCallbacks.splice(idx, 1);
      }
      /**
       * @returns a promise of rejected reasons for invoking callbacks.
       */
      async observe(collectionTime, timeoutMillis) {
        let callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis), batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);
        return (await (0, utils_1.PromiseAllSettled)([
          ...callbackFutures,
          ...batchCallbackFutures
        ])).filter(utils_1.isPromiseAllSettledRejectionResult).map((it) => it.reason);
      }
      _observeCallbacks(observationTime, timeoutMillis) {
        return this._callbacks.map(async ({ callback, instrument }) => {
          let observableResult = new ObservableResult_1.ObservableResultImpl(instrument._descriptor), callPromise = Promise.resolve(callback(observableResult));
          timeoutMillis != null && (callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis)), await callPromise, instrument._metricStorages.forEach((metricStorage) => {
            metricStorage.record(observableResult._buffer, observationTime);
          });
        });
      }
      _observeBatchCallbacks(observationTime, timeoutMillis) {
        return this._batchCallbacks.map(async ({ callback, instruments }) => {
          let observableResult = new ObservableResult_1.BatchObservableResultImpl(), callPromise = Promise.resolve(callback(observableResult));
          timeoutMillis != null && (callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis)), await callPromise, instruments.forEach((instrument) => {
            let buffer = observableResult._buffer.get(instrument);
            buffer != null && instrument._metricStorages.forEach((metricStorage) => {
              metricStorage.record(buffer, observationTime);
            });
          });
        });
      }
      _findCallback(callback, instrument) {
        return this._callbacks.findIndex((record) => record.callback === callback && record.instrument === instrument);
      }
      _findBatchCallback(callback, instruments) {
        return this._batchCallbacks.findIndex((record) => record.callback === callback && (0, utils_1.setEquals)(record.instruments, instruments));
      }
    };
    exports.ObservableRegistry = ObservableRegistry;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/SyncMetricStorage.js
var require_SyncMetricStorage2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/SyncMetricStorage.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.SyncMetricStorage = void 0;
    var MetricStorage_1 = require_MetricStorage2(), DeltaMetricProcessor_1 = require_DeltaMetricProcessor2(), TemporalMetricProcessor_1 = require_TemporalMetricProcessor2(), SyncMetricStorage = class extends MetricStorage_1.MetricStorage {
      constructor(instrumentDescriptor, aggregator, _attributesProcessor) {
        super(instrumentDescriptor), this._attributesProcessor = _attributesProcessor, this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator), this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator);
      }
      record(value, attributes, context, recordTime) {
        attributes = this._attributesProcessor.process(attributes, context), this._deltaMetricStorage.record(value, attributes, context, recordTime);
      }
      /**
       * Collects the metrics from this storage.
       *
       * Note: This is a stateful operation and may reset any interval-related
       * state for the MetricCollector.
       */
      collect(collector, collectors, collectionTime) {
        let accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, collectors, this._instrumentDescriptor, accumulations, collectionTime);
      }
    };
    exports.SyncMetricStorage = SyncMetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/AttributesProcessor.js
var require_AttributesProcessor2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/AttributesProcessor.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.FilteringAttributesProcessor = exports.NoopAttributesProcessor = exports.AttributesProcessor = void 0;
    var AttributesProcessor = class {
      static Noop() {
        return NOOP;
      }
    };
    exports.AttributesProcessor = AttributesProcessor;
    var NoopAttributesProcessor = class extends AttributesProcessor {
      process(incoming, _context) {
        return incoming;
      }
    };
    exports.NoopAttributesProcessor = NoopAttributesProcessor;
    var FilteringAttributesProcessor = class extends AttributesProcessor {
      constructor(_allowedAttributeNames) {
        super(), this._allowedAttributeNames = _allowedAttributeNames;
      }
      process(incoming, _context) {
        let filteredAttributes = {};
        return Object.keys(incoming).filter((attributeName) => this._allowedAttributeNames.includes(attributeName)).forEach((attributeName) => filteredAttributes[attributeName] = incoming[attributeName]), filteredAttributes;
      }
    };
    exports.FilteringAttributesProcessor = FilteringAttributesProcessor;
    var NOOP = new NoopAttributesProcessor();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterSharedState.js
var require_MeterSharedState2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterSharedState.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MeterSharedState = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor2(), Meter_1 = require_Meter2(), utils_1 = require_utils8(), AsyncMetricStorage_1 = require_AsyncMetricStorage2(), MetricStorageRegistry_1 = require_MetricStorageRegistry2(), MultiWritableMetricStorage_1 = require_MultiWritableMetricStorage2(), ObservableRegistry_1 = require_ObservableRegistry2(), SyncMetricStorage_1 = require_SyncMetricStorage2(), AttributesProcessor_1 = require_AttributesProcessor2(), MeterSharedState = class {
      constructor(_meterProviderSharedState, _instrumentationScope) {
        this._meterProviderSharedState = _meterProviderSharedState, this._instrumentationScope = _instrumentationScope, this.metricStorageRegistry = new MetricStorageRegistry_1.MetricStorageRegistry(), this.observableRegistry = new ObservableRegistry_1.ObservableRegistry(), this.meter = new Meter_1.Meter(this);
      }
      registerMetricStorage(descriptor) {
        let storages = this._registerMetricStorage(descriptor, SyncMetricStorage_1.SyncMetricStorage);
        return storages.length === 1 ? storages[0] : new MultiWritableMetricStorage_1.MultiMetricStorage(storages);
      }
      registerAsyncMetricStorage(descriptor) {
        return this._registerMetricStorage(descriptor, AsyncMetricStorage_1.AsyncMetricStorage);
      }
      /**
       * @param collector opaque handle of {@link MetricCollector} which initiated the collection.
       * @param collectionTime the HrTime at which the collection was initiated.
       * @param options options for collection.
       * @returns the list of metric data collected.
       */
      async collect(collector, collectionTime, options) {
        let errors = await this.observableRegistry.observe(collectionTime, options?.timeoutMillis), metricDataList = Array.from(this.metricStorageRegistry.getStorages(collector)).map((metricStorage) => metricStorage.collect(collector, this._meterProviderSharedState.metricCollectors, collectionTime)).filter(utils_1.isNotNullish);
        return {
          scopeMetrics: {
            scope: this._instrumentationScope,
            metrics: metricDataList.filter(utils_1.isNotNullish)
          },
          errors
        };
      }
      _registerMetricStorage(descriptor, MetricStorageType) {
        let storages = this._meterProviderSharedState.viewRegistry.findViews(descriptor, this._instrumentationScope).map((view) => {
          let viewDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptorWithView)(view, descriptor), compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleStorage(viewDescriptor);
          if (compatibleStorage != null)
            return compatibleStorage;
          let aggregator = view.aggregation.createAggregator(viewDescriptor), viewStorage = new MetricStorageType(viewDescriptor, aggregator, view.attributesProcessor);
          return this.metricStorageRegistry.register(viewStorage), viewStorage;
        });
        if (storages.length === 0) {
          let collectorStorages = this._meterProviderSharedState.selectAggregations(descriptor.type).map(([collector, aggregation]) => {
            let compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage(collector, descriptor);
            if (compatibleStorage != null)
              return compatibleStorage;
            let aggregator = aggregation.createAggregator(descriptor), storage = new MetricStorageType(descriptor, aggregator, AttributesProcessor_1.AttributesProcessor.Noop());
            return this.metricStorageRegistry.registerForCollector(collector, storage), storage;
          });
          storages = storages.concat(collectorStorages);
        }
        return storages;
      }
    };
    exports.MeterSharedState = MeterSharedState;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterProviderSharedState.js
var require_MeterProviderSharedState2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterProviderSharedState.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MeterProviderSharedState = void 0;
    var utils_1 = require_utils8(), ViewRegistry_1 = require_ViewRegistry2(), MeterSharedState_1 = require_MeterSharedState2(), MeterProviderSharedState = class {
      constructor(resource) {
        this.resource = resource, this.viewRegistry = new ViewRegistry_1.ViewRegistry(), this.metricCollectors = [], this.meterSharedStates = /* @__PURE__ */ new Map();
      }
      getMeterSharedState(instrumentationScope2) {
        let id = (0, utils_1.instrumentationScopeId)(instrumentationScope2), meterSharedState = this.meterSharedStates.get(id);
        return meterSharedState == null && (meterSharedState = new MeterSharedState_1.MeterSharedState(this, instrumentationScope2), this.meterSharedStates.set(id, meterSharedState)), meterSharedState;
      }
      selectAggregations(instrumentType) {
        let result = [];
        for (let collector of this.metricCollectors)
          result.push([collector, collector.selectAggregation(instrumentType)]);
        return result;
      }
    };
    exports.MeterProviderSharedState = MeterProviderSharedState;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricCollector.js
var require_MetricCollector2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricCollector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MetricCollector = void 0;
    var core_1 = require_src7(), utils_1 = require_utils8(), MetricCollector = class {
      constructor(_sharedState, _metricReader) {
        this._sharedState = _sharedState, this._metricReader = _metricReader;
      }
      async collect(options) {
        let collectionTime = (0, core_1.millisToHrTime)(Date.now()), meterCollectionPromises = Array.from(this._sharedState.meterSharedStates.values()).map((meterSharedState) => meterSharedState.collect(this, collectionTime, options)), result = await Promise.all(meterCollectionPromises);
        return {
          resourceMetrics: {
            resource: this._sharedState.resource,
            scopeMetrics: result.map((it) => it.scopeMetrics)
          },
          errors: (0, utils_1.FlatMap)(result, (it) => it.errors)
        };
      }
      /**
       * Delegates for MetricReader.forceFlush.
       */
      async forceFlush(options) {
        await this._metricReader.forceFlush(options);
      }
      /**
       * Delegates for MetricReader.shutdown.
       */
      async shutdown(options) {
        await this._metricReader.shutdown(options);
      }
      selectAggregationTemporality(instrumentType) {
        return this._metricReader.selectAggregationTemporality(instrumentType);
      }
      selectAggregation(instrumentType) {
        return this._metricReader.selectAggregation(instrumentType);
      }
    };
    exports.MetricCollector = MetricCollector;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/MeterProvider.js
var require_MeterProvider2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/MeterProvider.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MeterProvider = void 0;
    var api_1 = require_src(), resources_1 = require_src8(), MeterProviderSharedState_1 = require_MeterProviderSharedState2(), MetricCollector_1 = require_MetricCollector2(), MeterProvider2 = class {
      constructor(options) {
        var _a;
        this._shutdown = !1;
        let resource = resources_1.Resource.default().merge((_a = options?.resource) !== null && _a !== void 0 ? _a : resources_1.Resource.empty());
        if (this._sharedState = new MeterProviderSharedState_1.MeterProviderSharedState(resource), options?.views != null && options.views.length > 0)
          for (let view of options.views)
            this._sharedState.viewRegistry.addView(view);
      }
      /**
       * Get a meter with the configuration of the MeterProvider.
       */
      getMeter(name, version = "", options = {}) {
        return this._shutdown ? (api_1.diag.warn("A shutdown MeterProvider cannot provide a Meter"), (0, api_1.createNoopMeter)()) : this._sharedState.getMeterSharedState({
          name,
          version,
          schemaUrl: options.schemaUrl
        }).meter;
      }
      /**
       * Register a {@link MetricReader} to the meter provider. After the
       * registration, the MetricReader can start metrics collection.
       *
       * @param metricReader the metric reader to be registered.
       */
      addMetricReader(metricReader) {
        let collector = new MetricCollector_1.MetricCollector(this._sharedState, metricReader);
        metricReader.setMetricProducer(collector), this._sharedState.metricCollectors.push(collector);
      }
      /**
       * Flush all buffered data and shut down the MeterProvider and all registered
       * MetricReaders.
       *
       * Returns a promise which is resolved when all flushes are complete.
       */
      async shutdown(options) {
        if (this._shutdown) {
          api_1.diag.warn("shutdown may only be called once per MeterProvider");
          return;
        }
        this._shutdown = !0, await Promise.all(this._sharedState.metricCollectors.map((collector) => collector.shutdown(options)));
      }
      /**
       * Notifies all registered MetricReaders to flush any buffered data.
       *
       * Returns a promise which is resolved when all flushes are complete.
       */
      async forceFlush(options) {
        if (this._shutdown) {
          api_1.diag.warn("invalid attempt to force flush after MeterProvider shutdown");
          return;
        }
        await Promise.all(this._sharedState.metricCollectors.map((collector) => collector.forceFlush(options)));
      }
    };
    exports.MeterProvider = MeterProvider2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Predicate.js
var require_Predicate2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Predicate.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ExactPredicate = exports.PatternPredicate = void 0;
    var ESCAPE = /[\^$\\.+?()[\]{}|]/g, PatternPredicate = class _PatternPredicate {
      constructor(pattern) {
        pattern === "*" ? (this._matchAll = !0, this._regexp = /.*/) : (this._matchAll = !1, this._regexp = new RegExp(_PatternPredicate.escapePattern(pattern)));
      }
      match(str) {
        return this._matchAll ? !0 : this._regexp.test(str);
      }
      static escapePattern(pattern) {
        return `^${pattern.replace(ESCAPE, "\\$&").replace("*", ".*")}$`;
      }
      static hasWildcard(pattern) {
        return pattern.includes("*");
      }
    };
    exports.PatternPredicate = PatternPredicate;
    var ExactPredicate = class {
      constructor(pattern) {
        this._matchAll = pattern === void 0, this._pattern = pattern;
      }
      match(str) {
        return !!(this._matchAll || str === this._pattern);
      }
    };
    exports.ExactPredicate = ExactPredicate;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/InstrumentSelector.js
var require_InstrumentSelector2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/InstrumentSelector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.InstrumentSelector = void 0;
    var Predicate_1 = require_Predicate2(), InstrumentSelector = class {
      constructor(criteria) {
        var _a;
        this._nameFilter = new Predicate_1.PatternPredicate((_a = criteria?.name) !== null && _a !== void 0 ? _a : "*"), this._type = criteria?.type, this._unitFilter = new Predicate_1.ExactPredicate(criteria?.unit);
      }
      getType() {
        return this._type;
      }
      getNameFilter() {
        return this._nameFilter;
      }
      getUnitFilter() {
        return this._unitFilter;
      }
    };
    exports.InstrumentSelector = InstrumentSelector;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/MeterSelector.js
var require_MeterSelector2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/MeterSelector.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MeterSelector = void 0;
    var Predicate_1 = require_Predicate2(), MeterSelector = class {
      constructor(criteria) {
        this._nameFilter = new Predicate_1.ExactPredicate(criteria?.name), this._versionFilter = new Predicate_1.ExactPredicate(criteria?.version), this._schemaUrlFilter = new Predicate_1.ExactPredicate(criteria?.schemaUrl);
      }
      getNameFilter() {
        return this._nameFilter;
      }
      /**
       * TODO: semver filter? no spec yet.
       */
      getVersionFilter() {
        return this._versionFilter;
      }
      getSchemaUrlFilter() {
        return this._schemaUrlFilter;
      }
    };
    exports.MeterSelector = MeterSelector;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/View.js
var require_View2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/View.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.View = void 0;
    var Predicate_1 = require_Predicate2(), AttributesProcessor_1 = require_AttributesProcessor2(), InstrumentSelector_1 = require_InstrumentSelector2(), MeterSelector_1 = require_MeterSelector2(), Aggregation_1 = require_Aggregation2();
    function isSelectorNotProvided(options) {
      return options.instrumentName == null && options.instrumentType == null && options.instrumentUnit == null && options.meterName == null && options.meterVersion == null && options.meterSchemaUrl == null;
    }
    var View2 = class {
      /**
       * Create a new {@link View} instance.
       *
       * Parameters can be categorized as two types:
       *  Instrument selection criteria: Used to describe the instrument(s) this view will be applied to.
       *  Will be treated as additive (the Instrument has to meet all the provided criteria to be selected).
       *
       *  Metric stream altering: Alter the metric stream of instruments selected by instrument selection criteria.
       *
       * @param viewOptions {@link ViewOptions} for altering the metric stream and instrument selection.
       * @param viewOptions.name
       * Alters the metric stream:
       *  This will be used as the name of the metrics stream.
       *  If not provided, the original Instrument name will be used.
       * @param viewOptions.description
       * Alters the metric stream:
       *  This will be used as the description of the metrics stream.
       *  If not provided, the original Instrument description will be used by default.
       * @param viewOptions.attributeKeys
       * Alters the metric stream:
       *  If provided, the attributes that are not in the list will be ignored.
       *  If not provided, all attribute keys will be used by default.
       * @param viewOptions.aggregation
       * Alters the metric stream:
       *  Alters the {@link Aggregation} of the metric stream.
       * @param viewOptions.instrumentName
       * Instrument selection criteria:
       *  Original name of the Instrument(s) with wildcard support.
       * @param viewOptions.instrumentType
       * Instrument selection criteria:
       *  The original type of the Instrument(s).
       * @param viewOptions.instrumentUnit
       * Instrument selection criteria:
       *  The unit of the Instrument(s).
       * @param viewOptions.meterName
       * Instrument selection criteria:
       *  The name of the Meter. No wildcard support, name must match the meter exactly.
       * @param viewOptions.meterVersion
       * Instrument selection criteria:
       *  The version of the Meter. No wildcard support, version must match exactly.
       * @param viewOptions.meterSchemaUrl
       * Instrument selection criteria:
       *  The schema URL of the Meter. No wildcard support, schema URL must match exactly.
       *
       * @example
       * // Create a view that changes the Instrument 'my.instrument' to use to an
       * // ExplicitBucketHistogramAggregation with the boundaries [20, 30, 40]
       * new View({
       *   aggregation: new ExplicitBucketHistogramAggregation([20, 30, 40]),
       *   instrumentName: 'my.instrument'
       * })
       */
      constructor(viewOptions) {
        var _a;
        if (isSelectorNotProvided(viewOptions))
          throw new Error("Cannot create view with no selector arguments supplied");
        if (viewOptions.name != null && (viewOptions?.instrumentName == null || Predicate_1.PatternPredicate.hasWildcard(viewOptions.instrumentName)))
          throw new Error("Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.");
        viewOptions.attributeKeys != null ? this.attributesProcessor = new AttributesProcessor_1.FilteringAttributesProcessor(viewOptions.attributeKeys) : this.attributesProcessor = AttributesProcessor_1.AttributesProcessor.Noop(), this.name = viewOptions.name, this.description = viewOptions.description, this.aggregation = (_a = viewOptions.aggregation) !== null && _a !== void 0 ? _a : Aggregation_1.Aggregation.Default(), this.instrumentSelector = new InstrumentSelector_1.InstrumentSelector({
          name: viewOptions.instrumentName,
          type: viewOptions.instrumentType,
          unit: viewOptions.instrumentUnit
        }), this.meterSelector = new MeterSelector_1.MeterSelector({
          name: viewOptions.meterName,
          version: viewOptions.meterVersion,
          schemaUrl: viewOptions.meterSchemaUrl
        });
      }
    };
    exports.View = View2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/index.js
var require_src9 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.17.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/sdk-metrics/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TimeoutError = exports.View = exports.Aggregation = exports.SumAggregation = exports.LastValueAggregation = exports.HistogramAggregation = exports.DropAggregation = exports.ExponentialHistogramAggregation = exports.ExplicitBucketHistogramAggregation = exports.DefaultAggregation = exports.MeterProvider = exports.InstrumentType = exports.ConsoleMetricExporter = exports.InMemoryMetricExporter = exports.PeriodicExportingMetricReader = exports.MetricReader = exports.DataPointType = exports.AggregationTemporality = void 0;
    var AggregationTemporality_1 = require_AggregationTemporality2();
    Object.defineProperty(exports, "AggregationTemporality", { enumerable: !0, get: function() {
      return AggregationTemporality_1.AggregationTemporality;
    } });
    var MetricData_1 = require_MetricData2();
    Object.defineProperty(exports, "DataPointType", { enumerable: !0, get: function() {
      return MetricData_1.DataPointType;
    } });
    var MetricReader_1 = require_MetricReader2();
    Object.defineProperty(exports, "MetricReader", { enumerable: !0, get: function() {
      return MetricReader_1.MetricReader;
    } });
    var PeriodicExportingMetricReader_1 = require_PeriodicExportingMetricReader2();
    Object.defineProperty(exports, "PeriodicExportingMetricReader", { enumerable: !0, get: function() {
      return PeriodicExportingMetricReader_1.PeriodicExportingMetricReader;
    } });
    var InMemoryMetricExporter_1 = require_InMemoryMetricExporter2();
    Object.defineProperty(exports, "InMemoryMetricExporter", { enumerable: !0, get: function() {
      return InMemoryMetricExporter_1.InMemoryMetricExporter;
    } });
    var ConsoleMetricExporter_1 = require_ConsoleMetricExporter2();
    Object.defineProperty(exports, "ConsoleMetricExporter", { enumerable: !0, get: function() {
      return ConsoleMetricExporter_1.ConsoleMetricExporter;
    } });
    var InstrumentDescriptor_1 = require_InstrumentDescriptor2();
    Object.defineProperty(exports, "InstrumentType", { enumerable: !0, get: function() {
      return InstrumentDescriptor_1.InstrumentType;
    } });
    var MeterProvider_1 = require_MeterProvider2();
    Object.defineProperty(exports, "MeterProvider", { enumerable: !0, get: function() {
      return MeterProvider_1.MeterProvider;
    } });
    var Aggregation_1 = require_Aggregation2();
    Object.defineProperty(exports, "DefaultAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.DefaultAggregation;
    } });
    Object.defineProperty(exports, "ExplicitBucketHistogramAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.ExplicitBucketHistogramAggregation;
    } });
    Object.defineProperty(exports, "ExponentialHistogramAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.ExponentialHistogramAggregation;
    } });
    Object.defineProperty(exports, "DropAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.DropAggregation;
    } });
    Object.defineProperty(exports, "HistogramAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.HistogramAggregation;
    } });
    Object.defineProperty(exports, "LastValueAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.LastValueAggregation;
    } });
    Object.defineProperty(exports, "SumAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.SumAggregation;
    } });
    Object.defineProperty(exports, "Aggregation", { enumerable: !0, get: function() {
      return Aggregation_1.Aggregation;
    } });
    var View_1 = require_View2();
    Object.defineProperty(exports, "View", { enumerable: !0, get: function() {
      return View_1.View;
    } });
    var utils_1 = require_utils8();
    Object.defineProperty(exports, "TimeoutError", { enumerable: !0, get: function() {
      return utils_1.TimeoutError;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/OTLPMetricExporterOptions.js
var require_OTLPMetricExporterOptions = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/OTLPMetricExporterOptions.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.AggregationTemporalityPreference = void 0;
    var AggregationTemporalityPreference;
    (function(AggregationTemporalityPreference2) {
      AggregationTemporalityPreference2[AggregationTemporalityPreference2.DELTA = 0] = "DELTA", AggregationTemporalityPreference2[AggregationTemporalityPreference2.CUMULATIVE = 1] = "CUMULATIVE", AggregationTemporalityPreference2[AggregationTemporalityPreference2.LOWMEMORY = 2] = "LOWMEMORY";
    })(AggregationTemporalityPreference = exports.AggregationTemporalityPreference || (exports.AggregationTemporalityPreference = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/OTLPMetricExporterBase.js
var require_OTLPMetricExporterBase = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/OTLPMetricExporterBase.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.OTLPMetricExporterBase = exports.LowMemoryTemporalitySelector = exports.DeltaTemporalitySelector = exports.CumulativeTemporalitySelector = void 0;
    var core_1 = require_src7(), sdk_metrics_1 = require_src9(), OTLPMetricExporterOptions_1 = require_OTLPMetricExporterOptions(), api_1 = require_src(), CumulativeTemporalitySelector = () => sdk_metrics_1.AggregationTemporality.CUMULATIVE;
    exports.CumulativeTemporalitySelector = CumulativeTemporalitySelector;
    var DeltaTemporalitySelector = (instrumentType) => {
      switch (instrumentType) {
        case sdk_metrics_1.InstrumentType.COUNTER:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_COUNTER:
        case sdk_metrics_1.InstrumentType.HISTOGRAM:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_GAUGE:
          return sdk_metrics_1.AggregationTemporality.DELTA;
        case sdk_metrics_1.InstrumentType.UP_DOWN_COUNTER:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
          return sdk_metrics_1.AggregationTemporality.CUMULATIVE;
      }
    };
    exports.DeltaTemporalitySelector = DeltaTemporalitySelector;
    var LowMemoryTemporalitySelector = (instrumentType) => {
      switch (instrumentType) {
        case sdk_metrics_1.InstrumentType.COUNTER:
        case sdk_metrics_1.InstrumentType.HISTOGRAM:
          return sdk_metrics_1.AggregationTemporality.DELTA;
        case sdk_metrics_1.InstrumentType.UP_DOWN_COUNTER:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_COUNTER:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_GAUGE:
          return sdk_metrics_1.AggregationTemporality.CUMULATIVE;
      }
    };
    exports.LowMemoryTemporalitySelector = LowMemoryTemporalitySelector;
    function chooseTemporalitySelectorFromEnvironment() {
      let env = (0, core_1.getEnv)(), configuredTemporality = env.OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE.trim().toLowerCase();
      return configuredTemporality === "cumulative" ? exports.CumulativeTemporalitySelector : configuredTemporality === "delta" ? exports.DeltaTemporalitySelector : configuredTemporality === "lowmemory" ? exports.LowMemoryTemporalitySelector : (api_1.diag.warn(`OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE is set to '${env.OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE}', but only 'cumulative' and 'delta' are allowed. Using default ('cumulative') instead.`), exports.CumulativeTemporalitySelector);
    }
    function chooseTemporalitySelector(temporalityPreference) {
      return temporalityPreference != null ? temporalityPreference === OTLPMetricExporterOptions_1.AggregationTemporalityPreference.DELTA ? exports.DeltaTemporalitySelector : temporalityPreference === OTLPMetricExporterOptions_1.AggregationTemporalityPreference.LOWMEMORY ? exports.LowMemoryTemporalitySelector : exports.CumulativeTemporalitySelector : chooseTemporalitySelectorFromEnvironment();
    }
    var OTLPMetricExporterBase = class {
      constructor(exporter, config) {
        this._otlpExporter = exporter, this._aggregationTemporalitySelector = chooseTemporalitySelector(config?.temporalityPreference);
      }
      export(metrics, resultCallback) {
        this._otlpExporter.export([metrics], resultCallback);
      }
      async shutdown() {
        await this._otlpExporter.shutdown();
      }
      forceFlush() {
        return Promise.resolve();
      }
      selectAggregationTemporality(instrumentType) {
        return this._aggregationTemporalitySelector(instrumentType);
      }
    };
    exports.OTLPMetricExporterBase = OTLPMetricExporterBase;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/util.js
var require_util3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/util.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseRetryAfterToMills = exports.isExportRetryable = exports.invalidTimeout = exports.configureExporterTimeout = exports.appendRootPathToUrlIfNeeded = exports.appendResourcePathToUrl = exports.parseHeaders = exports.DEFAULT_EXPORT_BACKOFF_MULTIPLIER = exports.DEFAULT_EXPORT_MAX_BACKOFF = exports.DEFAULT_EXPORT_INITIAL_BACKOFF = exports.DEFAULT_EXPORT_MAX_ATTEMPTS = void 0;
    var api_1 = require_src(), core_1 = require_src7(), DEFAULT_TRACE_TIMEOUT = 1e4;
    exports.DEFAULT_EXPORT_MAX_ATTEMPTS = 5;
    exports.DEFAULT_EXPORT_INITIAL_BACKOFF = 1e3;
    exports.DEFAULT_EXPORT_MAX_BACKOFF = 5e3;
    exports.DEFAULT_EXPORT_BACKOFF_MULTIPLIER = 1.5;
    function parseHeaders(partialHeaders = {}) {
      let headers = {};
      return Object.entries(partialHeaders).forEach(([key, value]) => {
        typeof value < "u" ? headers[key] = String(value) : api_1.diag.warn(`Header "${key}" has wrong value and will be ignored`);
      }), headers;
    }
    exports.parseHeaders = parseHeaders;
    function appendResourcePathToUrl(url2, path) {
      return url2.endsWith("/") || (url2 = url2 + "/"), url2 + path;
    }
    exports.appendResourcePathToUrl = appendResourcePathToUrl;
    function appendRootPathToUrlIfNeeded(url2) {
      try {
        let parsedUrl = new URL(url2);
        return parsedUrl.pathname === "" && (parsedUrl.pathname = parsedUrl.pathname + "/"), parsedUrl.toString();
      } catch {
        return api_1.diag.warn(`Could not parse export URL: '${url2}'`), url2;
      }
    }
    exports.appendRootPathToUrlIfNeeded = appendRootPathToUrlIfNeeded;
    function configureExporterTimeout(timeoutMillis) {
      return typeof timeoutMillis == "number" ? timeoutMillis <= 0 ? invalidTimeout(timeoutMillis, DEFAULT_TRACE_TIMEOUT) : timeoutMillis : getExporterTimeoutFromEnv();
    }
    exports.configureExporterTimeout = configureExporterTimeout;
    function getExporterTimeoutFromEnv() {
      var _a;
      let definedTimeout = Number((_a = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_TIMEOUT) !== null && _a !== void 0 ? _a : (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TIMEOUT);
      return definedTimeout <= 0 ? invalidTimeout(definedTimeout, DEFAULT_TRACE_TIMEOUT) : definedTimeout;
    }
    function invalidTimeout(timeout, defaultTimeout) {
      return api_1.diag.warn("Timeout must be greater than 0", timeout), defaultTimeout;
    }
    exports.invalidTimeout = invalidTimeout;
    function isExportRetryable(statusCode) {
      return [429, 502, 503, 504].includes(statusCode);
    }
    exports.isExportRetryable = isExportRetryable;
    function parseRetryAfterToMills(retryAfter) {
      if (retryAfter == null)
        return -1;
      let seconds = Number.parseInt(retryAfter, 10);
      if (Number.isInteger(seconds))
        return seconds > 0 ? seconds * 1e3 : -1;
      let delay = new Date(retryAfter).getTime() - Date.now();
      return delay >= 0 ? delay : 0;
    }
    exports.parseRetryAfterToMills = parseRetryAfterToMills;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/OTLPExporterBase.js
var require_OTLPExporterBase = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/OTLPExporterBase.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.OTLPExporterBase = void 0;
    var api_1 = require_src(), core_1 = require_src7(), util_1 = require_util3(), OTLPExporterBase = class {
      /**
       * @param config
       */
      constructor(config = {}) {
        this._sendingPromises = [], this.url = this.getDefaultUrl(config), typeof config.hostname == "string" && (this.hostname = config.hostname), this.shutdown = this.shutdown.bind(this), this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this), this._concurrencyLimit = typeof config.concurrencyLimit == "number" ? config.concurrencyLimit : 1 / 0, this.timeoutMillis = (0, util_1.configureExporterTimeout)(config.timeoutMillis), this.onInit(config);
      }
      /**
       * Export items.
       * @param items
       * @param resultCallback
       */
      export(items, resultCallback) {
        if (this._shutdownOnce.isCalled) {
          resultCallback({
            code: core_1.ExportResultCode.FAILED,
            error: new Error("Exporter has been shutdown")
          });
          return;
        }
        if (this._sendingPromises.length >= this._concurrencyLimit) {
          resultCallback({
            code: core_1.ExportResultCode.FAILED,
            error: new Error("Concurrent export limit reached")
          });
          return;
        }
        this._export(items).then(() => {
          resultCallback({ code: core_1.ExportResultCode.SUCCESS });
        }).catch((error) => {
          resultCallback({ code: core_1.ExportResultCode.FAILED, error });
        });
      }
      _export(items) {
        return new Promise((resolve, reject) => {
          try {
            api_1.diag.debug("items to be sent", items), this.send(items, resolve, reject);
          } catch (e) {
            reject(e);
          }
        });
      }
      /**
       * Shutdown the exporter.
       */
      shutdown() {
        return this._shutdownOnce.call();
      }
      /**
       * Exports any pending spans in the exporter
       */
      forceFlush() {
        return Promise.all(this._sendingPromises).then(() => {
        });
      }
      /**
       * Called by _shutdownOnce with BindOnceFuture
       */
      _shutdown() {
        return api_1.diag.debug("shutdown started"), this.onShutdown(), this.forceFlush();
      }
    };
    exports.OTLPExporterBase = OTLPExporterBase;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/types.js
var require_types10 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.CompressionAlgorithm = void 0;
    var CompressionAlgorithm;
    (function(CompressionAlgorithm2) {
      CompressionAlgorithm2.NONE = "none", CompressionAlgorithm2.GZIP = "gzip";
    })(CompressionAlgorithm = exports.CompressionAlgorithm || (exports.CompressionAlgorithm = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/types.js
var require_types11 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.OTLPExporterError = void 0;
    var OTLPExporterError = class extends Error {
      constructor(message, code, data) {
        super(message), this.name = "OTLPExporterError", this.data = data, this.code = code;
      }
    };
    exports.OTLPExporterError = OTLPExporterError;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/util.js
var require_util4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/util.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.configureCompression = exports.createHttpAgent = exports.sendWithHttp = void 0;
    var url2 = __require("url"), http = __require("http"), https = __require("https"), zlib = __require("zlib"), stream_1 = __require("stream"), api_1 = require_src(), types_1 = require_types10(), core_1 = require_src7(), types_2 = require_types11(), util_1 = require_util3();
    function sendWithHttp(collector, data, contentType, onSuccess, onError) {
      let exporterTimeout = collector.timeoutMillis, parsedUrl = new url2.URL(collector.url), nodeVersion = Number(process.versions.node.split(".")[0]), retryTimer, req, reqIsDestroyed = !1, exporterTimer = setTimeout(() => {
        if (clearTimeout(retryTimer), reqIsDestroyed = !0, req.destroyed) {
          let err = new types_2.OTLPExporterError("Request Timeout");
          onError(err);
        } else
          nodeVersion >= 14 ? req.destroy() : req.abort();
      }, exporterTimeout), options = {
        hostname: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.pathname,
        method: "POST",
        headers: Object.assign({ "Content-Type": contentType }, collector.headers),
        agent: collector.agent
      }, request = parsedUrl.protocol === "http:" ? http.request : https.request, sendWithRetry = (retries = util_1.DEFAULT_EXPORT_MAX_ATTEMPTS, minDelay = util_1.DEFAULT_EXPORT_INITIAL_BACKOFF) => {
        switch (req = request(options, (res) => {
          let responseData = "";
          res.on("data", (chunk) => responseData += chunk), res.on("aborted", () => {
            if (reqIsDestroyed) {
              let err = new types_2.OTLPExporterError("Request Timeout");
              onError(err);
            }
          }), res.on("end", () => {
            if (reqIsDestroyed === !1)
              if (res.statusCode && res.statusCode < 299)
                api_1.diag.debug(`statusCode: ${res.statusCode}`, responseData), onSuccess(), clearTimeout(exporterTimer), clearTimeout(retryTimer);
              else if (res.statusCode && (0, util_1.isExportRetryable)(res.statusCode) && retries > 0) {
                let retryTime;
                minDelay = util_1.DEFAULT_EXPORT_BACKOFF_MULTIPLIER * minDelay, res.headers["retry-after"] ? retryTime = (0, util_1.parseRetryAfterToMills)(res.headers["retry-after"]) : retryTime = Math.round(Math.random() * (util_1.DEFAULT_EXPORT_MAX_BACKOFF - minDelay) + minDelay), retryTimer = setTimeout(() => {
                  sendWithRetry(retries - 1, minDelay);
                }, retryTime);
              } else {
                let error = new types_2.OTLPExporterError(res.statusMessage, res.statusCode, responseData);
                onError(error), clearTimeout(exporterTimer), clearTimeout(retryTimer);
              }
          });
        }), req.on("error", (error) => {
          if (reqIsDestroyed) {
            let err = new types_2.OTLPExporterError("Request Timeout", error.code);
            onError(err);
          } else
            onError(error);
          clearTimeout(exporterTimer), clearTimeout(retryTimer);
        }), req.on("abort", () => {
          if (reqIsDestroyed) {
            let err = new types_2.OTLPExporterError("Request Timeout");
            onError(err);
          }
          clearTimeout(exporterTimer), clearTimeout(retryTimer);
        }), collector.compression) {
          case types_1.CompressionAlgorithm.GZIP: {
            req.setHeader("Content-Encoding", "gzip"), readableFromBuffer(data).on("error", onError).pipe(zlib.createGzip()).on("error", onError).pipe(req);
            break;
          }
          default:
            req.end(data);
            break;
        }
      };
      sendWithRetry();
    }
    exports.sendWithHttp = sendWithHttp;
    function readableFromBuffer(buff) {
      let readable = new stream_1.Readable();
      return readable.push(buff), readable.push(null), readable;
    }
    function createHttpAgent(config) {
      if (config.httpAgentOptions && config.keepAlive === !1) {
        api_1.diag.warn("httpAgentOptions is used only when keepAlive is true");
        return;
      }
      if (!(config.keepAlive === !1 || !config.url))
        try {
          let Agent = new url2.URL(config.url).protocol === "http:" ? http.Agent : https.Agent;
          return new Agent(Object.assign({ keepAlive: !0 }, config.httpAgentOptions));
        } catch (err) {
          api_1.diag.error(`collector exporter failed to create http agent. err: ${err.message}`);
          return;
        }
    }
    exports.createHttpAgent = createHttpAgent;
    function configureCompression(compression) {
      return compression || (((0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_COMPRESSION || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_COMPRESSION) === types_1.CompressionAlgorithm.GZIP ? types_1.CompressionAlgorithm.GZIP : types_1.CompressionAlgorithm.NONE);
    }
    exports.configureCompression = configureCompression;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/OTLPExporterNodeBase.js
var require_OTLPExporterNodeBase = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/OTLPExporterNodeBase.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.OTLPExporterNodeBase = void 0;
    var OTLPExporterBase_1 = require_OTLPExporterBase(), util_1 = require_util3(), util_2 = require_util4(), api_1 = require_src(), core_1 = require_src7(), OTLPExporterNodeBase = class extends OTLPExporterBase_1.OTLPExporterBase {
      constructor(config = {}) {
        super(config), this.DEFAULT_HEADERS = {}, config.metadata && api_1.diag.warn("Metadata cannot be set when using http"), this.headers = Object.assign(this.DEFAULT_HEADERS, (0, util_1.parseHeaders)(config.headers), core_1.baggageUtils.parseKeyPairsIntoRecord((0, core_1.getEnv)().OTEL_EXPORTER_OTLP_HEADERS)), this.agent = (0, util_2.createHttpAgent)(config), this.compression = (0, util_2.configureCompression)(config.compression);
      }
      onInit(_config) {
      }
      send(objects, onSuccess, onError) {
        if (this._shutdownOnce.isCalled) {
          api_1.diag.debug("Shutdown already started. Cannot send objects");
          return;
        }
        let serviceRequest = this.convert(objects), promise = new Promise((resolve, reject) => {
          (0, util_2.sendWithHttp)(this, JSON.stringify(serviceRequest), "application/json", resolve, reject);
        }).then(onSuccess, onError);
        this._sendingPromises.push(promise);
        let popPromise = () => {
          let index = this._sendingPromises.indexOf(promise);
          this._sendingPromises.splice(index, 1);
        };
        promise.then(popPromise, popPromise);
      }
      onShutdown() {
      }
    };
    exports.OTLPExporterNodeBase = OTLPExporterNodeBase;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/index.js
var require_node6 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.CompressionAlgorithm = exports.configureCompression = exports.createHttpAgent = exports.sendWithHttp = exports.OTLPExporterNodeBase = void 0;
    var OTLPExporterNodeBase_1 = require_OTLPExporterNodeBase();
    Object.defineProperty(exports, "OTLPExporterNodeBase", { enumerable: !0, get: function() {
      return OTLPExporterNodeBase_1.OTLPExporterNodeBase;
    } });
    var util_1 = require_util4();
    Object.defineProperty(exports, "sendWithHttp", { enumerable: !0, get: function() {
      return util_1.sendWithHttp;
    } });
    Object.defineProperty(exports, "createHttpAgent", { enumerable: !0, get: function() {
      return util_1.createHttpAgent;
    } });
    Object.defineProperty(exports, "configureCompression", { enumerable: !0, get: function() {
      return util_1.configureCompression;
    } });
    var types_1 = require_types10();
    Object.defineProperty(exports, "CompressionAlgorithm", { enumerable: !0, get: function() {
      return types_1.CompressionAlgorithm;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/util.js
var require_util5 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/util.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.sendWithXhr = exports.sendWithBeacon = void 0;
    var api_1 = require_src(), types_1 = require_types11(), util_1 = require_util3();
    function sendWithBeacon(body, url2, blobPropertyBag, onSuccess, onError) {
      if (navigator.sendBeacon(url2, new Blob([body], blobPropertyBag)))
        api_1.diag.debug("sendBeacon - can send", body), onSuccess();
      else {
        let error = new types_1.OTLPExporterError(`sendBeacon - cannot send ${body}`);
        onError(error);
      }
    }
    exports.sendWithBeacon = sendWithBeacon;
    function sendWithXhr(body, url2, headers, exporterTimeout, onSuccess, onError) {
      let retryTimer, xhr, reqIsDestroyed = !1, exporterTimer = setTimeout(() => {
        if (clearTimeout(retryTimer), reqIsDestroyed = !0, xhr.readyState === XMLHttpRequest.DONE) {
          let err = new types_1.OTLPExporterError("Request Timeout");
          onError(err);
        } else
          xhr.abort();
      }, exporterTimeout), sendWithRetry = (retries = util_1.DEFAULT_EXPORT_MAX_ATTEMPTS, minDelay = util_1.DEFAULT_EXPORT_INITIAL_BACKOFF) => {
        xhr = new XMLHttpRequest(), xhr.open("POST", url2), Object.entries(Object.assign(Object.assign({}, {
          Accept: "application/json",
          "Content-Type": "application/json"
        }), headers)).forEach(([k, v]) => {
          xhr.setRequestHeader(k, v);
        }), xhr.send(body), xhr.onreadystatechange = () => {
          if (xhr.readyState === XMLHttpRequest.DONE && reqIsDestroyed === !1)
            if (xhr.status >= 200 && xhr.status <= 299)
              api_1.diag.debug("xhr success", body), onSuccess(), clearTimeout(exporterTimer), clearTimeout(retryTimer);
            else if (xhr.status && (0, util_1.isExportRetryable)(xhr.status) && retries > 0) {
              let retryTime;
              minDelay = util_1.DEFAULT_EXPORT_BACKOFF_MULTIPLIER * minDelay, xhr.getResponseHeader("Retry-After") ? retryTime = (0, util_1.parseRetryAfterToMills)(xhr.getResponseHeader("Retry-After")) : retryTime = Math.round(Math.random() * (util_1.DEFAULT_EXPORT_MAX_BACKOFF - minDelay) + minDelay), retryTimer = setTimeout(() => {
                sendWithRetry(retries - 1, minDelay);
              }, retryTime);
            } else {
              let error = new types_1.OTLPExporterError(`Failed to export with XHR (status: ${xhr.status})`, xhr.status);
              onError(error), clearTimeout(exporterTimer), clearTimeout(retryTimer);
            }
        }, xhr.onabort = () => {
          if (reqIsDestroyed) {
            let err = new types_1.OTLPExporterError("Request Timeout");
            onError(err);
          }
          clearTimeout(exporterTimer), clearTimeout(retryTimer);
        }, xhr.onerror = () => {
          if (reqIsDestroyed) {
            let err = new types_1.OTLPExporterError("Request Timeout");
            onError(err);
          }
          clearTimeout(exporterTimer), clearTimeout(retryTimer);
        };
      };
      sendWithRetry();
    }
    exports.sendWithXhr = sendWithXhr;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/OTLPExporterBrowserBase.js
var require_OTLPExporterBrowserBase = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/OTLPExporterBrowserBase.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.OTLPExporterBrowserBase = void 0;
    var OTLPExporterBase_1 = require_OTLPExporterBase(), util_1 = require_util3(), util_2 = require_util5(), api_1 = require_src(), core_1 = require_src7(), OTLPExporterBrowserBase = class extends OTLPExporterBase_1.OTLPExporterBase {
      /**
       * @param config
       */
      constructor(config = {}) {
        super(config), this._useXHR = !1, this._useXHR = !!config.headers || typeof navigator.sendBeacon != "function", this._useXHR ? this._headers = Object.assign({}, (0, util_1.parseHeaders)(config.headers), core_1.baggageUtils.parseKeyPairsIntoRecord((0, core_1.getEnv)().OTEL_EXPORTER_OTLP_HEADERS)) : this._headers = {};
      }
      onInit() {
        window.addEventListener("unload", this.shutdown);
      }
      onShutdown() {
        window.removeEventListener("unload", this.shutdown);
      }
      send(items, onSuccess, onError) {
        if (this._shutdownOnce.isCalled) {
          api_1.diag.debug("Shutdown already started. Cannot send objects");
          return;
        }
        let serviceRequest = this.convert(items), body = JSON.stringify(serviceRequest), promise = new Promise((resolve, reject) => {
          this._useXHR ? (0, util_2.sendWithXhr)(body, this.url, this._headers, this.timeoutMillis, resolve, reject) : (0, util_2.sendWithBeacon)(body, this.url, { type: "application/json" }, resolve, reject);
        }).then(onSuccess, onError);
        this._sendingPromises.push(promise);
        let popPromise = () => {
          let index = this._sendingPromises.indexOf(promise);
          this._sendingPromises.splice(index, 1);
        };
        promise.then(popPromise, popPromise);
      }
    };
    exports.OTLPExporterBrowserBase = OTLPExporterBrowserBase;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/index.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.sendWithXhr = exports.OTLPExporterBrowserBase = void 0;
    var OTLPExporterBrowserBase_1 = require_OTLPExporterBrowserBase();
    Object.defineProperty(exports, "OTLPExporterBrowserBase", { enumerable: !0, get: function() {
      return OTLPExporterBrowserBase_1.OTLPExporterBrowserBase;
    } });
    var util_1 = require_util5();
    Object.defineProperty(exports, "sendWithXhr", { enumerable: !0, get: function() {
      return util_1.sendWithXhr;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/index.js
var require_platform6 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.sendWithXhr = exports.OTLPExporterBrowserBase = exports.CompressionAlgorithm = exports.configureCompression = exports.createHttpAgent = exports.sendWithHttp = exports.OTLPExporterNodeBase = void 0;
    var node_1 = require_node6();
    Object.defineProperty(exports, "OTLPExporterNodeBase", { enumerable: !0, get: function() {
      return node_1.OTLPExporterNodeBase;
    } });
    Object.defineProperty(exports, "sendWithHttp", { enumerable: !0, get: function() {
      return node_1.sendWithHttp;
    } });
    Object.defineProperty(exports, "createHttpAgent", { enumerable: !0, get: function() {
      return node_1.createHttpAgent;
    } });
    Object.defineProperty(exports, "configureCompression", { enumerable: !0, get: function() {
      return node_1.configureCompression;
    } });
    Object.defineProperty(exports, "CompressionAlgorithm", { enumerable: !0, get: function() {
      return node_1.CompressionAlgorithm;
    } });
    var browser_1 = require_browser();
    Object.defineProperty(exports, "OTLPExporterBrowserBase", { enumerable: !0, get: function() {
      return browser_1.OTLPExporterBrowserBase;
    } });
    Object.defineProperty(exports, "sendWithXhr", { enumerable: !0, get: function() {
      return browser_1.sendWithXhr;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/index.js
var require_src10 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-exporter-base/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.invalidTimeout = exports.configureExporterTimeout = exports.appendRootPathToUrlIfNeeded = exports.appendResourcePathToUrl = exports.parseHeaders = exports.OTLPExporterError = exports.OTLPExporterBase = void 0;
    __exportStar(require_platform6(), exports);
    var OTLPExporterBase_1 = require_OTLPExporterBase();
    Object.defineProperty(exports, "OTLPExporterBase", { enumerable: !0, get: function() {
      return OTLPExporterBase_1.OTLPExporterBase;
    } });
    var types_1 = require_types11();
    Object.defineProperty(exports, "OTLPExporterError", { enumerable: !0, get: function() {
      return types_1.OTLPExporterError;
    } });
    var util_1 = require_util3();
    Object.defineProperty(exports, "parseHeaders", { enumerable: !0, get: function() {
      return util_1.parseHeaders;
    } });
    Object.defineProperty(exports, "appendResourcePathToUrl", { enumerable: !0, get: function() {
      return util_1.appendResourcePathToUrl;
    } });
    Object.defineProperty(exports, "appendRootPathToUrlIfNeeded", { enumerable: !0, get: function() {
      return util_1.appendRootPathToUrlIfNeeded;
    } });
    Object.defineProperty(exports, "configureExporterTimeout", { enumerable: !0, get: function() {
      return util_1.configureExporterTimeout;
    } });
    Object.defineProperty(exports, "invalidTimeout", { enumerable: !0, get: function() {
      return util_1.invalidTimeout;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/common/types.js
var require_types12 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/common/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/types.js
var require_types13 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/resource/types.js
var require_types14 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/resource/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/types.js
var require_types15 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ESpanKind = void 0;
    var ESpanKind;
    (function(ESpanKind2) {
      ESpanKind2[ESpanKind2.SPAN_KIND_UNSPECIFIED = 0] = "SPAN_KIND_UNSPECIFIED", ESpanKind2[ESpanKind2.SPAN_KIND_INTERNAL = 1] = "SPAN_KIND_INTERNAL", ESpanKind2[ESpanKind2.SPAN_KIND_SERVER = 2] = "SPAN_KIND_SERVER", ESpanKind2[ESpanKind2.SPAN_KIND_CLIENT = 3] = "SPAN_KIND_CLIENT", ESpanKind2[ESpanKind2.SPAN_KIND_PRODUCER = 4] = "SPAN_KIND_PRODUCER", ESpanKind2[ESpanKind2.SPAN_KIND_CONSUMER = 5] = "SPAN_KIND_CONSUMER";
    })(ESpanKind = exports.ESpanKind || (exports.ESpanKind = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/types.js
var require_types16 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/common/internal.js
var require_internal = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/common/internal.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.toAnyValue = exports.toKeyValue = exports.toAttributes = void 0;
    function toAttributes(attributes) {
      return Object.keys(attributes).map((key) => toKeyValue(key, attributes[key]));
    }
    exports.toAttributes = toAttributes;
    function toKeyValue(key, value) {
      return {
        key,
        value: toAnyValue(value)
      };
    }
    exports.toKeyValue = toKeyValue;
    function toAnyValue(value) {
      let t = typeof value;
      return t === "string" ? { stringValue: value } : t === "number" ? Number.isInteger(value) ? { intValue: value } : { doubleValue: value } : t === "boolean" ? { boolValue: value } : value instanceof Uint8Array ? { bytesValue: value } : Array.isArray(value) ? { arrayValue: { values: value.map(toAnyValue) } } : t === "object" && value != null ? {
        kvlistValue: {
          values: Object.entries(value).map(([k, v]) => toKeyValue(k, v))
        }
      } : {};
    }
    exports.toAnyValue = toAnyValue;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/internal.js
var require_internal2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/internal.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.toOtlpSpanEvent = exports.toOtlpLink = exports.sdkSpanToOtlpSpan = void 0;
    var core_1 = require_src7(), internal_1 = require_internal(), core = require_src7();
    function sdkSpanToOtlpSpan(span, useHex) {
      var _a;
      let ctx = span.spanContext(), status = span.status, parentSpanId = useHex ? span.parentSpanId : span.parentSpanId != null ? core.hexToBase64(span.parentSpanId) : void 0;
      return {
        traceId: useHex ? ctx.traceId : core.hexToBase64(ctx.traceId),
        spanId: useHex ? ctx.spanId : core.hexToBase64(ctx.spanId),
        parentSpanId,
        traceState: (_a = ctx.traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
        name: span.name,
        // Span kind is offset by 1 because the API does not define a value for unset
        kind: span.kind == null ? 0 : span.kind + 1,
        startTimeUnixNano: (0, core_1.hrTimeToNanoseconds)(span.startTime),
        endTimeUnixNano: (0, core_1.hrTimeToNanoseconds)(span.endTime),
        attributes: (0, internal_1.toAttributes)(span.attributes),
        droppedAttributesCount: span.droppedAttributesCount,
        events: span.events.map(toOtlpSpanEvent),
        droppedEventsCount: span.droppedEventsCount,
        status: {
          // API and proto enums share the same values
          code: status.code,
          message: status.message
        },
        links: span.links.map((link) => toOtlpLink(link, useHex)),
        droppedLinksCount: span.droppedLinksCount
      };
    }
    exports.sdkSpanToOtlpSpan = sdkSpanToOtlpSpan;
    function toOtlpLink(link, useHex) {
      var _a;
      return {
        attributes: link.attributes ? (0, internal_1.toAttributes)(link.attributes) : [],
        spanId: useHex ? link.context.spanId : core.hexToBase64(link.context.spanId),
        traceId: useHex ? link.context.traceId : core.hexToBase64(link.context.traceId),
        traceState: (_a = link.context.traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
        droppedAttributesCount: link.droppedAttributesCount || 0
      };
    }
    exports.toOtlpLink = toOtlpLink;
    function toOtlpSpanEvent(timedEvent) {
      return {
        attributes: timedEvent.attributes ? (0, internal_1.toAttributes)(timedEvent.attributes) : [],
        name: timedEvent.name,
        timeUnixNano: (0, core_1.hrTimeToNanoseconds)(timedEvent.time),
        droppedAttributesCount: timedEvent.droppedAttributesCount || 0
      };
    }
    exports.toOtlpSpanEvent = toOtlpSpanEvent;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/index.js
var require_trace4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.createExportTraceServiceRequest = void 0;
    var internal_1 = require_internal(), internal_2 = require_internal2();
    function createExportTraceServiceRequest(spans, useHex) {
      return {
        resourceSpans: spanRecordsToResourceSpans(spans, useHex)
      };
    }
    exports.createExportTraceServiceRequest = createExportTraceServiceRequest;
    function createResourceMap(readableSpans) {
      let resourceMap = /* @__PURE__ */ new Map();
      for (let record of readableSpans) {
        let ilmMap = resourceMap.get(record.resource);
        ilmMap || (ilmMap = /* @__PURE__ */ new Map(), resourceMap.set(record.resource, ilmMap));
        let instrumentationLibraryKey = `${record.instrumentationLibrary.name}@${record.instrumentationLibrary.version || ""}:${record.instrumentationLibrary.schemaUrl || ""}`, records = ilmMap.get(instrumentationLibraryKey);
        records || (records = [], ilmMap.set(instrumentationLibraryKey, records)), records.push(record);
      }
      return resourceMap;
    }
    function spanRecordsToResourceSpans(readableSpans, useHex) {
      let resourceMap = createResourceMap(readableSpans), out = [], entryIterator = resourceMap.entries(), entry = entryIterator.next();
      for (; !entry.done; ) {
        let [resource, ilmMap] = entry.value, scopeResourceSpans = [], ilmIterator = ilmMap.values(), ilmEntry = ilmIterator.next();
        for (; !ilmEntry.done; ) {
          let scopeSpans = ilmEntry.value;
          if (scopeSpans.length > 0) {
            let { name, version, schemaUrl } = scopeSpans[0].instrumentationLibrary, spans = scopeSpans.map((readableSpan) => (0, internal_2.sdkSpanToOtlpSpan)(readableSpan, useHex));
            scopeResourceSpans.push({
              scope: { name, version },
              spans,
              schemaUrl
            });
          }
          ilmEntry = ilmIterator.next();
        }
        let transformedSpans = {
          resource: {
            attributes: (0, internal_1.toAttributes)(resource.attributes),
            droppedAttributesCount: 0
          },
          scopeSpans: scopeResourceSpans,
          schemaUrl: void 0
        };
        out.push(transformedSpans), entry = entryIterator.next();
      }
      return out;
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/internal.js
var require_internal3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/internal.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.toMetric = exports.toScopeMetrics = exports.toResourceMetrics = void 0;
    var api_1 = require_src(), core_1 = require_src7(), sdk_metrics_1 = require_src9(), internal_1 = require_internal();
    function toResourceMetrics(resourceMetrics) {
      return {
        resource: {
          attributes: (0, internal_1.toAttributes)(resourceMetrics.resource.attributes),
          droppedAttributesCount: 0
        },
        schemaUrl: void 0,
        scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics)
      };
    }
    exports.toResourceMetrics = toResourceMetrics;
    function toScopeMetrics(scopeMetrics) {
      return Array.from(scopeMetrics.map((metrics) => ({
        scope: {
          name: metrics.scope.name,
          version: metrics.scope.version
        },
        metrics: metrics.metrics.map((metricData) => toMetric(metricData)),
        schemaUrl: metrics.scope.schemaUrl
      })));
    }
    exports.toScopeMetrics = toScopeMetrics;
    function toMetric(metricData) {
      let out = {
        name: metricData.descriptor.name,
        description: metricData.descriptor.description,
        unit: metricData.descriptor.unit
      }, aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);
      switch (metricData.dataPointType) {
        case sdk_metrics_1.DataPointType.SUM:
          out.sum = {
            aggregationTemporality,
            isMonotonic: metricData.isMonotonic,
            dataPoints: toSingularDataPoints(metricData)
          };
          break;
        case sdk_metrics_1.DataPointType.GAUGE:
          out.gauge = {
            dataPoints: toSingularDataPoints(metricData)
          };
          break;
        case sdk_metrics_1.DataPointType.HISTOGRAM:
          out.histogram = {
            aggregationTemporality,
            dataPoints: toHistogramDataPoints(metricData)
          };
          break;
        case sdk_metrics_1.DataPointType.EXPONENTIAL_HISTOGRAM:
          out.exponentialHistogram = {
            aggregationTemporality,
            dataPoints: toExponentialHistogramDataPoints(metricData)
          };
          break;
      }
      return out;
    }
    exports.toMetric = toMetric;
    function toSingularDataPoint(dataPoint, valueType) {
      let out = {
        attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
        startTimeUnixNano: (0, core_1.hrTimeToNanoseconds)(dataPoint.startTime),
        timeUnixNano: (0, core_1.hrTimeToNanoseconds)(dataPoint.endTime)
      };
      switch (valueType) {
        case api_1.ValueType.INT:
          out.asInt = dataPoint.value;
          break;
        case api_1.ValueType.DOUBLE:
          out.asDouble = dataPoint.value;
          break;
      }
      return out;
    }
    function toSingularDataPoints(metricData) {
      return metricData.dataPoints.map((dataPoint) => toSingularDataPoint(dataPoint, metricData.descriptor.valueType));
    }
    function toHistogramDataPoints(metricData) {
      return metricData.dataPoints.map((dataPoint) => {
        let histogram = dataPoint.value;
        return {
          attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
          bucketCounts: histogram.buckets.counts,
          explicitBounds: histogram.buckets.boundaries,
          count: histogram.count,
          sum: histogram.sum,
          min: histogram.min,
          max: histogram.max,
          startTimeUnixNano: (0, core_1.hrTimeToNanoseconds)(dataPoint.startTime),
          timeUnixNano: (0, core_1.hrTimeToNanoseconds)(dataPoint.endTime)
        };
      });
    }
    function toExponentialHistogramDataPoints(metricData) {
      return metricData.dataPoints.map((dataPoint) => {
        let histogram = dataPoint.value;
        return {
          attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
          count: histogram.count,
          min: histogram.min,
          max: histogram.max,
          sum: histogram.sum,
          positive: {
            offset: histogram.positive.offset,
            bucketCounts: histogram.positive.bucketCounts
          },
          negative: {
            offset: histogram.negative.offset,
            bucketCounts: histogram.negative.bucketCounts
          },
          scale: histogram.scale,
          zeroCount: histogram.zeroCount,
          startTimeUnixNano: (0, core_1.hrTimeToNanoseconds)(dataPoint.startTime),
          timeUnixNano: (0, core_1.hrTimeToNanoseconds)(dataPoint.endTime)
        };
      });
    }
    function toAggregationTemporality(temporality) {
      switch (temporality) {
        case sdk_metrics_1.AggregationTemporality.DELTA:
          return 1;
        case sdk_metrics_1.AggregationTemporality.CUMULATIVE:
          return 2;
      }
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/index.js
var require_metrics2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.createExportMetricsServiceRequest = void 0;
    var internal_1 = require_internal3();
    function createExportMetricsServiceRequest(resourceMetrics) {
      return {
        resourceMetrics: resourceMetrics.map((metrics) => (0, internal_1.toResourceMetrics)(metrics))
      };
    }
    exports.createExportMetricsServiceRequest = createExportMetricsServiceRequest;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/index.js
var require_logs = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.toLogAttributes = exports.createExportLogsServiceRequest = void 0;
    var internal_1 = require_internal(), core_1 = require_src7();
    function createExportLogsServiceRequest(logRecords, useHex) {
      return {
        resourceLogs: logRecordsToResourceLogs(logRecords, useHex)
      };
    }
    exports.createExportLogsServiceRequest = createExportLogsServiceRequest;
    function createResourceMap(logRecords) {
      let resourceMap = /* @__PURE__ */ new Map();
      for (let record of logRecords) {
        let { resource, instrumentationScope: { name, version = "", schemaUrl = "" } } = record, ismMap = resourceMap.get(resource);
        ismMap || (ismMap = /* @__PURE__ */ new Map(), resourceMap.set(resource, ismMap));
        let ismKey = `${name}@${version}:${schemaUrl}`, records = ismMap.get(ismKey);
        records || (records = [], ismMap.set(ismKey, records)), records.push(record);
      }
      return resourceMap;
    }
    function logRecordsToResourceLogs(logRecords, useHex) {
      let resourceMap = createResourceMap(logRecords);
      return Array.from(resourceMap, ([resource, ismMap]) => ({
        resource: {
          attributes: (0, internal_1.toAttributes)(resource.attributes),
          droppedAttributesCount: 0
        },
        scopeLogs: Array.from(ismMap, ([, scopeLogs]) => {
          let { instrumentationScope: { name, version, schemaUrl } } = scopeLogs[0];
          return {
            scope: { name, version },
            logRecords: scopeLogs.map((log) => toLogRecord(log, useHex)),
            schemaUrl
          };
        }),
        schemaUrl: void 0
      }));
    }
    function toLogRecord(log, useHex) {
      var _a, _b, _c, _d, _e;
      return {
        timeUnixNano: (0, core_1.hrTimeToNanoseconds)(log.hrTime),
        observedTimeUnixNano: (0, core_1.hrTimeToNanoseconds)(log.hrTimeObserved),
        severityNumber: log.severityNumber,
        severityText: log.severityText,
        body: (0, internal_1.toAnyValue)(log.body),
        attributes: toLogAttributes(log.attributes),
        droppedAttributesCount: 0,
        flags: (_a = log.spanContext) === null || _a === void 0 ? void 0 : _a.traceFlags,
        traceId: useHex ? (_b = log.spanContext) === null || _b === void 0 ? void 0 : _b.traceId : optionalHexToBase64((_c = log.spanContext) === null || _c === void 0 ? void 0 : _c.traceId),
        spanId: useHex ? (_d = log.spanContext) === null || _d === void 0 ? void 0 : _d.spanId : optionalHexToBase64((_e = log.spanContext) === null || _e === void 0 ? void 0 : _e.spanId)
      };
    }
    function optionalHexToBase64(str) {
      if (str !== void 0)
        return (0, core_1.hexToBase64)(str);
    }
    function toLogAttributes(attributes) {
      return Object.keys(attributes).map((key) => (0, internal_1.toKeyValue)(key, attributes[key]));
    }
    exports.toLogAttributes = toLogAttributes;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/index.js
var require_src11 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/otlp-transformer/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.createExportLogsServiceRequest = exports.createExportMetricsServiceRequest = exports.createExportTraceServiceRequest = void 0;
    __exportStar(require_types12(), exports);
    __exportStar(require_types13(), exports);
    __exportStar(require_types14(), exports);
    __exportStar(require_types15(), exports);
    __exportStar(require_types16(), exports);
    var trace_1 = require_trace4();
    Object.defineProperty(exports, "createExportTraceServiceRequest", { enumerable: !0, get: function() {
      return trace_1.createExportTraceServiceRequest;
    } });
    var metrics_1 = require_metrics2();
    Object.defineProperty(exports, "createExportMetricsServiceRequest", { enumerable: !0, get: function() {
      return metrics_1.createExportMetricsServiceRequest;
    } });
    var logs_1 = require_logs();
    Object.defineProperty(exports, "createExportLogsServiceRequest", { enumerable: !0, get: function() {
      return logs_1.createExportLogsServiceRequest;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/version.js
var require_version4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/version.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.VERSION = void 0;
    exports.VERSION = "0.43.0";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/node/OTLPMetricExporter.js
var require_OTLPMetricExporter = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/node/OTLPMetricExporter.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.OTLPMetricExporter = void 0;
    var core_1 = require_src7(), OTLPMetricExporterBase_1 = require_OTLPMetricExporterBase(), otlp_exporter_base_1 = require_src10(), otlp_transformer_1 = require_src11(), version_1 = require_version4(), DEFAULT_COLLECTOR_RESOURCE_PATH = "v1/metrics", DEFAULT_COLLECTOR_URL = `http://localhost:4318/${DEFAULT_COLLECTOR_RESOURCE_PATH}`, USER_AGENT = {
      "User-Agent": `OTel-OTLP-Exporter-JavaScript/${version_1.VERSION}`
    }, OTLPExporterNodeProxy = class extends otlp_exporter_base_1.OTLPExporterNodeBase {
      constructor(config) {
        super(config), this.headers = Object.assign(Object.assign(Object.assign({}, this.headers), USER_AGENT), core_1.baggageUtils.parseKeyPairsIntoRecord((0, core_1.getEnv)().OTEL_EXPORTER_OTLP_METRICS_HEADERS));
      }
      convert(metrics) {
        return (0, otlp_transformer_1.createExportMetricsServiceRequest)(metrics);
      }
      getDefaultUrl(config) {
        return typeof config.url == "string" ? config.url : (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_METRICS_ENDPOINT.length > 0 ? (0, otlp_exporter_base_1.appendRootPathToUrlIfNeeded)((0, core_1.getEnv)().OTEL_EXPORTER_OTLP_METRICS_ENDPOINT) : (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_ENDPOINT.length > 0 ? (0, otlp_exporter_base_1.appendResourcePathToUrl)((0, core_1.getEnv)().OTEL_EXPORTER_OTLP_ENDPOINT, DEFAULT_COLLECTOR_RESOURCE_PATH) : DEFAULT_COLLECTOR_URL;
      }
    }, OTLPMetricExporter2 = class extends OTLPMetricExporterBase_1.OTLPMetricExporterBase {
      constructor(config) {
        super(new OTLPExporterNodeProxy(config), config);
      }
    };
    exports.OTLPMetricExporter = OTLPMetricExporter2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/node/index.js
var require_node7 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/node/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_OTLPMetricExporter(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/index.js
var require_platform7 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_node7(), exports);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/index.js
var require_src12 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.43.0_@opentelemetry+api@1.6.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_platform7(), exports);
    __exportStar(require_OTLPMetricExporterOptions(), exports);
    __exportStar(require_OTLPMetricExporterBase(), exports);
  }
});

// ../cli-kit/dist/public/node/plugins.js
init_cjs_shims();
async function fanoutHooks(config, event, options, timeout) {
  let res = await config.runHook(event, options, timeout);
  return Object.fromEntries(res.successes.map(({ result, plugin }) => [plugin.name, result]));
}
async function getListOfTunnelPlugins(config) {
  let hooks = await fanoutHooks(config, "tunnel_provider", {}), names = getArrayRejectingUndefined(Object.values(hooks).map((key) => key?.name));
  return getArrayContainsDuplicates(names) ? { plugins: names, error: "multiple-plugins-for-provider" } : { plugins: names };
}

// ../cli-kit/dist/public/node/analytics.js
init_cjs_shims();

// ../cli-kit/dist/public/node/monorail.js
init_cjs_shims();
var url = "https://monorail-edge.shopifysvc.com/v1/produce", MONORAIL_COMMAND_TOPIC = "app_cli3_command/1.15", publishedCommandNames = /* @__PURE__ */ new Set();
async function publishMonorailEvent(schemaId, publicData, sensitiveData) {
  let commandName = publicData.command;
  if (commandName && typeof commandName == "string") {
    if (publishedCommandNames.has(commandName))
      return { type: "ok" };
    publishedCommandNames.add(commandName);
  }
  try {
    let currentTime = (/* @__PURE__ */ new Date()).getTime(), payload = { ...publicData, ...sensitiveData }, body = JSON.stringify({ schema_id: schemaId, payload }), headers = buildHeaders(currentTime), response = await fetch(url, { method: "POST", body, headers });
    return response.status === 200 ? (outputDebug(outputContent`Analytics event sent: ${outputToken.json(sanitizePayload(payload))}`), { type: "ok" }) : (outputDebug(`Failed to report usage analytics: ${response.statusText}`), { type: "error", message: response.statusText });
  } catch (error) {
    let message = "Failed to report usage analytics";
    return error instanceof Error && (message = message.concat(`: ${error.message}`)), outputDebug(message), { type: "error", message };
  }
}
function sanitizePayload(payload) {
  let result = { ...payload };
  return "api_key" in result && (result.api_key = "****"), result;
}
var buildHeaders = (currentTime) => ({
  "Content-Type": "application/json; charset=utf-8",
  "X-Monorail-Edge-Event-Created-At-Ms": currentTime.toString(),
  "X-Monorail-Edge-Event-Sent-At-Ms": currentTime.toString()
});

// ../cli-kit/dist/private/node/otel-metrics.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/otel-js/service/types.js
init_cjs_shims();
var MetricInstrumentType;
(function(MetricInstrumentType2) {
  MetricInstrumentType2.Histogram = "Histogram", MetricInstrumentType2.Counter = "Counter", MetricInstrumentType2.UpDownCounter = "UpDownCounter";
})(MetricInstrumentType || (MetricInstrumentType = {}));

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultOtelService.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultMeterProvider.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/otel-js/export/InstantaneousMetricReader.js
init_cjs_shims();
var import_sdk_metrics = __toESM(require_src5(), 1), import_core = __toESM(require_src3(), 1), import_api = __toESM(require_src(), 1);

// ../cli-kit/dist/public/node/vendor/otel-js/utils/throttle.js
init_cjs_shims();
function throttle(func, wait, { leading = !0, trailing = !0 } = {}) {
  let lastArgs, result, context, timeout = null, previous = 0;
  function later() {
    previous = leading === !1 ? 0 : Date.now(), timeout = null, lastArgs && (result = func.apply(context, lastArgs)), context = null, lastArgs = null;
  }
  return function(...args) {
    let now = Date.now();
    !previous && leading === !1 && (previous = now);
    let remaining = wait - (now - previous);
    return context = this, lastArgs = args, remaining <= 0 || remaining > wait ? (timeout && (clearTimeout(timeout), timeout = null), previous = now, lastArgs && (result = func.apply(context, lastArgs)), context = null, lastArgs = null) : !timeout && trailing !== !1 && (timeout = setTimeout(later, remaining)), result;
  };
}

// ../cli-kit/dist/public/node/vendor/otel-js/export/InstantaneousMetricReader.js
var InstantaneousMetricReader = class extends import_sdk_metrics.MetricReader {
  constructor({ exporter, throttleLimit }) {
    super({
      aggregationSelector: exporter.selectAggregation?.bind(exporter),
      aggregationTemporalitySelector: exporter.selectAggregationTemporality?.bind(exporter)
    }), this._exporter = exporter, this.onForceFlush = throttle(
      // eslint-disable-next-line @typescript-eslint/unbound-method
      this.onForceFlush,
      throttleLimit
    );
  }
  async onForceFlush() {
    let { resourceMetrics, errors } = await this.collect({});
    return errors.length > 0 && import_api.diag.error("PeriodicExportingMetricReader: metrics collection errors", ...errors), new Promise((resolve, reject) => {
      this._exporter.export(resourceMetrics, (result) => {
        result.code === import_core.ExportResultCode.SUCCESS ? resolve() : reject(result.error ?? new Error(`InstantaneousMetricReader: metrics export failed (error ${result.error})`));
      });
    });
  }
  async onShutdown() {
    await this._exporter.shutdown();
  }
};

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultMeterProvider.js
var import_exporter_metrics_otlp_http = __toESM(require_src12(), 1), import_resources = __toESM(require_src4(), 1), import_sdk_metrics2 = __toESM(require_src5(), 1), import_semantic_conventions = __toESM(require_src2(), 1), DefaultMeterProvider = class extends import_sdk_metrics2.MeterProvider {
  constructor({ serviceName, env, throttleLimit, useXhr, otelEndpoint }) {
    super({
      resource: new import_resources.Resource({
        [import_semantic_conventions.SemanticResourceAttributes.SERVICE_NAME]: serviceName
      })
    });
    let opts = {
      // url: OTEL_ENDPOINTS[env as Environment] || OTEL_ENDPOINTS.local,
      // CLI addition
      url: otelEndpoint,
      temporalityPreference: import_sdk_metrics2.AggregationTemporality.DELTA
    };
    useXhr && (opts.headers = {});
    let exporter = new import_exporter_metrics_otlp_http.OTLPMetricExporter(opts);
    this.addMetricReader(new InstantaneousMetricReader({
      exporter,
      throttleLimit
    })), env === "dev" && this.addMetricReader(new InstantaneousMetricReader({
      exporter: new import_sdk_metrics2.ConsoleMetricExporter(),
      throttleLimit
    }));
  }
};

// ../cli-kit/dist/public/node/vendor/otel-js/service/BaseOtelService/BaseOtelService.js
init_cjs_shims();
var import_sdk_metrics3 = __toESM(require_src5(), 1);

// ../cli-kit/dist/public/node/vendor/otel-js/utils/validators.js
init_cjs_shims();
var import_api2 = __toESM(require_src(), 1), validMetricRegex = new RegExp("[^a-zA-Z_][^a-zA-Z0-9_]*");
function isValidMetricName(value) {
  return validMetricRegex.test(value) ? (import_api2.diag.warn(`Metric name ${value} contains invalid characters and will be dropped.
    Service Names and metric names must conform to the following regex %c[a-zA-Z_][a-zA-Z0-9_]*`, "color:red"), !1) : !0;
}

// ../cli-kit/dist/public/node/vendor/otel-js/service/BaseOtelService/BaseOtelService.js
var instrumentationScope = "opentelemetry-js-shopify-web", BaseOtelService = class {
  /**
   * Bootstraps an Otel exporter which can send Otel metrics to a dedicated Shopify supported collector endpoint.
   */
  constructor({ serviceName, prefixMetric = !1, metrics = {}, onRecord, meterProvider }) {
    if (this.metrics = /* @__PURE__ */ new Map(), this.recordListeners = /* @__PURE__ */ new Set(), !serviceName)
      throw new Error("Service name is required.");
    if (this.serviceName = serviceName, this.prefixMetric = prefixMetric, onRecord && this.addOnRecord(onRecord), !meterProvider)
      throw new Error("MeterProvider is required.");
    this.meterProvider = meterProvider, this.register(metrics);
  }
  getMeterProvider() {
    return this.meterProvider;
  }
  addView(viewOptions) {
    this.meterProvider._sharedState?.viewRegistry?.addView?.(new import_sdk_metrics3.View(viewOptions));
  }
  record(metricName, value, labels) {
    let recordMetric = this.metrics.get(metricName);
    if (!recordMetric)
      throw new Error(`Service ${this.serviceName} has no metrics registered for name: ${metricName}. Can't record value for unknown metric.`);
    recordMetric(value, labels);
  }
  registerMetric(metricName, { type, ...options }) {
    if (this.metrics.has(metricName))
      return;
    let meter = this.meterProvider.getMeter(instrumentationScope), name = this.prefixMetric ? `${this.serviceName}_${metricName}` : metricName;
    if (!isValidMetricName(name))
      return;
    let createInstrument = () => {
      switch (type) {
        case MetricInstrumentType.Counter:
          return meter.createCounter(name, options);
        case MetricInstrumentType.UpDownCounter:
          return meter.createUpDownCounter(name, options);
        case MetricInstrumentType.Histogram:
          return "boundaries" in options && this.addView({
            instrumentName: name,
            aggregation: new import_sdk_metrics3.ExplicitBucketHistogramAggregation(options.boundaries, !0)
          }), meter.createHistogram(name, options);
      }
    };
    this.metrics.set(metricName, (firstValue, firstLabels) => {
      let instrument = createInstrument(), record = (value, labels) => {
        let [finalValue, finalLabels] = this.notifyRecordListeners(
          metricName,
          value,
          // ensures an new object is created so we don't mutate the original
          { ...labels }
        );
        "record" in instrument ? instrument.record(finalValue, finalLabels) : instrument.add(finalValue, finalLabels), this.meterProvider.forceFlush({});
      };
      record(firstValue, firstLabels), this.metrics.set(metricName, record);
    });
  }
  register(metrics) {
    Object.entries(metrics).forEach(([metricName, options]) => {
      this.registerMetric(metricName, options);
    });
  }
  addOnRecord(onRecord) {
    return this.recordListeners.add(onRecord), () => {
      this.recordListeners.delete(onRecord);
    };
  }
  removeOnRecord(onRecord) {
    this.recordListeners.delete(onRecord);
  }
  shutdown() {
    return this.metrics.clear(), this.recordListeners.clear(), this.meterProvider.shutdown();
  }
  notifyRecordListeners(metricName, initialValue, initialLabels) {
    return Array.from(this.recordListeners).reduce((recordArgs, listener) => listener(metricName, ...recordArgs) || recordArgs, [initialValue, initialLabels]);
  }
};

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultOtelService.js
var import_api3 = __toESM(require_src(), 1), DefaultOtelService = class extends BaseOtelService {
  /**
   * Bootstraps an Otel exporter which can send Otel metrics to a dedicated Shopify supported collector endpoint.
   */
  constructor({
    throttleLimit = 5e3,
    env = "local",
    serviceName,
    prefixMetric = !1,
    metrics = {},
    onRecord,
    meterProvider,
    useXhr = !1,
    // CLI addition
    otelEndpoint
  }) {
    import_api3.diag.setLogger(new import_api3.DiagConsoleLogger(), ["production", "staging"].includes(env) ? import_api3.DiagLogLevel.ERROR : import_api3.DiagLogLevel.INFO), super({
      serviceName,
      meterProvider: meterProvider ?? new DefaultMeterProvider({
        serviceName,
        env,
        throttleLimit,
        useXhr,
        // CLI addition
        otelEndpoint
      }),
      prefixMetric,
      metrics,
      onRecord
    });
  }
  shutdown() {
    return import_api3.diag.disable(), super.shutdown();
  }
};

// ../cli-kit/dist/private/node/otel-metrics.js
var import_api4 = __toESM(require_src(), 1), Name;
(function(Name2) {
  Name2.Counter = "cli_commands_total", Name2.Duration = "cli_commands_duration_ms", Name2.Elapsed = "cli_commands_wall_clock_elapsed_ms";
})(Name || (Name = {}));
async function recordMetrics(options, timing, recorderFactory = createMetricRecorder) {
  let recorder = recorderFactory({
    skipMetricAnalytics: options.skipMetricAnalytics,
    otelOptions: defaultOtelOptions()
  }), regularisedCliVersion = options.cliVersion;
  options.cliVersion.includes("nightly") ? regularisedCliVersion = "nightly" : options.cliVersion.includes("pre") && (regularisedCliVersion = "pre");
  let labels = {
    exit: options.exitMode,
    job: `${options.owningPlugin}::${options.command}`,
    cli_version: regularisedCliVersion
  };
  recordCommandCounter(recorder, labels), recordCommandTiming(recorder, labels, timing);
}
function defaultOtelOptions() {
  return {
    serviceName: "shopify-cli",
    throttleLimit: 1e3,
    prefixMetric: !1,
    metrics: {
      [Name.Counter]: {
        type: MetricInstrumentType.Counter,
        description: "Total number of CLI commands executed",
        valueType: import_api4.ValueType.INT
      },
      [Name.Duration]: {
        type: MetricInstrumentType.Histogram,
        description: "Total time spent in execution of CLI commands. Does not include time spent waiting for network, prompts, etc.",
        valueType: import_api4.ValueType.INT,
        boundaries: [0, 100, 250, 500, 1e3, 2e3, 5e3, 1e4, 2e4, 5e4]
      },
      [Name.Elapsed]: {
        type: MetricInstrumentType.Histogram,
        description: "Total time elapsed from start to finish of CLI commands. Includes time spent waiting for network, prompts, etc.",
        valueType: import_api4.ValueType.INT,
        boundaries: [0, 100, 250, 500, 1e3, 2e3, 5e3, 1e4, 2e4, 5e4]
      }
    }
  };
}
function createMetricRecorder(options) {
  let recorder = "console";
  return options.skipMetricAnalytics || isUnitTest() || isSpinEnvironment() || (recorder = {
    type: "otel",
    otel: globalOtelService(options)
  }), recorder;
}
var _otelService;
function globalOtelService(options) {
  return _otelService || (_otelService = new DefaultOtelService({
    ...options.otelOptions,
    env: void 0,
    otelEndpoint: `${opentelemetryDomain()}/v1/metrics`
  })), _otelService;
}
function recordCommandCounter(recorder, labels) {
  if (recorder === "console") {
    outputDebug(outputContent`[OTEL] record ${Name.Counter} counter ${outputToken.json({ labels })}`);
    return;
  }
  recorder.otel.record(Name.Counter, 1, labels);
}
function recordCommandTiming(recorder, labels, timing) {
  if (recorder === "console") {
    outputDebug(outputContent`[OTEL] record ${Name.Duration} histogram ${timing.active.toString()}ms ${outputToken.json({
      labels
    })}`), outputDebug(outputContent`[OTEL] record ${Name.Elapsed} histogram stage="active" ${timing.active.toString()}ms`), outputDebug(outputContent`[OTEL] record ${Name.Elapsed} histogram stage="network" ${timing.network.toString()}ms`), outputDebug(outputContent`[OTEL] record ${Name.Elapsed} histogram stage="prompt" ${timing.prompt.toString()}ms`);
    return;
  }
  timing.active > 0 && (recorder.otel.record(Name.Duration, timing.active, labels), recorder.otel.record(Name.Elapsed, timing.active, { ...labels, stage: "active" })), timing.network > 0 && recorder.otel.record(Name.Elapsed, timing.network, { ...labels, stage: "network" }), timing.prompt > 0 && recorder.otel.record(Name.Elapsed, timing.prompt, { ...labels, stage: "prompt" });
}

// ../cli-kit/dist/public/node/analytics.js
async function reportAnalyticsEvent(options) {
  try {
    let payload = await buildPayload(options);
    if (payload === void 0)
      return;
    let withinRateLimit = !1;
    if (await runWithRateLimit({
      key: "report-analytics-event",
      ...reportingRateLimit,
      task: async () => {
        withinRateLimit = !0;
      }
    }), !withinRateLimit) {
      outputDebug(outputContent`Skipping command analytics due to rate limiting, payload: ${outputToken.json(payload)}`);
      return;
    }
    let skipMonorailAnalytics = !alwaysLogAnalytics() && analyticsDisabled(), skipMetricAnalytics = !alwaysLogMetrics() && analyticsDisabled();
    (skipMonorailAnalytics || skipMetricAnalytics) && outputDebug(outputContent`Skipping command analytics, payload: ${outputToken.json(payload)}`);
    let doMonorail = async () => {
      if (skipMonorailAnalytics)
        return;
      let response = await publishMonorailEvent(MONORAIL_COMMAND_TOPIC, payload.public, payload.sensitive);
      response.type === "error" && outputDebug(response.message);
    }, doOpenTelemetry = async () => {
      let active = payload.public.cmd_all_timing_active_ms || 0, network = payload.public.cmd_all_timing_network_ms || 0, prompt = payload.public.cmd_all_timing_prompts_ms || 0;
      return recordMetrics({
        skipMetricAnalytics,
        cliVersion: payload.public.cli_version,
        owningPlugin: payload.public.cmd_all_plugin || "@shopify/cli",
        command: payload.public.command,
        exitMode: options.exitMode
      }, {
        active,
        network,
        prompt
      });
    };
    await Promise.all([doMonorail(), doOpenTelemetry()]);
  } catch (error) {
    let message = "Failed to report usage analytics";
    error instanceof Error && (message = message.concat(`: ${error.message}`)), outputDebug(message);
  }
}
async function buildPayload({ config, errorMessage, exitMode }) {
  let { commandStartOptions, environmentFlags, ...sensitiveMetadata } = getAllSensitiveMetadata();
  if (commandStartOptions === void 0) {
    outputDebug("Unable to log analytics event - no information on executed command");
    return;
  }
  let { startCommand, startArgs, startTime } = commandStartOptions, currentTime = (/* @__PURE__ */ new Date()).getTime(), { "@shopify/cli": internalPluginsPublic, ...externalPluginsPublic } = await fanoutHooks(config, "public_command_metadata", {}), { "@shopify/cli": internalPluginsSensitive, ...externalPluginsSensitive } = await fanoutHooks(config, "sensitive_command_metadata", {}), environmentData = await getEnvironmentData(config), sensitiveEnvironmentData = await getSensitiveEnvironmentData(config), publicMetadata = getAllPublicMetadata(), totalTimeFromSubtimers = ["cmd_all_timing_network_ms", "cmd_all_timing_prompts_ms"].reduce((total, timer) => {
    let value = publicMetadata[timer];
    return value !== void 0 ? total + value : total;
  }, 0), wallClockElapsed = currentTime - startTime, totalTimeWithoutSubtimers = wallClockElapsed - totalTimeFromSubtimers, payload = {
    public: {
      command: startCommand,
      time_start: startTime,
      time_end: currentTime,
      total_time: wallClockElapsed,
      success: exitMode === "ok" && errorMessage === void 0,
      cli_version: CLI_KIT_VERSION,
      ruby_version: "",
      node_version: process.version.replace("v", ""),
      is_employee: await isShopify(),
      ...environmentData,
      ...internalPluginsPublic,
      ...publicMetadata,
      cmd_all_timing_active_ms: totalTimeWithoutSubtimers,
      cmd_all_exit: exitMode,
      user_id: await getLastSeenUserIdAfterAuth()
    },
    sensitive: {
      args: startArgs.join(" "),
      cmd_all_environment_flags: environmentFlags,
      error_message: errorMessage,
      ...internalPluginsSensitive,
      ...sensitiveEnvironmentData,
      metadata: JSON.stringify({
        ...sensitiveMetadata,
        extraPublic: {
          ...externalPluginsPublic
        },
        extraSensitive: { ...externalPluginsSensitive }
      })
    }
  };
  return ["cmd_all_timing_active_ms", "cmd_all_timing_network_ms", "cmd_all_timing_prompts_ms"].forEach((metric) => {
    let current = payload.public[metric];
    current !== void 0 && (payload.public[metric] = Math.floor(current));
  }), payload = JSON.parse(JSON.stringify(payload)), sanitizePayload2(payload);
}
function sanitizePayload2(payload) {
  let sanitizedPayloadString = JSON.stringify(payload).replace(/shptka_\w*/g, "*****");
  return JSON.parse(sanitizedPayloadString);
}

export {
  fanoutHooks,
  getListOfTunnelPlugins,
  reportAnalyticsEvent
};
//# sourceMappingURL=chunk-AT4IG4GJ.js.map
