{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js", "../../../node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js", "../../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js", "../../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js", "../../../node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js", "../../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js", "../../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js", "../../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js", "../../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js", "../../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js", "../../../node_modules/.pnpm/binary-extensions@2.3.0/node_modules/binary-extensions/binary-extensions.json", "../../../node_modules/.pnpm/binary-extensions@2.3.0/node_modules/binary-extensions/index.js", "../../../node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js", "../../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/constants.js", "../../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/nodefs-handler.js", "../../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/fsevents-handler.js", "../../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/index.js"],
  "sourcesContent": ["'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return { files, depth, path };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath(full);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n            const recursiveError = new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            );\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst picomatch = require('picomatch');\nconst normalizePath = require('normalize-path');\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path, false);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n", "'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n", "'use strict';\n\nconst utils = require('./utils');\n\nmodule.exports = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n", "/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n", "'use strict';\n\nconst fill = require('fill-range');\nconst utils = require('./utils');\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fill(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n", "'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n", "'use strict';\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n", "'use strict';\n\nconst stringify = require('./stringify');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  let memo = {};\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let closed = true;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n", "'use strict';\n\nconst stringify = require('./lib/stringify');\nconst compile = require('./lib/compile');\nconst expand = require('./lib/expand');\nconst parse = require('./lib/parse');\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n", "[\n\t\"3dm\",\n\t\"3ds\",\n\t\"3g2\",\n\t\"3gp\",\n\t\"7z\",\n\t\"a\",\n\t\"aac\",\n\t\"adp\",\n\t\"afdesign\",\n\t\"afphoto\",\n\t\"afpub\",\n\t\"ai\",\n\t\"aif\",\n\t\"aiff\",\n\t\"alz\",\n\t\"ape\",\n\t\"apk\",\n\t\"appimage\",\n\t\"ar\",\n\t\"arj\",\n\t\"asf\",\n\t\"au\",\n\t\"avi\",\n\t\"bak\",\n\t\"baml\",\n\t\"bh\",\n\t\"bin\",\n\t\"bk\",\n\t\"bmp\",\n\t\"btif\",\n\t\"bz2\",\n\t\"bzip2\",\n\t\"cab\",\n\t\"caf\",\n\t\"cgm\",\n\t\"class\",\n\t\"cmx\",\n\t\"cpio\",\n\t\"cr2\",\n\t\"cur\",\n\t\"dat\",\n\t\"dcm\",\n\t\"deb\",\n\t\"dex\",\n\t\"djvu\",\n\t\"dll\",\n\t\"dmg\",\n\t\"dng\",\n\t\"doc\",\n\t\"docm\",\n\t\"docx\",\n\t\"dot\",\n\t\"dotm\",\n\t\"dra\",\n\t\"DS_Store\",\n\t\"dsk\",\n\t\"dts\",\n\t\"dtshd\",\n\t\"dvb\",\n\t\"dwg\",\n\t\"dxf\",\n\t\"ecelp4800\",\n\t\"ecelp7470\",\n\t\"ecelp9600\",\n\t\"egg\",\n\t\"eol\",\n\t\"eot\",\n\t\"epub\",\n\t\"exe\",\n\t\"f4v\",\n\t\"fbs\",\n\t\"fh\",\n\t\"fla\",\n\t\"flac\",\n\t\"flatpak\",\n\t\"fli\",\n\t\"flv\",\n\t\"fpx\",\n\t\"fst\",\n\t\"fvt\",\n\t\"g3\",\n\t\"gh\",\n\t\"gif\",\n\t\"graffle\",\n\t\"gz\",\n\t\"gzip\",\n\t\"h261\",\n\t\"h263\",\n\t\"h264\",\n\t\"icns\",\n\t\"ico\",\n\t\"ief\",\n\t\"img\",\n\t\"ipa\",\n\t\"iso\",\n\t\"jar\",\n\t\"jpeg\",\n\t\"jpg\",\n\t\"jpgv\",\n\t\"jpm\",\n\t\"jxr\",\n\t\"key\",\n\t\"ktx\",\n\t\"lha\",\n\t\"lib\",\n\t\"lvp\",\n\t\"lz\",\n\t\"lzh\",\n\t\"lzma\",\n\t\"lzo\",\n\t\"m3u\",\n\t\"m4a\",\n\t\"m4v\",\n\t\"mar\",\n\t\"mdi\",\n\t\"mht\",\n\t\"mid\",\n\t\"midi\",\n\t\"mj2\",\n\t\"mka\",\n\t\"mkv\",\n\t\"mmr\",\n\t\"mng\",\n\t\"mobi\",\n\t\"mov\",\n\t\"movie\",\n\t\"mp3\",\n\t\"mp4\",\n\t\"mp4a\",\n\t\"mpeg\",\n\t\"mpg\",\n\t\"mpga\",\n\t\"mxu\",\n\t\"nef\",\n\t\"npx\",\n\t\"numbers\",\n\t\"nupkg\",\n\t\"o\",\n\t\"odp\",\n\t\"ods\",\n\t\"odt\",\n\t\"oga\",\n\t\"ogg\",\n\t\"ogv\",\n\t\"otf\",\n\t\"ott\",\n\t\"pages\",\n\t\"pbm\",\n\t\"pcx\",\n\t\"pdb\",\n\t\"pdf\",\n\t\"pea\",\n\t\"pgm\",\n\t\"pic\",\n\t\"png\",\n\t\"pnm\",\n\t\"pot\",\n\t\"potm\",\n\t\"potx\",\n\t\"ppa\",\n\t\"ppam\",\n\t\"ppm\",\n\t\"pps\",\n\t\"ppsm\",\n\t\"ppsx\",\n\t\"ppt\",\n\t\"pptm\",\n\t\"pptx\",\n\t\"psd\",\n\t\"pya\",\n\t\"pyc\",\n\t\"pyo\",\n\t\"pyv\",\n\t\"qt\",\n\t\"rar\",\n\t\"ras\",\n\t\"raw\",\n\t\"resources\",\n\t\"rgb\",\n\t\"rip\",\n\t\"rlc\",\n\t\"rmf\",\n\t\"rmvb\",\n\t\"rpm\",\n\t\"rtf\",\n\t\"rz\",\n\t\"s3m\",\n\t\"s7z\",\n\t\"scpt\",\n\t\"sgi\",\n\t\"shar\",\n\t\"snap\",\n\t\"sil\",\n\t\"sketch\",\n\t\"slk\",\n\t\"smv\",\n\t\"snk\",\n\t\"so\",\n\t\"stl\",\n\t\"suo\",\n\t\"sub\",\n\t\"swf\",\n\t\"tar\",\n\t\"tbz\",\n\t\"tbz2\",\n\t\"tga\",\n\t\"tgz\",\n\t\"thmx\",\n\t\"tif\",\n\t\"tiff\",\n\t\"tlz\",\n\t\"ttc\",\n\t\"ttf\",\n\t\"txz\",\n\t\"udf\",\n\t\"uvh\",\n\t\"uvi\",\n\t\"uvm\",\n\t\"uvp\",\n\t\"uvs\",\n\t\"uvu\",\n\t\"viv\",\n\t\"vob\",\n\t\"war\",\n\t\"wav\",\n\t\"wax\",\n\t\"wbmp\",\n\t\"wdp\",\n\t\"weba\",\n\t\"webm\",\n\t\"webp\",\n\t\"whl\",\n\t\"wim\",\n\t\"wm\",\n\t\"wma\",\n\t\"wmv\",\n\t\"wmx\",\n\t\"woff\",\n\t\"woff2\",\n\t\"wrm\",\n\t\"wvx\",\n\t\"xbm\",\n\t\"xif\",\n\t\"xla\",\n\t\"xlam\",\n\t\"xls\",\n\t\"xlsb\",\n\t\"xlsm\",\n\t\"xlsx\",\n\t\"xlt\",\n\t\"xltm\",\n\t\"xltx\",\n\t\"xm\",\n\t\"xmind\",\n\t\"xpi\",\n\t\"xpm\",\n\t\"xwd\",\n\t\"xz\",\n\t\"z\",\n\t\"zip\",\n\t\"zipx\"\n]\n", "module.exports = require('./binary-extensions.json');\n", "'use strict';\nconst path = require('path');\nconst binaryExtensions = require('binary-extensions');\n\nconst extensions = new Set(binaryExtensions);\n\nmodule.exports = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n", "'use strict';\n\nconst {sep} = require('path');\nconst {platform} = process;\nconst os = require('os');\n\nexports.EV_ALL = 'all';\nexports.EV_READY = 'ready';\nexports.EV_ADD = 'add';\nexports.EV_CHANGE = 'change';\nexports.EV_ADD_DIR = 'addDir';\nexports.EV_UNLINK = 'unlink';\nexports.EV_UNLINK_DIR = 'unlinkDir';\nexports.EV_RAW = 'raw';\nexports.EV_ERROR = 'error';\n\nexports.STR_DATA = 'data';\nexports.STR_END = 'end';\nexports.STR_CLOSE = 'close';\n\nexports.FSEVENT_CREATED = 'created';\nexports.FSEVENT_MODIFIED = 'modified';\nexports.FSEVENT_DELETED = 'deleted';\nexports.FSEVENT_MOVED = 'moved';\nexports.FSEVENT_CLONED = 'cloned';\nexports.FSEVENT_UNKNOWN = 'unknown';\nexports.FSEVENT_TYPE_FILE = 'file';\nexports.FSEVENT_TYPE_DIRECTORY = 'directory';\nexports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\nexports.KEY_LISTENERS = 'listeners';\nexports.KEY_ERR = 'errHandlers';\nexports.KEY_RAW = 'rawEmitters';\nexports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\nexports.DOT_SLASH = `.${sep}`;\n\nexports.BACK_SLASH_RE = /\\\\/g;\nexports.DOUBLE_SLASH_RE = /\\/\\//;\nexports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\nexports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\nexports.REPLACER_RE = /^\\.[/\\\\]/;\n\nexports.SLASH = '/';\nexports.SLASH_SLASH = '//';\nexports.BRACE_START = '{';\nexports.BANG = '!';\nexports.ONE_DOT = '.';\nexports.TWO_DOTS = '..';\nexports.STAR = '*';\nexports.GLOBSTAR = '**';\nexports.ROOT_GLOBSTAR = '/**/*';\nexports.SLASH_GLOBSTAR = '/**';\nexports.DIR_SUFFIX = 'Dir';\nexports.ANYMATCH_OPTS = {dot: true};\nexports.STRING_TYPE = 'string';\nexports.FUNCTION_TYPE = 'function';\nexports.EMPTY_STR = '';\nexports.EMPTY_FN = () => {};\nexports.IDENTITY_FN = val => val;\n\nexports.isWindows = platform === 'win32';\nexports.isMacos = platform === 'darwin';\nexports.isLinux = platform === 'linux';\nexports.isIBMi = os.type() === 'OS400';\n", "'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst isBinaryPath = require('is-binary-path');\nconst {\n  isWindows,\n  isLinux,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR\n} = require('./constants');\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify(fs.open);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst close = promisify(fs.close);\nconst fsrealpath = promisify(fs.realpath);\n\nconst statMethods = { lstat, stat };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n  let listeners = new Set();\n  let rawEmitters = new Set();\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath.dirname(path);\n  const basename = sysPath.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath.dirname(file);\n  const basename = sysPath.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path)\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n    this.fsw._emit(EV_ADD, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n\n    let linkPath;\n    try {\n      linkPath = await fsrealpath(path);\n    } catch (e) {\n      this.fsw._emitReady();\n      return true;\n    }\n\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath.join(directory, EMPTY_STR);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath.join(dir, sysPath.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n  const tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n    let closer;\n    if (stats.isDirectory()) {\n      const absPath = sysPath.resolve(path);\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (absPath !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(absPath, targetPath);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n}\n\nmodule.exports = NodeFsHandler;\n", "'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\n\nlet fsevents;\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = require('./constants');\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\nconst statMethods = { stat, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\n\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n)\n\n/**\n * @mixin\n */\nclass FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat(path)\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath.dirname(path);\n    const item = sysPath.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE) {\n        let stats;\n        try {\n          stats = await stat(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n  const base = sysPath.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n", "'use strict';\n\nconst { EventEmitter } = require('events');\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst readdirp = require('readdirp');\nconst anymatch = require('anymatch').default;\nconst globParent = require('glob-parent');\nconst isGlob = require('is-glob');\nconst braces = require('braces');\nconst normalizePath = require('normalize-path');\n\nconst NodeFsHandler = require('./lib/nodefs-handler');\nconst FsEventsHandler = require('./lib/fsevents-handler');\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos,\n  isIBMi\n} = require('./lib/constants');\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n  if(isIBMi) {\n    opts.usePolling = true;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You\u2019re frozen when your heart\u2019s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path)\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;\n"],
  "mappings": ";;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAEA,QAAM,KAAK,UAAQ,IAAI,GACjB,EAAE,SAAS,IAAI,UAAQ,QAAQ,GAC/B,UAAU,UAAQ,MAAM,GACxB,EAAE,UAAU,IAAI,UAAQ,MAAM,GAC9B,YAAY,qBAEZ,UAAU,UAAU,GAAG,OAAO,GAC9B,OAAO,UAAU,GAAG,IAAI,GACxB,QAAQ,UAAU,GAAG,KAAK,GAC1B,WAAW,UAAU,GAAG,QAAQ,GAWhC,OAAO,KACP,uBAAuB,4BACvB,qBAAqB,oBAAI,IAAI,CAAC,UAAU,SAAS,UAAU,SAAS,oBAAoB,CAAC,GACzF,YAAY,SACZ,WAAW,eACX,gBAAgB,qBAChB,kBAAkB,OAClB,YAAY,CAAC,WAAW,UAAU,eAAe,eAAe,GAEhE,oBAAoB,WAAS,mBAAmB,IAAI,MAAM,IAAI,GAC9D,CAAC,KAAK,GAAG,IAAI,QAAQ,SAAS,KAAK,MAAM,GAAG,EAAE,MAAM,GAAG,CAAC,EAAE,IAAI,OAAK,OAAO,SAAS,GAAG,EAAE,CAAC,GACzF,oBAAoB,QAAQ,aAAa,YAAY,MAAM,MAAO,QAAQ,MAAM,OAAO,IAEvF,kBAAkB,YAAU;AAChC,UAAI,WAAW,QACf;AAAA,YAAI,OAAO,UAAW;AAAY,iBAAO;AAEzC,YAAI,OAAO,UAAW,UAAU;AAC9B,cAAM,OAAO,UAAU,OAAO,KAAK,CAAC;AACpC,iBAAO,WAAS,KAAK,MAAM,QAAQ;AAAA,QACrC;AAEA,YAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,cAAM,WAAW,CAAC,GACZ,WAAW,CAAC;AAClB,mBAAW,QAAQ,QAAQ;AACzB,gBAAM,UAAU,KAAK,KAAK;AAC1B,YAAI,QAAQ,OAAO,CAAC,MAAM,OACxB,SAAS,KAAK,UAAU,QAAQ,MAAM,CAAC,CAAC,CAAC,IAEzC,SAAS,KAAK,UAAU,OAAO,CAAC;AAAA,UAEpC;AAEA,iBAAI,SAAS,SAAS,IAChB,SAAS,SAAS,IACb,WACL,SAAS,KAAK,OAAK,EAAE,MAAM,QAAQ,CAAC,KAAK,CAAC,SAAS,KAAK,OAAK,EAAE,MAAM,QAAQ,CAAC,IAE3E,WAAS,CAAC,SAAS,KAAK,OAAK,EAAE,MAAM,QAAQ,CAAC,IAEhD,WAAS,SAAS,KAAK,OAAK,EAAE,MAAM,QAAQ,CAAC;AAAA,QACtD;AAAA;AAAA,IACF,GAEM,iBAAN,MAAM,wBAAuB,SAAS;AAAA,MACpC,WAAW,iBAAiB;AAC1B,eAAO;AAAA,UACL,MAAM;AAAA;AAAA,UAEN,YAAY,CAAC,SAAS;AAAA,UACtB,iBAAiB,CAAC,SAAS;AAAA;AAAA,UAE3B,MAAM;AAAA,UACN,OAAO;AAAA,UACP,OAAO;AAAA,UACP,YAAY;AAAA,QACd;AAAA,MACF;AAAA,MAEA,YAAY,UAAU,CAAC,GAAG;AACxB,cAAM;AAAA,UACJ,YAAY;AAAA,UACZ,aAAa;AAAA,UACb,eAAe,QAAQ,iBAAiB;AAAA,QAC1C,CAAC;AACD,YAAM,OAAO,EAAE,GAAG,gBAAe,gBAAgB,GAAG,QAAQ,GACtD,EAAE,MAAM,KAAK,IAAI;AAEvB,aAAK,cAAc,gBAAgB,KAAK,UAAU,GAClD,KAAK,mBAAmB,gBAAgB,KAAK,eAAe;AAE5D,YAAM,aAAa,KAAK,QAAQ,QAAQ;AAExC,QAAI,oBACF,KAAK,QAAQ,UAAQ,WAAW,MAAM,EAAE,QAAQ,GAAK,CAAC,IAEtD,KAAK,QAAQ,YAGf,KAAK,YAAY,KAAK,OACtB,KAAK,YAAY,CAAC,UAAU,eAAe,eAAe,EAAE,SAAS,IAAI,GACzE,KAAK,aAAa,CAAC,WAAW,eAAe,eAAe,EAAE,SAAS,IAAI,GAC3E,KAAK,mBAAmB,SAAS,iBACjC,KAAK,QAAQ,QAAQ,QAAQ,IAAI,GACjC,KAAK,YAAa,YAAY,MAAO,CAAC,KAAK,YAC3C,KAAK,aAAa,KAAK,YAAY,WAAW,SAC9C,KAAK,aAAa,EAAE,UAAU,QAAQ,eAAe,KAAK,UAAU,GAGpE,KAAK,UAAU,CAAC,KAAK,YAAY,MAAM,CAAC,CAAC,GACzC,KAAK,UAAU,IACf,KAAK,SAAS;AAAA,MAChB;AAAA,MAEA,MAAM,MAAM,OAAO;AACjB,YAAI,MAAK,SACT;AAAA,eAAK,UAAU;AAEf,cAAI;AACF,mBAAO,CAAC,KAAK,aAAa,QAAQ,KAAG;AACnC,kBAAM,EAAE,MAAM,OAAO,QAAQ,CAAC,EAAE,IAAI,KAAK,UAAU,CAAC;AAEpD,kBAAI,MAAM,SAAS,GAAG;AACpB,oBAAM,QAAQ,MAAM,OAAO,GAAG,KAAK,EAAE,IAAI,YAAU,KAAK,aAAa,QAAQ,IAAI,CAAC;AAClF,yBAAW,SAAS,MAAM,QAAQ,IAAI,KAAK,GAAG;AAC5C,sBAAI,KAAK;AAAW;AAEpB,sBAAM,YAAY,MAAM,KAAK,cAAc,KAAK;AAChD,kBAAI,cAAc,eAAe,KAAK,iBAAiB,KAAK,KACtD,SAAS,KAAK,aAChB,KAAK,QAAQ,KAAK,KAAK,YAAY,MAAM,UAAU,QAAQ,CAAC,CAAC,GAG3D,KAAK,cACP,KAAK,KAAK,KAAK,GACf,aAEQ,cAAc,UAAU,KAAK,eAAe,KAAK,MAAM,KAAK,YAAY,KAAK,KACnF,KAAK,eACP,KAAK,KAAK,KAAK,GACf;AAAA,gBAGN;AAAA,cACF,OAAO;AACL,oBAAM,SAAS,KAAK,QAAQ,IAAI;AAChC,oBAAI,CAAC,QAAQ;AACX,uBAAK,KAAK,IAAI;AACd;AAAA,gBACF;AAEA,oBADA,KAAK,SAAS,MAAM,QAChB,KAAK;AAAW;AAAA,cACtB;AAAA,YACF;AAAA,UACF,SAAS,OAAO;AACd,iBAAK,QAAQ,KAAK;AAAA,UACpB,UAAE;AACA,iBAAK,UAAU;AAAA,UACjB;AAAA;AAAA,MACF;AAAA,MAEA,MAAM,YAAY,MAAM,OAAO;AAC7B,YAAI;AACJ,YAAI;AACF,kBAAQ,MAAM,QAAQ,MAAM,KAAK,UAAU;AAAA,QAC7C,SAAS,OAAO;AACd,eAAK,SAAS,KAAK;AAAA,QACrB;AACA,eAAO,EAAE,OAAO,OAAO,KAAK;AAAA,MAC9B;AAAA,MAEA,MAAM,aAAa,QAAQ,MAAM;AAC/B,YAAI;AACJ,YAAI;AACF,cAAM,WAAW,KAAK,YAAY,OAAO,OAAO,QAC1C,WAAW,QAAQ,QAAQ,QAAQ,KAAK,MAAM,QAAQ,CAAC;AAC7D,kBAAQ,EAAE,MAAM,QAAQ,SAAS,KAAK,OAAO,QAAQ,GAAG,UAAU,SAAS,GAC3E,MAAM,KAAK,UAAU,IAAI,KAAK,YAAY,SAAS,MAAM,KAAK,MAAM,QAAQ;AAAA,QAC9E,SAAS,KAAK;AACZ,eAAK,SAAS,GAAG;AAAA,QACnB;AACA,eAAO;AAAA,MACT;AAAA,MAEA,SAAS,KAAK;AACZ,QAAI,kBAAkB,GAAG,KAAK,CAAC,KAAK,YAClC,KAAK,KAAK,QAAQ,GAAG,IAErB,KAAK,QAAQ,GAAG;AAAA,MAEpB;AAAA,MAEA,MAAM,cAAc,OAAO;AAGzB,YAAM,QAAQ,SAAS,MAAM,KAAK,UAAU;AAC5C,YAAK,OAGL;AAAA,cAAI,MAAM,OAAO;AACf,mBAAO;AAET,cAAI,MAAM,YAAY;AACpB,mBAAO;AAET,cAAI,SAAS,MAAM,eAAe,GAAG;AACnC,gBAAM,OAAO,MAAM;AACnB,gBAAI;AACF,kBAAM,gBAAgB,MAAM,SAAS,IAAI,GACnC,qBAAqB,MAAM,MAAM,aAAa;AACpD,kBAAI,mBAAmB,OAAO;AAC5B,uBAAO;AAET,kBAAI,mBAAmB,YAAY,GAAG;AACpC,oBAAM,MAAM,cAAc;AAC1B,oBAAI,KAAK,WAAW,aAAa,KAAK,KAAK,OAAO,KAAK,CAAC,MAAM,QAAQ,KAAK;AACzE,sBAAM,iBAAiB,IAAI;AAAA,oBACzB,+BAA+B,IAAI,gBAAgB,aAAa;AAAA,kBAClE;AACA,wCAAe,OAAO,sBACf,KAAK,SAAS,cAAc;AAAA,gBACrC;AACA,uBAAO;AAAA,cACT;AAAA,YACF,SAAS,OAAO;AACd,mBAAK,SAAS,KAAK;AAAA,YACrB;AAAA,UACF;AAAA;AAAA,MACF;AAAA,MAEA,eAAe,OAAO;AACpB,YAAM,QAAQ,SAAS,MAAM,KAAK,UAAU;AAE5C,eAAO,SAAS,KAAK,oBAAoB,CAAC,MAAM,YAAY;AAAA,MAC9D;AAAA,IACF,GAkBM,WAAW,CAAC,MAAM,UAAU,CAAC,MAAM;AACvC,UAAI,OAAO,QAAQ,aAAa,QAAQ;AAGxC,UAFI,SAAS,WAAQ,OAAO,gBACxB,SAAM,QAAQ,OAAO,OACpB,MAEE;AAAA,YAAI,OAAO,QAAS;AACzB,gBAAM,IAAI,UAAU,0EAA0E;AACzF,YAAI,QAAQ,CAAC,UAAU,SAAS,IAAI;AACzC,gBAAM,IAAI,MAAM,6CAA6C,UAAU,KAAK,IAAI,CAAC,EAAE;AAAA;AAJnF,cAAM,IAAI,MAAM,qEAAqE;AAOvF,qBAAQ,OAAO,MACR,IAAI,eAAe,OAAO;AAAA,IACnC,GAEM,kBAAkB,CAAC,MAAM,UAAU,CAAC,MACjC,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAM,QAAQ,CAAC;AACf,eAAS,MAAM,OAAO,EACnB,GAAG,QAAQ,WAAS,MAAM,KAAK,KAAK,CAAC,EACrC,GAAG,OAAO,MAAM,QAAQ,KAAK,CAAC,EAC9B,GAAG,SAAS,WAAS,OAAO,KAAK,CAAC;AAAA,IACvC,CAAC;AAGH,aAAS,UAAU;AACnB,aAAS,iBAAiB;AAC1B,aAAS,UAAU;AAEnB,WAAO,UAAU;AAAA;AAAA;;;AC9RjB;AAAA;AAAA;AAAA;AAEA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,GAAK,CAAC;AAE5D,QAAM,YAAY,qBACZ,gBAAgB,0BAOhB,OAAO,KACP,kBAAkB,EAAC,aAAa,GAAK,GACrC,SAAS,CAAC,SAAS,MAAM,QAAQ,IAAI,IAAI,OAAO,CAAC,IAAI,GAOrD,gBAAgB,CAAC,SAAS,YAAY;AAC1C,UAAI,OAAO,WAAY;AACrB,eAAO;AAET,UAAI,OAAO,WAAY,UAAU;AAC/B,YAAM,OAAO,UAAU,SAAS,OAAO;AACvC,eAAO,CAAC,WAAW,YAAY,UAAU,KAAK,MAAM;AAAA,MACtD;AACA,aAAI,mBAAmB,SACd,CAAC,WAAW,QAAQ,KAAK,MAAM,IAEjC,CAAC,WAAW;AAAA,IACrB,GASM,gBAAgB,CAAC,UAAU,aAAa,MAAM,gBAAgB;AAClE,UAAM,SAAS,MAAM,QAAQ,IAAI,GAC3B,QAAQ,SAAS,KAAK,CAAC,IAAI;AACjC,UAAI,CAAC,UAAU,OAAO,SAAU;AAC9B,cAAM,IAAI,UAAU,qDAClB,OAAO,UAAU,SAAS,KAAK,KAAK,CAAC;AAEzC,UAAM,OAAO,cAAc,OAAO,EAAK;AAEvC,eAAS,QAAQ,GAAG,QAAQ,YAAY,QAAQ,SAAS;AACvD,YAAM,QAAQ,YAAY,KAAK;AAC/B,YAAI,MAAM,IAAI;AACZ,iBAAO,cAAc,KAAK;AAAA,MAE9B;AAEA,UAAM,UAAU,UAAU,CAAC,IAAI,EAAE,OAAO,KAAK,MAAM,CAAC,CAAC;AACrD,eAAS,QAAQ,GAAG,QAAQ,SAAS,QAAQ,SAAS;AACpD,YAAM,UAAU,SAAS,KAAK;AAC9B,YAAI,SAAS,QAAQ,GAAG,OAAO,IAAI,QAAQ,IAAI;AAC7C,iBAAO,cAAc,QAAQ;AAAA,MAEjC;AAEA,aAAO,cAAc,KAAK;AAAA,IAC5B,GAQM,WAAW,CAAC,UAAU,YAAY,UAAU,oBAAoB;AACpE,UAAI,YAAY;AACd,cAAM,IAAI,UAAU,kCAAkC;AAExD,UAAM,OAAO,OAAO,WAAY,YAAY,EAAC,aAAa,QAAO,IAAI,SAC/D,cAAc,KAAK,eAAe,IAGlC,UAAU,OAAO,QAAQ,GACzB,eAAe,QAClB,OAAO,UAAQ,OAAO,QAAS,YAAY,KAAK,OAAO,CAAC,MAAM,IAAI,EAClE,IAAI,UAAQ,KAAK,MAAM,CAAC,CAAC,EACzB,IAAI,UAAQ,UAAU,MAAM,IAAI,CAAC,GAC9B,WAAW,QACd,OAAO,UAAQ,OAAO,QAAS,YAAa,OAAO,QAAS,YAAY,KAAK,OAAO,CAAC,MAAM,IAAK,EAChG,IAAI,aAAW,cAAc,SAAS,IAAI,CAAC;AAE9C,aAAI,cAAc,OACT,CAACA,aAAY,KAAK,OAEhB,cAAc,UAAU,cAAcA,aADzB,OAAO,MAAO,YAAY,KAAK,EACiB,IAIjE,cAAc,UAAU,cAAc,YAAY,WAAW;AAAA,IACtE;AAEA,aAAS,UAAU;AACnB,WAAO,UAAU;AAAA;AAAA;;;ACvGjB;AAAA;AAAA;AAAA;AAEA,YAAQ,YAAY,SACd,OAAO,OAAQ,WACV,OAAO,UAAU,GAAG,IAEzB,OAAO,OAAQ,YAAY,IAAI,KAAK,MAAM,KACrC,OAAO,UAAU,OAAO,GAAG,CAAC,IAE9B;AAOT,YAAQ,OAAO,CAAC,MAAM,SAAS,KAAK,MAAM,KAAK,CAAAC,UAAQA,MAAK,SAAS,IAAI;AAMzE,YAAQ,eAAe,CAAC,KAAK,KAAK,OAAO,GAAG,UACtC,UAAU,MACV,CAAC,QAAQ,UAAU,GAAG,KAAK,CAAC,QAAQ,UAAU,GAAG,IAAU,MACtD,OAAO,GAAG,IAAI,OAAO,GAAG,KAAK,OAAO,IAAI,KAAM;AAOzD,YAAQ,aAAa,CAAC,OAAO,IAAI,GAAG,SAAS;AAC3C,UAAI,OAAO,MAAM,MAAM,CAAC;AACxB,MAAK,SAEA,QAAQ,KAAK,SAAS,QAAS,KAAK,SAAS,UAAU,KAAK,SAAS,YACpE,KAAK,YAAY,OACnB,KAAK,QAAQ,OAAO,KAAK,OACzB,KAAK,UAAU;AAAA,IAGrB;AAMA,YAAQ,eAAe,UACjB,KAAK,SAAS,WACb,KAAK,UAAU,IAAI,KAAK,UAAU,IADL,MAEhC,KAAK,UAAU,IACR;AASX,YAAQ,iBAAiB,WACnB,MAAM,SAAS,UAAgB,KAC/B,MAAM,YAAY,MAAQ,MAAM,SAAe,KAC9C,QAAM,UAAU,IAAI,MAAM,UAAU,MAIrC,MAAM,SAAS,MAAQ,MAAM,UAAU,MACzC,MAAM,UAAU,IACT,MAEF;AAOT,YAAQ,gBAAgB,UAClB,KAAK,SAAS,UAAU,KAAK,SAAS,UACjC,KAEF,KAAK,SAAS,MAAQ,KAAK,UAAU;AAO9C,YAAQ,SAAS,WAAS,MAAM,OAAO,CAAC,KAAK,UACvC,KAAK,SAAS,UAAQ,IAAI,KAAK,KAAK,KAAK,GACzC,KAAK,SAAS,YAAS,KAAK,OAAO,SAChC,MACN,CAAC,CAAC;AAML,YAAQ,UAAU,IAAI,SAAS;AAC7B,UAAM,SAAS,CAAC,GACV,OAAO,SAAO;AAClB,iBAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,cAAI,MAAM,IAAI,CAAC;AACf,gBAAM,QAAQ,GAAG,IAAI,KAAK,KAAK,MAAM,IAAI,QAAQ,UAAU,OAAO,KAAK,GAAG;AAAA,QAC5E;AACA,eAAO;AAAA,MACT;AACA,kBAAK,IAAI,GACF;AAAA,IACT;AAAA;AAAA;;;AC/GA;AAAA;AAAA;AAAA;AAEA,QAAM,QAAQ;AAEd,WAAO,UAAU,CAAC,KAAK,UAAU,CAAC,MAAM;AACtC,UAAI,YAAY,CAAC,MAAM,SAAS,CAAC,MAAM;AACrC,YAAI,eAAe,QAAQ,iBAAiB,MAAM,eAAe,MAAM,GACnE,cAAc,KAAK,YAAY,MAAQ,QAAQ,kBAAkB,IACjE,SAAS;AAEb,YAAI,KAAK;AACP,kBAAK,gBAAgB,gBAAgB,MAAM,cAAc,IAAI,IACpD,OAAO,KAAK,QAEd,KAAK;AAGd,YAAI,KAAK;AACP,iBAAO,KAAK;AAGd,YAAI,KAAK;AACP,mBAAS,SAAS,KAAK;AACrB,sBAAU,UAAU,KAAK;AAG7B,eAAO;AAAA,MACT;AAEA,aAAO,UAAU,GAAG;AAAA,IACtB;AAAA;AAAA;;;AC9BA;AAAA;AAAA;AAAA;AASA,QAAM,OAAO,UAAQ,MAAM,GACrB,eAAe,0BAEf,WAAW,SAAO,QAAQ,QAAQ,OAAO,OAAQ,YAAY,CAAC,MAAM,QAAQ,GAAG,GAE/E,YAAY,cACT,WAAS,aAAa,KAAO,OAAO,KAAK,IAAI,OAAO,KAAK,GAG5D,eAAe,WACZ,OAAO,SAAU,YAAa,OAAO,SAAU,YAAY,UAAU,IAGxE,WAAW,SAAO,OAAO,UAAU,CAAC,GAAG,GAEvC,QAAQ,WAAS;AACrB,UAAI,QAAQ,GAAG,KAAK,IAChB,QAAQ;AAEZ,UADI,MAAM,CAAC,MAAM,QAAK,QAAQ,MAAM,MAAM,CAAC,IACvC,UAAU;AAAK,eAAO;AAC1B,aAAO,MAAM,EAAE,KAAK,MAAM;AAAI;AAC9B,aAAO,QAAQ;AAAA,IACjB,GAEM,YAAY,CAAC,OAAO,KAAK,YACzB,OAAO,SAAU,YAAY,OAAO,OAAQ,WACvC,KAEF,QAAQ,cAAc,IAGzB,MAAM,CAAC,OAAO,WAAW,aAAa;AAC1C,UAAI,YAAY,GAAG;AACjB,YAAI,OAAO,MAAM,CAAC,MAAM,MAAM,MAAM;AACpC,QAAI,SAAM,QAAQ,MAAM,MAAM,CAAC,IAC/B,QAAS,OAAO,MAAM,SAAS,OAAO,YAAY,IAAI,WAAW,GAAG;AAAA,MACtE;AACA,aAAI,aAAa,KACR,OAAO,KAAK,IAEd;AAAA,IACT,GAEM,WAAW,CAAC,OAAO,cAAc;AACrC,UAAI,WAAW,MAAM,CAAC,MAAM,MAAM,MAAM;AAKxC,WAJI,aACF,QAAQ,MAAM,MAAM,CAAC,GACrB,cAEK,MAAM,SAAS;AAAW,gBAAQ,MAAM;AAC/C,aAAO,WAAY,MAAM,QAAS;AAAA,IACpC,GAEM,aAAa,CAAC,OAAO,YAAY;AACrC,YAAM,UAAU,KAAK,CAAC,GAAG,MAAM,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,GACzD,MAAM,UAAU,KAAK,CAAC,GAAG,MAAM,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC;AAEzD,UAAI,SAAS,QAAQ,UAAU,KAAK,MAChC,YAAY,IACZ,YAAY,IACZ;AAgBJ,aAdI,MAAM,UAAU,WAClB,YAAY,MAAM,UAAU,KAAK,GAAG,IAGlC,MAAM,UAAU,WAClB,YAAY,KAAK,MAAM,GAAG,MAAM,UAAU,KAAK,GAAG,CAAC,MAGjD,aAAa,YACf,SAAS,GAAG,SAAS,IAAI,SAAS,KAElC,SAAS,aAAa,WAGpB,QAAQ,OACH,IAAI,MAAM,GAAG,MAAM,MAGrB;AAAA,IACT,GAEM,UAAU,CAAC,GAAG,GAAG,WAAW,YAAY;AAC5C,UAAI;AACF,eAAO,aAAa,GAAG,GAAG,EAAE,MAAM,IAAO,GAAG,QAAQ,CAAC;AAGvD,UAAI,QAAQ,OAAO,aAAa,CAAC;AACjC,UAAI,MAAM;AAAG,eAAO;AAEpB,UAAI,OAAO,OAAO,aAAa,CAAC;AAChC,aAAO,IAAI,KAAK,IAAI,IAAI;AAAA,IAC1B,GAEM,UAAU,CAAC,OAAO,KAAK,YAAY;AACvC,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,YAAI,OAAO,QAAQ,SAAS,IACxB,SAAS,QAAQ,UAAU,KAAK;AACpC,eAAO,OAAO,IAAI,MAAM,GAAG,MAAM,KAAK,GAAG,CAAC,MAAM,MAAM,KAAK,GAAG;AAAA,MAChE;AACA,aAAO,aAAa,OAAO,KAAK,OAAO;AAAA,IACzC,GAEM,aAAa,IAAI,SACd,IAAI,WAAW,8BAA8B,KAAK,QAAQ,GAAG,IAAI,CAAC,GAGrE,eAAe,CAAC,OAAO,KAAK,YAAY;AAC5C,UAAI,QAAQ,iBAAiB;AAAM,cAAM,WAAW,CAAC,OAAO,GAAG,CAAC;AAChE,aAAO,CAAC;AAAA,IACV,GAEM,cAAc,CAAC,MAAM,YAAY;AACrC,UAAI,QAAQ,iBAAiB;AAC3B,cAAM,IAAI,UAAU,kBAAkB,IAAI,kBAAkB;AAE9D,aAAO,CAAC;AAAA,IACV,GAEM,cAAc,CAAC,OAAO,KAAK,OAAO,GAAG,UAAU,CAAC,MAAM;AAC1D,UAAI,IAAI,OAAO,KAAK,GAChB,IAAI,OAAO,GAAG;AAElB,UAAI,CAAC,OAAO,UAAU,CAAC,KAAK,CAAC,OAAO,UAAU,CAAC,GAAG;AAChD,YAAI,QAAQ,iBAAiB;AAAM,gBAAM,WAAW,CAAC,OAAO,GAAG,CAAC;AAChE,eAAO,CAAC;AAAA,MACV;AAGA,MAAI,MAAM,MAAG,IAAI,IACb,MAAM,MAAG,IAAI;AAEjB,UAAI,aAAa,IAAI,GACjB,cAAc,OAAO,KAAK,GAC1B,YAAY,OAAO,GAAG,GACtB,aAAa,OAAO,IAAI;AAC5B,aAAO,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,CAAC;AAEjC,UAAI,SAAS,MAAM,WAAW,KAAK,MAAM,SAAS,KAAK,MAAM,UAAU,GACnE,SAAS,SAAS,KAAK,IAAI,YAAY,QAAQ,UAAU,QAAQ,WAAW,MAAM,IAAI,GACtF,WAAW,WAAW,MAAS,UAAU,OAAO,KAAK,OAAO,MAAM,IAClE,SAAS,QAAQ,aAAa,UAAU,QAAQ;AAEpD,UAAI,QAAQ,WAAW,SAAS;AAC9B,eAAO,QAAQ,SAAS,OAAO,MAAM,GAAG,SAAS,KAAK,MAAM,GAAG,IAAM,OAAO;AAG9E,UAAI,QAAQ,EAAE,WAAW,CAAC,GAAG,WAAW,CAAC,EAAE,GACvC,OAAO,SAAO,MAAM,MAAM,IAAI,cAAc,WAAW,EAAE,KAAK,KAAK,IAAI,GAAG,CAAC,GAC3E,QAAQ,CAAC,GACT,QAAQ;AAEZ,aAAO,aAAa,KAAK,IAAI,KAAK;AAChC,QAAI,QAAQ,YAAY,MAAQ,OAAO,IACrC,KAAK,CAAC,IAEN,MAAM,KAAK,IAAI,OAAO,GAAG,KAAK,GAAG,QAAQ,QAAQ,CAAC,GAEpD,IAAI,aAAa,IAAI,OAAO,IAAI,MAChC;AAGF,aAAI,QAAQ,YAAY,KACf,OAAO,IACV,WAAW,OAAO,OAAO,IACzB,QAAQ,OAAO,MAAM,EAAE,MAAM,IAAO,GAAG,QAAQ,CAAC,IAG/C;AAAA,IACT,GAEM,cAAc,CAAC,OAAO,KAAK,OAAO,GAAG,UAAU,CAAC,MAAM;AAC1D,UAAK,CAAC,SAAS,KAAK,KAAK,MAAM,SAAS,KAAO,CAAC,SAAS,GAAG,KAAK,IAAI,SAAS;AAC5E,eAAO,aAAa,OAAO,KAAK,OAAO;AAIzC,UAAI,SAAS,QAAQ,cAAc,SAAO,OAAO,aAAa,GAAG,IAC7D,IAAI,GAAG,KAAK,GAAG,WAAW,CAAC,GAC3B,IAAI,GAAG,GAAG,GAAG,WAAW,CAAC,GAEzB,aAAa,IAAI,GACjB,MAAM,KAAK,IAAI,GAAG,CAAC,GACnB,MAAM,KAAK,IAAI,GAAG,CAAC;AAEvB,UAAI,QAAQ,WAAW,SAAS;AAC9B,eAAO,QAAQ,KAAK,KAAK,IAAO,OAAO;AAGzC,UAAI,QAAQ,CAAC,GACT,QAAQ;AAEZ,aAAO,aAAa,KAAK,IAAI,KAAK;AAChC,cAAM,KAAK,OAAO,GAAG,KAAK,CAAC,GAC3B,IAAI,aAAa,IAAI,OAAO,IAAI,MAChC;AAGF,aAAI,QAAQ,YAAY,KACf,QAAQ,OAAO,MAAM,EAAE,MAAM,IAAO,QAAQ,CAAC,IAG/C;AAAA,IACT,GAEM,OAAO,CAAC,OAAO,KAAK,MAAM,UAAU,CAAC,MAAM;AAC/C,UAAI,OAAO,QAAQ,aAAa,KAAK;AACnC,eAAO,CAAC,KAAK;AAGf,UAAI,CAAC,aAAa,KAAK,KAAK,CAAC,aAAa,GAAG;AAC3C,eAAO,aAAa,OAAO,KAAK,OAAO;AAGzC,UAAI,OAAO,QAAS;AAClB,eAAO,KAAK,OAAO,KAAK,GAAG,EAAE,WAAW,KAAK,CAAC;AAGhD,UAAI,SAAS,IAAI;AACf,eAAO,KAAK,OAAO,KAAK,GAAG,IAAI;AAGjC,UAAI,OAAO,EAAE,GAAG,QAAQ;AAIxB,aAHI,KAAK,YAAY,OAAM,KAAK,OAAO,KACvC,OAAO,QAAQ,KAAK,QAAQ,GAEvB,SAAS,IAAI,IAKd,SAAS,KAAK,KAAK,SAAS,GAAG,IAC1B,YAAY,OAAO,KAAK,MAAM,IAAI,IAGpC,YAAY,OAAO,KAAK,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,CAAC,GAAG,IAAI,IAR1D,QAAQ,QAAQ,CAAC,SAAS,IAAI,IAAU,YAAY,MAAM,IAAI,IAC3D,KAAK,OAAO,KAAK,GAAG,IAAI;AAAA,IAQnC;AAEA,WAAO,UAAU;AAAA;AAAA;;;ACxPjB;AAAA;AAAA;AAAA;AAEA,QAAM,OAAO,sBACP,QAAQ,iBAER,UAAU,CAAC,KAAK,UAAU,CAAC,MAAM;AACrC,UAAI,OAAO,CAAC,MAAM,SAAS,CAAC,MAAM;AAChC,YAAI,eAAe,MAAM,eAAe,MAAM,GAC1C,cAAc,KAAK,YAAY,MAAQ,QAAQ,kBAAkB,IACjE,UAAU,iBAAiB,MAAQ,gBAAgB,IACnD,SAAS,QAAQ,kBAAkB,KAAO,OAAO,IACjD,SAAS;AAKb,YAHI,KAAK,WAAW,MAGhB,KAAK,YAAY;AACnB,iBAAO,SAAS,KAAK;AAGvB,YAAI,KAAK,SAAS;AAChB,iBAAO,UAAW,SAAS,KAAK,QAAS;AAG3C,YAAI,KAAK,SAAS;AAChB,iBAAO,UAAW,SAAS,KAAK,QAAS;AAG3C,YAAI,KAAK,SAAS;AAChB,iBAAO,KAAK,KAAK,SAAS,UAAU,KAAM,UAAU,KAAK,QAAQ;AAGnE,YAAI,KAAK;AACP,iBAAO,KAAK;AAGd,YAAI,KAAK,SAAS,KAAK,SAAS,GAAG;AACjC,cAAI,OAAO,MAAM,OAAO,KAAK,KAAK,GAC9B,QAAQ,KAAK,GAAG,MAAM,EAAE,GAAG,SAAS,MAAM,IAAO,SAAS,GAAK,CAAC;AAEpE,cAAI,MAAM,WAAW;AACnB,mBAAO,KAAK,SAAS,KAAK,MAAM,SAAS,IAAI,IAAI,KAAK,MAAM;AAAA,QAEhE;AAEA,YAAI,KAAK;AACP,mBAAS,SAAS,KAAK;AACrB,sBAAU,KAAK,OAAO,IAAI;AAG9B,eAAO;AAAA,MACT;AAEA,aAAO,KAAK,GAAG;AAAA,IACjB;AAEA,WAAO,UAAU;AAAA;AAAA;;;ACxDjB;AAAA;AAAA;AAAA;AAEA,QAAM,OAAO,sBACP,YAAY,qBACZ,QAAQ,iBAER,SAAS,CAAC,QAAQ,IAAI,QAAQ,IAAI,UAAU,OAAU;AAC1D,UAAI,SAAS,CAAC;AAKd,UAHA,QAAQ,CAAC,EAAE,OAAO,KAAK,GACvB,QAAQ,CAAC,EAAE,OAAO,KAAK,GAEnB,CAAC,MAAM;AAAQ,eAAO;AAC1B,UAAI,CAAC,MAAM;AACT,eAAO,UAAU,MAAM,QAAQ,KAAK,EAAE,IAAI,SAAO,IAAI,GAAG,GAAG,IAAI;AAGjE,eAAS,QAAQ;AACf,YAAI,MAAM,QAAQ,IAAI;AACpB,mBAAS,SAAS;AAChB,mBAAO,KAAK,OAAO,OAAO,OAAO,OAAO,CAAC;AAAA;AAG3C,mBAAS,OAAO;AACd,YAAI,YAAY,MAAQ,OAAO,OAAQ,aAAU,MAAM,IAAI,GAAG,MAC9D,OAAO,KAAK,MAAM,QAAQ,GAAG,IAAI,OAAO,MAAM,KAAK,OAAO,IAAK,OAAO,GAAI;AAIhF,aAAO,MAAM,QAAQ,MAAM;AAAA,IAC7B,GAEM,SAAS,CAAC,KAAK,UAAU,CAAC,MAAM;AACpC,UAAI,aAAa,QAAQ,eAAe,SAAS,MAAO,QAAQ,YAE5D,OAAO,CAAC,MAAM,SAAS,CAAC,MAAM;AAChC,aAAK,QAAQ,CAAC;AAEd,YAAI,IAAI,QACJ,IAAI,OAAO;AAEf,eAAO,EAAE,SAAS,WAAW,EAAE,SAAS,UAAU,EAAE;AAClD,cAAI,EAAE,QACN,IAAI,EAAE;AAGR,YAAI,KAAK,WAAW,KAAK,QAAQ;AAC/B,YAAE,KAAK,OAAO,EAAE,IAAI,GAAG,UAAU,MAAM,OAAO,CAAC,CAAC;AAChD;AAAA,QACF;AAEA,YAAI,KAAK,SAAS,WAAW,KAAK,YAAY,MAAQ,KAAK,MAAM,WAAW,GAAG;AAC7E,YAAE,KAAK,OAAO,EAAE,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;AAC9B;AAAA,QACF;AAEA,YAAI,KAAK,SAAS,KAAK,SAAS,GAAG;AACjC,cAAI,OAAO,MAAM,OAAO,KAAK,KAAK;AAElC,cAAI,MAAM,aAAa,GAAG,MAAM,QAAQ,MAAM,UAAU;AACtD,kBAAM,IAAI,WAAW,qGAAqG;AAG5H,cAAI,QAAQ,KAAK,GAAG,MAAM,OAAO;AACjC,UAAI,MAAM,WAAW,MACnB,QAAQ,UAAU,MAAM,OAAO,IAGjC,EAAE,KAAK,OAAO,EAAE,IAAI,GAAG,KAAK,CAAC,GAC7B,KAAK,QAAQ,CAAC;AACd;AAAA,QACF;AAEA,YAAI,UAAU,MAAM,aAAa,IAAI,GACjC,QAAQ,KAAK,OACb,QAAQ;AAEZ,eAAO,MAAM,SAAS,WAAW,MAAM,SAAS,UAAU,MAAM;AAC9D,kBAAQ,MAAM,QACd,QAAQ,MAAM;AAGhB,iBAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AAC1C,cAAI,QAAQ,KAAK,MAAM,CAAC;AAExB,cAAI,MAAM,SAAS,WAAW,KAAK,SAAS,SAAS;AACnD,YAAI,MAAM,KAAG,MAAM,KAAK,EAAE,GAC1B,MAAM,KAAK,EAAE;AACb;AAAA,UACF;AAEA,cAAI,MAAM,SAAS,SAAS;AAC1B,cAAE,KAAK,OAAO,EAAE,IAAI,GAAG,OAAO,OAAO,CAAC;AACtC;AAAA,UACF;AAEA,cAAI,MAAM,SAAS,MAAM,SAAS,QAAQ;AACxC,kBAAM,KAAK,OAAO,MAAM,IAAI,GAAG,MAAM,KAAK,CAAC;AAC3C;AAAA,UACF;AAEA,UAAI,MAAM,SACR,KAAK,OAAO,IAAI;AAAA,QAEpB;AAEA,eAAO;AAAA,MACT;AAEA,aAAO,MAAM,QAAQ,KAAK,GAAG,CAAC;AAAA,IAChC;AAEA,WAAO,UAAU;AAAA;AAAA;;;AChHjB;AAAA;AAAA;AAAA;AAEA,WAAO,UAAU;AAAA,MACf,YAAY,OAAO;AAAA;AAAA,MAGnB,QAAQ;AAAA;AAAA,MACR,QAAQ;AAAA;AAAA;AAAA,MAGR,kBAAkB;AAAA;AAAA,MAClB,kBAAkB;AAAA;AAAA,MAClB,kBAAkB;AAAA;AAAA,MAClB,kBAAkB;AAAA;AAAA,MAElB,uBAAuB;AAAA;AAAA,MACvB,wBAAwB;AAAA;AAAA,MAExB,eAAe;AAAA;AAAA;AAAA,MAGf,gBAAgB;AAAA;AAAA,MAChB,SAAS;AAAA;AAAA,MACT,gBAAgB;AAAA;AAAA,MAChB,eAAe;AAAA;AAAA,MACf,sBAAsB;AAAA;AAAA,MACtB,wBAAwB;AAAA;AAAA,MACxB,YAAY;AAAA;AAAA,MACZ,YAAY;AAAA;AAAA,MACZ,aAAa;AAAA;AAAA,MACb,UAAU;AAAA;AAAA,MACV,mBAAmB;AAAA;AAAA,MACnB,YAAY;AAAA;AAAA,MACZ,uBAAuB;AAAA;AAAA,MACvB,gBAAgB;AAAA;AAAA,MAChB,oBAAoB;AAAA;AAAA,MACpB,WAAW;AAAA;AAAA,MACX,mBAAmB;AAAA;AAAA,MACnB,yBAAyB;AAAA;AAAA,MACzB,uBAAuB;AAAA;AAAA,MACvB,0BAA0B;AAAA;AAAA,MAC1B,gBAAgB;AAAA;AAAA;AAAA,MAChB,qBAAqB;AAAA;AAAA,MACrB,cAAc;AAAA;AAAA,MACd,WAAW;AAAA;AAAA,MACX,oBAAoB;AAAA;AAAA,MACpB,0BAA0B;AAAA;AAAA,MAC1B,wBAAwB;AAAA;AAAA,MACxB,2BAA2B;AAAA;AAAA,MAC3B,gBAAgB;AAAA;AAAA,MAChB,mBAAmB;AAAA;AAAA,MACnB,YAAY;AAAA;AAAA,MACZ,UAAU;AAAA;AAAA,MACV,iBAAiB;AAAA;AAAA,MACjB,oBAAoB;AAAA;AAAA,MACpB,+BAA+B;AAAA;AAAA,IACjC;AAAA;AAAA;;;ACxDA;AAAA;AAAA;AAAA;AAEA,QAAM,YAAY,qBAMZ;AAAA,MACJ;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI,qBAME,QAAQ,CAAC,OAAO,UAAU,CAAC,MAAM;AACrC,UAAI,OAAO,SAAU;AACnB,cAAM,IAAI,UAAU,mBAAmB;AAGzC,UAAI,OAAO,WAAW,CAAC,GACnB,MAAM,OAAO,KAAK,aAAc,WAAW,KAAK,IAAI,YAAY,KAAK,SAAS,IAAI;AACtF,UAAI,MAAM,SAAS;AACjB,cAAM,IAAI,YAAY,iBAAiB,MAAM,MAAM,8BAA8B,GAAG,GAAG;AAGzF,UAAI,MAAM,EAAE,MAAM,QAAQ,OAAO,OAAO,CAAC,EAAE,GACvC,QAAQ,CAAC,GAAG,GACZ,QAAQ,KACR,OAAO,KACP,WAAW,GACX,SAAS,MAAM,QACf,QAAQ,GACR,QAAQ,GACR,OACA,OAAO,CAAC,GAMN,UAAU,MAAM,MAAM,OAAO,GAC7B,OAAO,UAAQ;AAKnB,YAJI,KAAK,SAAS,UAAU,KAAK,SAAS,UACxC,KAAK,OAAO,SAGV,QAAQ,KAAK,SAAS,UAAU,KAAK,SAAS,QAAQ;AACxD,eAAK,SAAS,KAAK;AACnB;AAAA,QACF;AAEA,qBAAM,MAAM,KAAK,IAAI,GACrB,KAAK,SAAS,OACd,KAAK,OAAO,MACZ,OAAO,MACA;AAAA,MACT;AAIA,WAFA,KAAK,EAAE,MAAM,MAAM,CAAC,GAEb,QAAQ;AAQb,YAPA,QAAQ,MAAM,MAAM,SAAS,CAAC,GAC9B,QAAQ,QAAQ,GAMZ,YAAU,iCAAiC,UAAU,sBAQzD;AAAA,cAAI,UAAU,gBAAgB;AAC5B,iBAAK,EAAE,MAAM,QAAQ,QAAQ,QAAQ,eAAe,QAAQ,MAAM,QAAQ,EAAE,CAAC;AAC7E;AAAA,UACF;AAMA,cAAI,UAAU,2BAA2B;AACvC,iBAAK,EAAE,MAAM,QAAQ,OAAO,OAAO,MAAM,CAAC;AAC1C;AAAA,UACF;AAMA,cAAI,UAAU,0BAA0B;AACtC;AAEA,gBAAI,SAAS,IACT;AAEJ,mBAAO,QAAQ,WAAW,OAAO,QAAQ,MAAI;AAG3C,kBAFA,SAAS,MAEL,SAAS,0BAA0B;AACrC;AACA;AAAA,cACF;AAEA,kBAAI,SAAS,gBAAgB;AAC3B,yBAAS,QAAQ;AACjB;AAAA,cACF;AAEA,kBAAI,SAAS,8BACX,YAEI,aAAa;AACf;AAAA,YAGN;AAEA,iBAAK,EAAE,MAAM,QAAQ,MAAM,CAAC;AAC5B;AAAA,UACF;AAMA,cAAI,UAAU,uBAAuB;AACnC,oBAAQ,KAAK,EAAE,MAAM,SAAS,OAAO,CAAC,EAAE,CAAC,GACzC,MAAM,KAAK,KAAK,GAChB,KAAK,EAAE,MAAM,QAAQ,MAAM,CAAC;AAC5B;AAAA,UACF;AAEA,cAAI,UAAU,wBAAwB;AACpC,gBAAI,MAAM,SAAS,SAAS;AAC1B,mBAAK,EAAE,MAAM,QAAQ,MAAM,CAAC;AAC5B;AAAA,YACF;AACA,oBAAQ,MAAM,IAAI,GAClB,KAAK,EAAE,MAAM,QAAQ,MAAM,CAAC,GAC5B,QAAQ,MAAM,MAAM,SAAS,CAAC;AAC9B;AAAA,UACF;AAMA,cAAI,UAAU,qBAAqB,UAAU,qBAAqB,UAAU,eAAe;AACzF,gBAAI,OAAO,OACP;AAMJ,iBAJI,QAAQ,eAAe,OACzB,QAAQ,KAGH,QAAQ,WAAW,OAAO,QAAQ,MAAI;AAC3C,kBAAI,SAAS,gBAAgB;AAC3B,yBAAS,OAAO,QAAQ;AACxB;AAAA,cACF;AAEA,kBAAI,SAAS,MAAM;AACjB,gBAAI,QAAQ,eAAe,OAAM,SAAS;AAC1C;AAAA,cACF;AAEA,uBAAS;AAAA,YACX;AAEA,iBAAK,EAAE,MAAM,QAAQ,MAAM,CAAC;AAC5B;AAAA,UACF;AAMA,cAAI,UAAU,uBAAuB;AACnC;AAGA,gBAAI,QAAQ;AAAA,cACV,MAAM;AAAA,cACN,MAAM;AAAA,cACN,OAAO;AAAA,cACP,QALW,KAAK,SAAS,KAAK,MAAM,MAAM,EAAE,MAAM,OAAO,MAAM,WAAW;AAAA,cAM1E;AAAA,cACA,QAAQ;AAAA,cACR,QAAQ;AAAA,cACR,OAAO,CAAC;AAAA,YACV;AAEA,oBAAQ,KAAK,KAAK,GAClB,MAAM,KAAK,KAAK,GAChB,KAAK,EAAE,MAAM,QAAQ,MAAM,CAAC;AAC5B;AAAA,UACF;AAMA,cAAI,UAAU,wBAAwB;AACpC,gBAAI,MAAM,SAAS,SAAS;AAC1B,mBAAK,EAAE,MAAM,QAAQ,MAAM,CAAC;AAC5B;AAAA,YACF;AAEA,gBAAI,OAAO;AACX,oBAAQ,MAAM,IAAI,GAClB,MAAM,QAAQ,IAEd,KAAK,EAAE,MAAM,MAAM,CAAC,GACpB,SAEA,QAAQ,MAAM,MAAM,SAAS,CAAC;AAC9B;AAAA,UACF;AAMA,cAAI,UAAU,cAAc,QAAQ,GAAG;AACrC,gBAAI,MAAM,SAAS,GAAG;AACpB,oBAAM,SAAS;AACf,kBAAI,OAAO,MAAM,MAAM,MAAM;AAC7B,oBAAM,QAAQ,CAAC,MAAM,EAAE,MAAM,QAAQ,OAAO,UAAU,KAAK,EAAE,CAAC;AAAA,YAChE;AAEA,iBAAK,EAAE,MAAM,SAAS,MAAM,CAAC,GAC7B,MAAM;AACN;AAAA,UACF;AAMA,cAAI,UAAU,YAAY,QAAQ,KAAK,MAAM,WAAW,GAAG;AACzD,gBAAI,WAAW,MAAM;AAErB,gBAAI,UAAU,KAAK,SAAS,WAAW,GAAG;AACxC,mBAAK,EAAE,MAAM,QAAQ,MAAM,CAAC;AAC5B;AAAA,YACF;AAEA,gBAAI,KAAK,SAAS,OAAO;AAKvB,kBAJA,MAAM,QAAQ,CAAC,GACf,KAAK,SAAS,OACd,KAAK,OAAO,SAER,MAAM,MAAM,WAAW,KAAK,MAAM,MAAM,WAAW,GAAG;AACxD,sBAAM,UAAU,IAChB,MAAM,SAAS,GACf,KAAK,OAAO;AACZ;AAAA,cACF;AAEA,oBAAM,UACN,MAAM,OAAO,CAAC;AACd;AAAA,YACF;AAEA,gBAAI,KAAK,SAAS,SAAS;AACzB,uBAAS,IAAI;AAEb,kBAAI,SAAS,SAAS,SAAS,SAAS,CAAC;AACzC,qBAAO,SAAS,KAAK,QAAQ,OAC7B,OAAO,QACP,MAAM;AACN;AAAA,YACF;AAEA,iBAAK,EAAE,MAAM,OAAO,MAAM,CAAC;AAC3B;AAAA,UACF;AAMA,eAAK,EAAE,MAAM,QAAQ,MAAM,CAAC;AAAA;AAI9B;AAGE,YAFA,QAAQ,MAAM,IAAI,GAEd,MAAM,SAAS,QAAQ;AACzB,gBAAM,MAAM,QAAQ,UAAQ;AAC1B,YAAK,KAAK,UACJ,KAAK,SAAS,WAAQ,KAAK,SAAS,KACpC,KAAK,SAAS,YAAS,KAAK,UAAU,KACrC,KAAK,UAAO,KAAK,OAAO,SAC7B,KAAK,UAAU;AAAA,UAEnB,CAAC;AAGD,cAAI,SAAS,MAAM,MAAM,SAAS,CAAC,GAC/BC,SAAQ,OAAO,MAAM,QAAQ,KAAK;AAEtC,iBAAO,MAAM,OAAOA,QAAO,GAAG,GAAG,MAAM,KAAK;AAAA,QAC9C;AAAA,aACO,MAAM,SAAS;AAExB,kBAAK,EAAE,MAAM,MAAM,CAAC,GACb;AAAA,IACT;AAEA,WAAO,UAAU;AAAA;AAAA;;;AC5UjB;AAAA;AAAA;AAAA;AAEA,QAAM,YAAY,qBACZ,UAAU,mBACV,SAAS,kBACT,QAAQ,iBAgBR,SAAS,CAAC,OAAO,UAAU,CAAC,MAAM;AACtC,UAAI,SAAS,CAAC;AAEd,UAAI,MAAM,QAAQ,KAAK;AACrB,iBAAS,WAAW,OAAO;AACzB,cAAI,SAAS,OAAO,OAAO,SAAS,OAAO;AAC3C,UAAI,MAAM,QAAQ,MAAM,IACtB,OAAO,KAAK,GAAG,MAAM,IAErB,OAAO,KAAK,MAAM;AAAA,QAEtB;AAAA;AAEA,iBAAS,CAAC,EAAE,OAAO,OAAO,OAAO,OAAO,OAAO,CAAC;AAGlD,aAAI,WAAW,QAAQ,WAAW,MAAQ,QAAQ,YAAY,OAC5D,SAAS,CAAC,GAAG,IAAI,IAAI,MAAM,CAAC,IAEvB;AAAA,IACT;AAgBA,WAAO,QAAQ,CAAC,OAAO,UAAU,CAAC,MAAM,MAAM,OAAO,OAAO;AAgB5D,WAAO,YAAY,CAAC,OAAO,UAAU,CAAC,MAE3B,UADL,OAAO,SAAU,WACF,OAAO,MAAM,OAAO,OAAO,IAE7B,OAFgC,OAAO;AAoB1D,WAAO,UAAU,CAAC,OAAO,UAAU,CAAC,OAC9B,OAAO,SAAU,aACnB,QAAQ,OAAO,MAAM,OAAO,OAAO,IAE9B,QAAQ,OAAO,OAAO;AAoB/B,WAAO,SAAS,CAAC,OAAO,UAAU,CAAC,MAAM;AACvC,MAAI,OAAO,SAAU,aACnB,QAAQ,OAAO,MAAM,OAAO,OAAO;AAGrC,UAAI,SAAS,OAAO,OAAO,OAAO;AAGlC,aAAI,QAAQ,YAAY,OACtB,SAAS,OAAO,OAAO,OAAO,IAI5B,QAAQ,YAAY,OACtB,SAAS,CAAC,GAAG,IAAI,IAAI,MAAM,CAAC,IAGvB;AAAA,IACT;AAkBA,WAAO,SAAS,CAAC,OAAO,UAAU,CAAC,MAC7B,UAAU,MAAM,MAAM,SAAS,IAC1B,CAAC,KAAK,IAGT,QAAQ,WAAW,KACrB,OAAO,QAAQ,OAAO,OAAO,IAC7B,OAAO,OAAO,OAAO,OAAO;AAOlC,WAAO,UAAU;AAAA;AAAA;;;ACzKjB;AAAA;AAAA;AAAA,MACC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AA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",
  "names": ["testString", "node", "index", "require_binary_extensions", "require_constants", "rawEmitter", "listener", "newStats", "stats", "path", "now", "stat"]
}
